const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./Home-B7j9ZMVE.js","./Home-BNLohJCA.css","./Art-BIm3KAoV.js","./Art-BbEiMmZ4.css","./Code-I1ya4v3_.js","./Code-EeilDvri.css","./Auth-aEzh_JkD.js","./Auth-BohRWEJM.css","./NotFound-BusaW-sW.js","./NotFound-LKaI2yC2.css"])))=>i.map(i=>d[i]);
(function(){const s=document.createElement("link").relList;if(s&&s.supports&&s.supports("modulepreload"))return;for(const f of document.querySelectorAll('link[rel="modulepreload"]'))d(f);new MutationObserver(f=>{for(const v of f)if(v.type==="childList")for(const _ of v.addedNodes)_.tagName==="LINK"&&_.rel==="modulepreload"&&d(_)}).observe(document,{childList:!0,subtree:!0});function l(f){const v={};return f.integrity&&(v.integrity=f.integrity),f.referrerPolicy&&(v.referrerPolicy=f.referrerPolicy),f.crossOrigin==="use-credentials"?v.credentials="include":f.crossOrigin==="anonymous"?v.credentials="omit":v.credentials="same-origin",v}function d(f){if(f.ep)return;f.ep=!0;const v=l(f);fetch(f.href,v)}})();/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */(function(n,s){typeof exports=="object"&&typeof module<"u"?s(exports):typeof define=="function"&&define.amd?define(["exports"],s):s((n=typeof globalThis<"u"?globalThis:n||self).THREE={})})(void 0,function(n){const s="128",we="300 es";class ce{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const r=this._listeners;r[e]===void 0&&(r[e]=[]),r[e].indexOf(t)===-1&&r[e].push(t)}hasEventListener(e,t){if(this._listeners===void 0)return!1;const r=this._listeners;return r[e]!==void 0&&r[e].indexOf(t)!==-1}removeEventListener(e,t){if(this._listeners===void 0)return;const r=this._listeners[e];if(r!==void 0){const i=r.indexOf(t);i!==-1&&r.splice(i,1)}}dispatchEvent(e){if(this._listeners===void 0)return;const t=this._listeners[e.type];if(t!==void 0){e.target=this;const r=t.slice(0);for(let i=0,a=r.length;i<a;i++)r[i].call(this,e);e.target=null}}}const He=[];for(let o=0;o<256;o++)He[o]=(o<16?"0":"")+o.toString(16);let Le=1234567;const Ue=Math.PI/180,tt=180/Math.PI;function it(){const o=4294967295*Math.random()|0,e=4294967295*Math.random()|0,t=4294967295*Math.random()|0,r=4294967295*Math.random()|0;return(He[255&o]+He[o>>8&255]+He[o>>16&255]+He[o>>24&255]+"-"+He[255&e]+He[e>>8&255]+"-"+He[e>>16&15|64]+He[e>>24&255]+"-"+He[63&t|128]+He[t>>8&255]+"-"+He[t>>16&255]+He[t>>24&255]+He[255&r]+He[r>>8&255]+He[r>>16&255]+He[r>>24&255]).toUpperCase()}function ct(o,e,t){return Math.max(e,Math.min(t,o))}function Rt(o,e){return(o%e+e)%e}function nn(o,e,t){return(1-t)*o+t*e}function pn(o){return(o&o-1)==0&&o!==0}function Zn(o){return Math.pow(2,Math.ceil(Math.log(o)/Math.LN2))}function Kn(o){return Math.pow(2,Math.floor(Math.log(o)/Math.LN2))}var hi=Object.freeze({__proto__:null,DEG2RAD:Ue,RAD2DEG:tt,generateUUID:it,clamp:ct,euclideanModulo:Rt,mapLinear:function(o,e,t,r,i){return r+(o-e)*(i-r)/(t-e)},inverseLerp:function(o,e,t){return o!==e?(t-o)/(e-o):0},lerp:nn,damp:function(o,e,t,r){return nn(o,e,1-Math.exp(-t*r))},pingpong:function(o,e=1){return e-Math.abs(Rt(o,2*e)-e)},smoothstep:function(o,e,t){return o<=e?0:o>=t?1:(o=(o-e)/(t-e))*o*(3-2*o)},smootherstep:function(o,e,t){return o<=e?0:o>=t?1:(o=(o-e)/(t-e))*o*o*(o*(6*o-15)+10)},randInt:function(o,e){return o+Math.floor(Math.random()*(e-o+1))},randFloat:function(o,e){return o+Math.random()*(e-o)},randFloatSpread:function(o){return o*(.5-Math.random())},seededRandom:function(o){return o!==void 0&&(Le=o%2147483647),Le=16807*Le%2147483647,(Le-1)/2147483646},degToRad:function(o){return o*Ue},radToDeg:function(o){return o*tt},isPowerOfTwo:pn,ceilPowerOfTwo:Zn,floorPowerOfTwo:Kn,setQuaternionFromProperEuler:function(o,e,t,r,i){const a=Math.cos,c=Math.sin,u=a(t/2),h=c(t/2),p=a((e+r)/2),m=c((e+r)/2),g=a((e-r)/2),y=c((e-r)/2),x=a((r-e)/2),b=c((r-e)/2);switch(i){case"XYX":o.set(u*m,h*g,h*y,u*p);break;case"YZY":o.set(h*y,u*m,h*g,u*p);break;case"ZXZ":o.set(h*g,h*y,u*m,u*p);break;case"XZX":o.set(u*m,h*b,h*x,u*p);break;case"YXY":o.set(h*x,u*m,h*b,u*p);break;case"ZYZ":o.set(h*b,h*x,u*m,u*p);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+i)}}});class Ee{constructor(e=0,t=0){this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this)}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this)}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,r=this.y,i=e.elements;return this.x=i[0]*t+i[3]*r+i[6],this.y=i[1]*t+i[4]*r+i[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const r=this.length();return this.divideScalar(r||1).multiplyScalar(Math.max(e,Math.min(t,r)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,r=this.y-e.y;return t*t+r*r}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,r){return this.x=e.x+(t.x-e.x)*r,this.y=e.y+(t.y-e.y)*r,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t,r){return r!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const r=Math.cos(t),i=Math.sin(t),a=this.x-e.x,c=this.y-e.y;return this.x=a*r-c*i+e.x,this.y=a*i+c*r+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}}Ee.prototype.isVector2=!0;class St{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(e,t,r,i,a,c,u,h,p){const m=this.elements;return m[0]=e,m[1]=i,m[2]=u,m[3]=t,m[4]=a,m[5]=h,m[6]=r,m[7]=c,m[8]=p,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,r=e.elements;return t[0]=r[0],t[1]=r[1],t[2]=r[2],t[3]=r[3],t[4]=r[4],t[5]=r[5],t[6]=r[6],t[7]=r[7],t[8]=r[8],this}extractBasis(e,t,r){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),r.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const r=e.elements,i=t.elements,a=this.elements,c=r[0],u=r[3],h=r[6],p=r[1],m=r[4],g=r[7],y=r[2],x=r[5],b=r[8],S=i[0],M=i[3],A=i[6],I=i[1],k=i[4],N=i[7],G=i[2],U=i[5],B=i[8];return a[0]=c*S+u*I+h*G,a[3]=c*M+u*k+h*U,a[6]=c*A+u*N+h*B,a[1]=p*S+m*I+g*G,a[4]=p*M+m*k+g*U,a[7]=p*A+m*N+g*B,a[2]=y*S+x*I+b*G,a[5]=y*M+x*k+b*U,a[8]=y*A+x*N+b*B,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],r=e[1],i=e[2],a=e[3],c=e[4],u=e[5],h=e[6],p=e[7],m=e[8];return t*c*m-t*u*p-r*a*m+r*u*h+i*a*p-i*c*h}invert(){const e=this.elements,t=e[0],r=e[1],i=e[2],a=e[3],c=e[4],u=e[5],h=e[6],p=e[7],m=e[8],g=m*c-u*p,y=u*h-m*a,x=p*a-c*h,b=t*g+r*y+i*x;if(b===0)return this.set(0,0,0,0,0,0,0,0,0);const S=1/b;return e[0]=g*S,e[1]=(i*p-m*r)*S,e[2]=(u*r-i*c)*S,e[3]=y*S,e[4]=(m*t-i*h)*S,e[5]=(i*a-u*t)*S,e[6]=x*S,e[7]=(r*h-p*t)*S,e[8]=(c*t-r*a)*S,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,r,i,a,c,u){const h=Math.cos(a),p=Math.sin(a);return this.set(r*h,r*p,-r*(h*c+p*u)+c+e,-i*p,i*h,-i*(-p*c+h*u)+u+t,0,0,1),this}scale(e,t){const r=this.elements;return r[0]*=e,r[3]*=e,r[6]*=e,r[1]*=t,r[4]*=t,r[7]*=t,this}rotate(e){const t=Math.cos(e),r=Math.sin(e),i=this.elements,a=i[0],c=i[3],u=i[6],h=i[1],p=i[4],m=i[7];return i[0]=t*a+r*h,i[3]=t*c+r*p,i[6]=t*u+r*m,i[1]=-r*a+t*h,i[4]=-r*c+t*p,i[7]=-r*u+t*m,this}translate(e,t){const r=this.elements;return r[0]+=e*r[2],r[3]+=e*r[5],r[6]+=e*r[8],r[1]+=t*r[2],r[4]+=t*r[5],r[7]+=t*r[8],this}equals(e){const t=this.elements,r=e.elements;for(let i=0;i<9;i++)if(t[i]!==r[i])return!1;return!0}fromArray(e,t=0){for(let r=0;r<9;r++)this.elements[r]=e[r+t];return this}toArray(e=[],t=0){const r=this.elements;return e[t]=r[0],e[t+1]=r[1],e[t+2]=r[2],e[t+3]=r[3],e[t+4]=r[4],e[t+5]=r[5],e[t+6]=r[6],e[t+7]=r[7],e[t+8]=r[8],e}clone(){return new this.constructor().fromArray(this.elements)}}let wn;St.prototype.isMatrix3=!0;class Er{static getDataURL(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement>"u")return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{wn===void 0&&(wn=document.createElementNS("http://www.w3.org/1999/xhtml","canvas")),wn.width=e.width,wn.height=e.height;const r=wn.getContext("2d");e instanceof ImageData?r.putImageData(e,0,0):r.drawImage(e,0,0,e.width,e.height),t=wn}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}}let Ra=0;class un extends ce{constructor(e=un.DEFAULT_IMAGE,t=un.DEFAULT_MAPPING,r=1001,i=1001,a=1006,c=1008,u=1023,h=1009,p=1,m=3e3){super(),Object.defineProperty(this,"id",{value:Ra++}),this.uuid=it(),this.name="",this.image=e,this.mipmaps=[],this.mapping=t,this.wrapS=r,this.wrapT=i,this.magFilter=a,this.minFilter=c,this.anisotropy=p,this.format=u,this.internalFormat=null,this.type=h,this.offset=new Ee(0,0),this.repeat=new Ee(1,1),this.center=new Ee(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new St,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=m,this.version=0,this.onUpdate=null}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.image=e.image,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.encoding=e.encoding,this}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const r={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(this.image!==void 0){const i=this.image;if(i.uuid===void 0&&(i.uuid=it()),!t&&e.images[i.uuid]===void 0){let a;if(Array.isArray(i)){a=[];for(let c=0,u=i.length;c<u;c++)i[c].isDataTexture?a.push(zc(i[c].image)):a.push(zc(i[c]))}else a=zc(i);e.images[i.uuid]={uuid:i.uuid,url:a}}r.image=i.uuid}return t||(e.textures[this.uuid]=r),r}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==300)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case 1e3:e.x=e.x-Math.floor(e.x);break;case 1001:e.x=e.x<0?0:1;break;case 1002:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x)}if(e.y<0||e.y>1)switch(this.wrapT){case 1e3:e.y=e.y-Math.floor(e.y);break;case 1001:e.y=e.y<0?0:1;break;case 1002:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y)}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&this.version++}}function zc(o){return typeof HTMLImageElement<"u"&&o instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&o instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&o instanceof ImageBitmap?Er.getDataURL(o):o.data?{data:Array.prototype.slice.call(o.data),width:o.width,height:o.height,type:o.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}un.DEFAULT_IMAGE=void 0,un.DEFAULT_MAPPING=300,un.prototype.isTexture=!0;class Dt{constructor(e=0,t=0,r=0,i=1){this.x=e,this.y=t,this.z=r,this.w=i}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,r,i){return this.x=e,this.y=t,this.z=r,this.w=i,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,r=this.y,i=this.z,a=this.w,c=e.elements;return this.x=c[0]*t+c[4]*r+c[8]*i+c[12]*a,this.y=c[1]*t+c[5]*r+c[9]*i+c[13]*a,this.z=c[2]*t+c[6]*r+c[10]*i+c[14]*a,this.w=c[3]*t+c[7]*r+c[11]*i+c[15]*a,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,r,i,a;const h=e.elements,p=h[0],m=h[4],g=h[8],y=h[1],x=h[5],b=h[9],S=h[2],M=h[6],A=h[10];if(Math.abs(m-y)<.01&&Math.abs(g-S)<.01&&Math.abs(b-M)<.01){if(Math.abs(m+y)<.1&&Math.abs(g+S)<.1&&Math.abs(b+M)<.1&&Math.abs(p+x+A-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const k=(p+1)/2,N=(x+1)/2,G=(A+1)/2,U=(m+y)/4,B=(g+S)/4,V=(b+M)/4;return k>N&&k>G?k<.01?(r=0,i=.707106781,a=.707106781):(r=Math.sqrt(k),i=U/r,a=B/r):N>G?N<.01?(r=.707106781,i=0,a=.707106781):(i=Math.sqrt(N),r=U/i,a=V/i):G<.01?(r=.707106781,i=.707106781,a=0):(a=Math.sqrt(G),r=B/a,i=V/a),this.set(r,i,a,t),this}let I=Math.sqrt((M-b)*(M-b)+(g-S)*(g-S)+(y-m)*(y-m));return Math.abs(I)<.001&&(I=1),this.x=(M-b)/I,this.y=(g-S)/I,this.z=(y-m)/I,this.w=Math.acos((p+x+A-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const r=this.length();return this.divideScalar(r||1).multiplyScalar(Math.max(e,Math.min(t,r)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,r){return this.x=e.x+(t.x-e.x)*r,this.y=e.y+(t.y-e.y)*r,this.z=e.z+(t.z-e.z)*r,this.w=e.w+(t.w-e.w)*r,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t,r){return r!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}}Dt.prototype.isVector4=!0;class Vr extends ce{constructor(e,t,r){super(),this.width=e,this.height=t,this.depth=1,this.scissor=new Dt(0,0,e,t),this.scissorTest=!1,this.viewport=new Dt(0,0,e,t),r=r||{},this.texture=new un(void 0,r.mapping,r.wrapS,r.wrapT,r.magFilter,r.minFilter,r.format,r.type,r.anisotropy,r.encoding),this.texture.image={},this.texture.image.width=e,this.texture.image.height=t,this.texture.image.depth=1,this.texture.generateMipmaps=r.generateMipmaps!==void 0&&r.generateMipmaps,this.texture.minFilter=r.minFilter!==void 0?r.minFilter:1006,this.depthBuffer=r.depthBuffer===void 0||r.depthBuffer,this.stencilBuffer=r.stencilBuffer!==void 0&&r.stencilBuffer,this.depthTexture=r.depthTexture!==void 0?r.depthTexture:null}setTexture(e){e.image={width:this.width,height:this.height,depth:this.depth},this.texture=e}setSize(e,t,r=1){this.width===e&&this.height===t&&this.depth===r||(this.width=e,this.height=t,this.depth=r,this.texture.image.width=e,this.texture.image.height=t,this.texture.image.depth=r,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.width=e.width,this.height=e.height,this.depth=e.depth,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.depthTexture=e.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}Vr.prototype.isWebGLRenderTarget=!0;class Wd extends Vr{constructor(e,t,r){super(e,t,r),this.samples=4}copy(e){return super.copy.call(this,e),this.samples=e.samples,this}}Wd.prototype.isWebGLMultisampleRenderTarget=!0;class fn{constructor(e=0,t=0,r=0,i=1){this._x=e,this._y=t,this._z=r,this._w=i}static slerp(e,t,r,i){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),r.slerpQuaternions(e,t,i)}static slerpFlat(e,t,r,i,a,c,u){let h=r[i+0],p=r[i+1],m=r[i+2],g=r[i+3];const y=a[c+0],x=a[c+1],b=a[c+2],S=a[c+3];if(u===0)return e[t+0]=h,e[t+1]=p,e[t+2]=m,void(e[t+3]=g);if(u===1)return e[t+0]=y,e[t+1]=x,e[t+2]=b,void(e[t+3]=S);if(g!==S||h!==y||p!==x||m!==b){let M=1-u;const A=h*y+p*x+m*b+g*S,I=A>=0?1:-1,k=1-A*A;if(k>Number.EPSILON){const G=Math.sqrt(k),U=Math.atan2(G,A*I);M=Math.sin(M*U)/G,u=Math.sin(u*U)/G}const N=u*I;if(h=h*M+y*N,p=p*M+x*N,m=m*M+b*N,g=g*M+S*N,M===1-u){const G=1/Math.sqrt(h*h+p*p+m*m+g*g);h*=G,p*=G,m*=G,g*=G}}e[t]=h,e[t+1]=p,e[t+2]=m,e[t+3]=g}static multiplyQuaternionsFlat(e,t,r,i,a,c){const u=r[i],h=r[i+1],p=r[i+2],m=r[i+3],g=a[c],y=a[c+1],x=a[c+2],b=a[c+3];return e[t]=u*b+m*g+h*x-p*y,e[t+1]=h*b+m*y+p*g-u*x,e[t+2]=p*b+m*x+u*y-h*g,e[t+3]=m*b-u*g-h*y-p*x,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,r,i){return this._x=e,this._y=t,this._z=r,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t){if(!e||!e.isEuler)throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const r=e._x,i=e._y,a=e._z,c=e._order,u=Math.cos,h=Math.sin,p=u(r/2),m=u(i/2),g=u(a/2),y=h(r/2),x=h(i/2),b=h(a/2);switch(c){case"XYZ":this._x=y*m*g+p*x*b,this._y=p*x*g-y*m*b,this._z=p*m*b+y*x*g,this._w=p*m*g-y*x*b;break;case"YXZ":this._x=y*m*g+p*x*b,this._y=p*x*g-y*m*b,this._z=p*m*b-y*x*g,this._w=p*m*g+y*x*b;break;case"ZXY":this._x=y*m*g-p*x*b,this._y=p*x*g+y*m*b,this._z=p*m*b+y*x*g,this._w=p*m*g-y*x*b;break;case"ZYX":this._x=y*m*g-p*x*b,this._y=p*x*g+y*m*b,this._z=p*m*b-y*x*g,this._w=p*m*g+y*x*b;break;case"YZX":this._x=y*m*g+p*x*b,this._y=p*x*g+y*m*b,this._z=p*m*b-y*x*g,this._w=p*m*g-y*x*b;break;case"XZY":this._x=y*m*g-p*x*b,this._y=p*x*g-y*m*b,this._z=p*m*b+y*x*g,this._w=p*m*g+y*x*b;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+c)}return t!==!1&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const r=t/2,i=Math.sin(r);return this._x=e.x*i,this._y=e.y*i,this._z=e.z*i,this._w=Math.cos(r),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,r=t[0],i=t[4],a=t[8],c=t[1],u=t[5],h=t[9],p=t[2],m=t[6],g=t[10],y=r+u+g;if(y>0){const x=.5/Math.sqrt(y+1);this._w=.25/x,this._x=(m-h)*x,this._y=(a-p)*x,this._z=(c-i)*x}else if(r>u&&r>g){const x=2*Math.sqrt(1+r-u-g);this._w=(m-h)/x,this._x=.25*x,this._y=(i+c)/x,this._z=(a+p)/x}else if(u>g){const x=2*Math.sqrt(1+u-r-g);this._w=(a-p)/x,this._x=(i+c)/x,this._y=.25*x,this._z=(h+m)/x}else{const x=2*Math.sqrt(1+g-r-u);this._w=(c-i)/x,this._x=(a+p)/x,this._y=(h+m)/x,this._z=.25*x}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let r=e.dot(t)+1;return r<Number.EPSILON?(r=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=r):(this._x=0,this._y=-e.z,this._z=e.y,this._w=r)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=r),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(ct(this.dot(e),-1,1)))}rotateTowards(e,t){const r=this.angleTo(e);if(r===0)return this;const i=Math.min(1,t/r);return this.slerp(e,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e,t){return t!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(e,t)):this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const r=e._x,i=e._y,a=e._z,c=e._w,u=t._x,h=t._y,p=t._z,m=t._w;return this._x=r*m+c*u+i*p-a*h,this._y=i*m+c*h+a*u-r*p,this._z=a*m+c*p+r*h-i*u,this._w=c*m-r*u-i*h-a*p,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const r=this._x,i=this._y,a=this._z,c=this._w;let u=c*e._w+r*e._x+i*e._y+a*e._z;if(u<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,u=-u):this.copy(e),u>=1)return this._w=c,this._x=r,this._y=i,this._z=a,this;const h=1-u*u;if(h<=Number.EPSILON){const x=1-t;return this._w=x*c+t*this._w,this._x=x*r+t*this._x,this._y=x*i+t*this._y,this._z=x*a+t*this._z,this.normalize(),this._onChangeCallback(),this}const p=Math.sqrt(h),m=Math.atan2(p,u),g=Math.sin((1-t)*m)/p,y=Math.sin(t*m)/p;return this._w=c*g+this._w*y,this._x=r*g+this._x*y,this._y=i*g+this._y*y,this._z=a*g+this._z*y,this._onChangeCallback(),this}slerpQuaternions(e,t,r){this.copy(e).slerp(t,r)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}fn.prototype.isQuaternion=!0;class O{constructor(e=0,t=0,r=0){this.x=e,this.y=t,this.z=r}set(e,t,r){return r===void 0&&(r=this.z),this.x=e,this.y=t,this.z=r,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(e,t)):(this.x*=e.x,this.y*=e.y,this.z*=e.z,this)}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return e&&e.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(jd.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(jd.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,r=this.y,i=this.z,a=e.elements;return this.x=a[0]*t+a[3]*r+a[6]*i,this.y=a[1]*t+a[4]*r+a[7]*i,this.z=a[2]*t+a[5]*r+a[8]*i,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,r=this.y,i=this.z,a=e.elements,c=1/(a[3]*t+a[7]*r+a[11]*i+a[15]);return this.x=(a[0]*t+a[4]*r+a[8]*i+a[12])*c,this.y=(a[1]*t+a[5]*r+a[9]*i+a[13])*c,this.z=(a[2]*t+a[6]*r+a[10]*i+a[14])*c,this}applyQuaternion(e){const t=this.x,r=this.y,i=this.z,a=e.x,c=e.y,u=e.z,h=e.w,p=h*t+c*i-u*r,m=h*r+u*t-a*i,g=h*i+a*r-c*t,y=-a*t-c*r-u*i;return this.x=p*h+y*-a+m*-u-g*-c,this.y=m*h+y*-c+g*-a-p*-u,this.z=g*h+y*-u+p*-c-m*-a,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,r=this.y,i=this.z,a=e.elements;return this.x=a[0]*t+a[4]*r+a[8]*i,this.y=a[1]*t+a[5]*r+a[9]*i,this.z=a[2]*t+a[6]*r+a[10]*i,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const r=this.length();return this.divideScalar(r||1).multiplyScalar(Math.max(e,Math.min(t,r)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,r){return this.x=e.x+(t.x-e.x)*r,this.y=e.y+(t.y-e.y)*r,this.z=e.z+(t.z-e.z)*r,this}cross(e,t){return t!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(e,t)):this.crossVectors(this,e)}crossVectors(e,t){const r=e.x,i=e.y,a=e.z,c=t.x,u=t.y,h=t.z;return this.x=i*h-a*u,this.y=a*c-r*h,this.z=r*u-i*c,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const r=e.dot(this)/t;return this.copy(e).multiplyScalar(r)}projectOnPlane(e){return Uc.copy(this).projectOnVector(e),this.sub(Uc)}reflect(e){return this.sub(Uc.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const r=this.dot(e)/t;return Math.acos(ct(r,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,r=this.y-e.y,i=this.z-e.z;return t*t+r*r+i*i}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,r){const i=Math.sin(t)*e;return this.x=i*Math.sin(r),this.y=Math.cos(t)*e,this.z=i*Math.cos(r),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,r){return this.x=e*Math.sin(t),this.y=r,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),r=this.setFromMatrixColumn(e,1).length(),i=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=r,this.z=i,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,4*t)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,3*t)}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t,r){return r!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}}O.prototype.isVector3=!0;const Uc=new O,jd=new fn;class Wn{constructor(e=new O(1/0,1/0,1/0),t=new O(-1/0,-1/0,-1/0)){this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){let t=1/0,r=1/0,i=1/0,a=-1/0,c=-1/0,u=-1/0;for(let h=0,p=e.length;h<p;h+=3){const m=e[h],g=e[h+1],y=e[h+2];m<t&&(t=m),g<r&&(r=g),y<i&&(i=y),m>a&&(a=m),g>c&&(c=g),y>u&&(u=y)}return this.min.set(t,r,i),this.max.set(a,c,u),this}setFromBufferAttribute(e){let t=1/0,r=1/0,i=1/0,a=-1/0,c=-1/0,u=-1/0;for(let h=0,p=e.count;h<p;h++){const m=e.getX(h),g=e.getY(h),y=e.getZ(h);m<t&&(t=m),g<r&&(r=g),y<i&&(i=y),m>a&&(a=m),g>c&&(c=g),y>u&&(u=y)}return this.min.set(t,r,i),this.max.set(a,c,u),this}setFromPoints(e){this.makeEmpty();for(let t=0,r=e.length;t<r;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const r=lo.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(r),this.max.copy(e).add(r),this}setFromObject(e){return this.makeEmpty(),this.expandByObject(e)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return e===void 0&&(console.warn("THREE.Box3: .getCenter() target is now required"),e=new O),this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return e===void 0&&(console.warn("THREE.Box3: .getSize() target is now required"),e=new O),this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e){e.updateWorldMatrix(!1,!1);const t=e.geometry;t!==void 0&&(t.boundingBox===null&&t.computeBoundingBox(),Gc.copy(t.boundingBox),Gc.applyMatrix4(e.matrixWorld),this.union(Gc));const r=e.children;for(let i=0,a=r.length;i<a;i++)this.expandByObject(r[i]);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t===void 0&&(console.warn("THREE.Box3: .getParameter() target is now required"),t=new O),t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,lo),lo.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,r;return e.normal.x>0?(t=e.normal.x*this.min.x,r=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,r=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,r+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,r+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,r+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,r+=e.normal.z*this.min.z),t<=-e.constant&&r>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(co),La.subVectors(this.max,co),bs.subVectors(e.a,co),ws.subVectors(e.b,co),Ms.subVectors(e.c,co),di.subVectors(ws,bs),pi.subVectors(Ms,ws),Hi.subVectors(bs,Ms);let t=[0,-di.z,di.y,0,-pi.z,pi.y,0,-Hi.z,Hi.y,di.z,0,-di.x,pi.z,0,-pi.x,Hi.z,0,-Hi.x,-di.y,di.x,0,-pi.y,pi.x,0,-Hi.y,Hi.x,0];return!!Vc(t,bs,ws,Ms,La)&&(t=[1,0,0,0,1,0,0,0,1],!!Vc(t,bs,ws,Ms,La)&&(Ca.crossVectors(di,pi),t=[Ca.x,Ca.y,Ca.z],Vc(t,bs,ws,Ms,La)))}clampPoint(e,t){return t===void 0&&(console.warn("THREE.Box3: .clampPoint() target is now required"),t=new O),t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return lo.copy(e).clamp(this.min,this.max).sub(e).length()}getBoundingSphere(e){return e===void 0&&console.error("THREE.Box3: .getBoundingSphere() target is now required"),this.getCenter(e.center),e.radius=.5*this.getSize(lo).length(),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()||(Wr[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),Wr[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),Wr[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),Wr[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),Wr[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),Wr[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),Wr[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),Wr[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(Wr)),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}Wn.prototype.isBox3=!0;const Wr=[new O,new O,new O,new O,new O,new O,new O,new O],lo=new O,Gc=new Wn,bs=new O,ws=new O,Ms=new O,di=new O,pi=new O,Hi=new O,co=new O,La=new O,Ca=new O,Fi=new O;function Vc(o,e,t,r,i){for(let a=0,c=o.length-3;a<=c;a+=3){Fi.fromArray(o,a);const u=i.x*Math.abs(Fi.x)+i.y*Math.abs(Fi.y)+i.z*Math.abs(Fi.z),h=e.dot(Fi),p=t.dot(Fi),m=r.dot(Fi);if(Math.max(-Math.max(h,p,m),Math.min(h,p,m))>u)return!1}return!0}const zy=new Wn,qd=new O,Wc=new O,jc=new O;class fi{constructor(e=new O,t=-1){this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const r=this.center;t!==void 0?r.copy(t):zy.setFromPoints(e).getCenter(r);let i=0;for(let a=0,c=e.length;a<c;a++)i=Math.max(i,r.distanceToSquared(e[a]));return this.radius=Math.sqrt(i),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const r=this.center.distanceToSquared(e);return t===void 0&&(console.warn("THREE.Sphere: .clampPoint() target is now required"),t=new O),t.copy(e),r>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return e===void 0&&(console.warn("THREE.Sphere: .getBoundingBox() target is now required"),e=new Wn),this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){jc.subVectors(e,this.center);const t=jc.lengthSq();if(t>this.radius*this.radius){const r=Math.sqrt(t),i=.5*(r-this.radius);this.center.add(jc.multiplyScalar(i/r)),this.radius+=i}return this}union(e){return Wc.subVectors(e.center,this.center).normalize().multiplyScalar(e.radius),this.expandByPoint(qd.copy(e.center).add(Wc)),this.expandByPoint(qd.copy(e.center).sub(Wc)),this}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}}const jr=new O,qc=new O,Pa=new O,mi=new O,Xc=new O,Ia=new O,Yc=new O;class gi{constructor(e=new O,t=new O(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t===void 0&&(console.warn("THREE.Ray: .at() target is now required"),t=new O),t.copy(this.direction).multiplyScalar(e).add(this.origin)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,jr)),this}closestPointToPoint(e,t){t===void 0&&(console.warn("THREE.Ray: .closestPointToPoint() target is now required"),t=new O),t.subVectors(e,this.origin);const r=t.dot(this.direction);return r<0?t.copy(this.origin):t.copy(this.direction).multiplyScalar(r).add(this.origin)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=jr.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(jr.copy(this.direction).multiplyScalar(t).add(this.origin),jr.distanceToSquared(e))}distanceSqToSegment(e,t,r,i){qc.copy(e).add(t).multiplyScalar(.5),Pa.copy(t).sub(e).normalize(),mi.copy(this.origin).sub(qc);const a=.5*e.distanceTo(t),c=-this.direction.dot(Pa),u=mi.dot(this.direction),h=-mi.dot(Pa),p=mi.lengthSq(),m=Math.abs(1-c*c);let g,y,x,b;if(m>0)if(g=c*h-u,y=c*u-h,b=a*m,g>=0)if(y>=-b)if(y<=b){const S=1/m;g*=S,y*=S,x=g*(g+c*y+2*u)+y*(c*g+y+2*h)+p}else y=a,g=Math.max(0,-(c*y+u)),x=-g*g+y*(y+2*h)+p;else y=-a,g=Math.max(0,-(c*y+u)),x=-g*g+y*(y+2*h)+p;else y<=-b?(g=Math.max(0,-(-c*a+u)),y=g>0?-a:Math.min(Math.max(-a,-h),a),x=-g*g+y*(y+2*h)+p):y<=b?(g=0,y=Math.min(Math.max(-a,-h),a),x=y*(y+2*h)+p):(g=Math.max(0,-(c*a+u)),y=g>0?a:Math.min(Math.max(-a,-h),a),x=-g*g+y*(y+2*h)+p);else y=c>0?-a:a,g=Math.max(0,-(c*y+u)),x=-g*g+y*(y+2*h)+p;return r&&r.copy(this.direction).multiplyScalar(g).add(this.origin),i&&i.copy(Pa).multiplyScalar(y).add(qc),x}intersectSphere(e,t){jr.subVectors(e.center,this.origin);const r=jr.dot(this.direction),i=jr.dot(jr)-r*r,a=e.radius*e.radius;if(i>a)return null;const c=Math.sqrt(a-i),u=r-c,h=r+c;return u<0&&h<0?null:u<0?this.at(h,t):this.at(u,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const r=-(this.origin.dot(e.normal)+e.constant)/t;return r>=0?r:null}intersectPlane(e,t){const r=this.distanceToPlane(e);return r===null?null:this.at(r,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0?!0:e.normal.dot(this.direction)*t<0}intersectBox(e,t){let r,i,a,c,u,h;const p=1/this.direction.x,m=1/this.direction.y,g=1/this.direction.z,y=this.origin;return p>=0?(r=(e.min.x-y.x)*p,i=(e.max.x-y.x)*p):(r=(e.max.x-y.x)*p,i=(e.min.x-y.x)*p),m>=0?(a=(e.min.y-y.y)*m,c=(e.max.y-y.y)*m):(a=(e.max.y-y.y)*m,c=(e.min.y-y.y)*m),r>c||a>i?null:((a>r||r!=r)&&(r=a),(c<i||i!=i)&&(i=c),g>=0?(u=(e.min.z-y.z)*g,h=(e.max.z-y.z)*g):(u=(e.max.z-y.z)*g,h=(e.min.z-y.z)*g),r>h||u>i?null:((u>r||r!=r)&&(r=u),(h<i||i!=i)&&(i=h),i<0?null:this.at(r>=0?r:i,t)))}intersectsBox(e){return this.intersectBox(e,jr)!==null}intersectTriangle(e,t,r,i,a){Xc.subVectors(t,e),Ia.subVectors(r,e),Yc.crossVectors(Xc,Ia);let c,u=this.direction.dot(Yc);if(u>0){if(i)return null;c=1}else{if(!(u<0))return null;c=-1,u=-u}mi.subVectors(this.origin,e);const h=c*this.direction.dot(Ia.crossVectors(mi,Ia));if(h<0)return null;const p=c*this.direction.dot(Xc.cross(mi));if(p<0||h+p>u)return null;const m=-c*mi.dot(Yc);return m<0?null:this.at(m/u,a)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class Ze{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(e,t,r,i,a,c,u,h,p,m,g,y,x,b,S,M){const A=this.elements;return A[0]=e,A[4]=t,A[8]=r,A[12]=i,A[1]=a,A[5]=c,A[9]=u,A[13]=h,A[2]=p,A[6]=m,A[10]=g,A[14]=y,A[3]=x,A[7]=b,A[11]=S,A[15]=M,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new Ze().fromArray(this.elements)}copy(e){const t=this.elements,r=e.elements;return t[0]=r[0],t[1]=r[1],t[2]=r[2],t[3]=r[3],t[4]=r[4],t[5]=r[5],t[6]=r[6],t[7]=r[7],t[8]=r[8],t[9]=r[9],t[10]=r[10],t[11]=r[11],t[12]=r[12],t[13]=r[13],t[14]=r[14],t[15]=r[15],this}copyPosition(e){const t=this.elements,r=e.elements;return t[12]=r[12],t[13]=r[13],t[14]=r[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,r){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),r.setFromMatrixColumn(this,2),this}makeBasis(e,t,r){return this.set(e.x,t.x,r.x,0,e.y,t.y,r.y,0,e.z,t.z,r.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,r=e.elements,i=1/Ss.setFromMatrixColumn(e,0).length(),a=1/Ss.setFromMatrixColumn(e,1).length(),c=1/Ss.setFromMatrixColumn(e,2).length();return t[0]=r[0]*i,t[1]=r[1]*i,t[2]=r[2]*i,t[3]=0,t[4]=r[4]*a,t[5]=r[5]*a,t[6]=r[6]*a,t[7]=0,t[8]=r[8]*c,t[9]=r[9]*c,t[10]=r[10]*c,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){e&&e.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const t=this.elements,r=e.x,i=e.y,a=e.z,c=Math.cos(r),u=Math.sin(r),h=Math.cos(i),p=Math.sin(i),m=Math.cos(a),g=Math.sin(a);if(e.order==="XYZ"){const y=c*m,x=c*g,b=u*m,S=u*g;t[0]=h*m,t[4]=-h*g,t[8]=p,t[1]=x+b*p,t[5]=y-S*p,t[9]=-u*h,t[2]=S-y*p,t[6]=b+x*p,t[10]=c*h}else if(e.order==="YXZ"){const y=h*m,x=h*g,b=p*m,S=p*g;t[0]=y+S*u,t[4]=b*u-x,t[8]=c*p,t[1]=c*g,t[5]=c*m,t[9]=-u,t[2]=x*u-b,t[6]=S+y*u,t[10]=c*h}else if(e.order==="ZXY"){const y=h*m,x=h*g,b=p*m,S=p*g;t[0]=y-S*u,t[4]=-c*g,t[8]=b+x*u,t[1]=x+b*u,t[5]=c*m,t[9]=S-y*u,t[2]=-c*p,t[6]=u,t[10]=c*h}else if(e.order==="ZYX"){const y=c*m,x=c*g,b=u*m,S=u*g;t[0]=h*m,t[4]=b*p-x,t[8]=y*p+S,t[1]=h*g,t[5]=S*p+y,t[9]=x*p-b,t[2]=-p,t[6]=u*h,t[10]=c*h}else if(e.order==="YZX"){const y=c*h,x=c*p,b=u*h,S=u*p;t[0]=h*m,t[4]=S-y*g,t[8]=b*g+x,t[1]=g,t[5]=c*m,t[9]=-u*m,t[2]=-p*m,t[6]=x*g+b,t[10]=y-S*g}else if(e.order==="XZY"){const y=c*h,x=c*p,b=u*h,S=u*p;t[0]=h*m,t[4]=-g,t[8]=p*m,t[1]=y*g+S,t[5]=c*m,t[9]=x*g-b,t[2]=b*g-x,t[6]=u*m,t[10]=S*g+y}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(Uy,e,Gy)}lookAt(e,t,r){const i=this.elements;return $n.subVectors(e,t),$n.lengthSq()===0&&($n.z=1),$n.normalize(),vi.crossVectors(r,$n),vi.lengthSq()===0&&(Math.abs(r.z)===1?$n.x+=1e-4:$n.z+=1e-4,$n.normalize(),vi.crossVectors(r,$n)),vi.normalize(),Oa.crossVectors($n,vi),i[0]=vi.x,i[4]=Oa.x,i[8]=$n.x,i[1]=vi.y,i[5]=Oa.y,i[9]=$n.y,i[2]=vi.z,i[6]=Oa.z,i[10]=$n.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(e,t)):this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const r=e.elements,i=t.elements,a=this.elements,c=r[0],u=r[4],h=r[8],p=r[12],m=r[1],g=r[5],y=r[9],x=r[13],b=r[2],S=r[6],M=r[10],A=r[14],I=r[3],k=r[7],N=r[11],G=r[15],U=i[0],B=i[4],V=i[8],he=i[12],Z=i[1],J=i[5],re=i[9],ee=i[13],le=i[2],Ce=i[6],Pe=i[10],We=i[14],Oe=i[3],De=i[7],ze=i[11],st=i[15];return a[0]=c*U+u*Z+h*le+p*Oe,a[4]=c*B+u*J+h*Ce+p*De,a[8]=c*V+u*re+h*Pe+p*ze,a[12]=c*he+u*ee+h*We+p*st,a[1]=m*U+g*Z+y*le+x*Oe,a[5]=m*B+g*J+y*Ce+x*De,a[9]=m*V+g*re+y*Pe+x*ze,a[13]=m*he+g*ee+y*We+x*st,a[2]=b*U+S*Z+M*le+A*Oe,a[6]=b*B+S*J+M*Ce+A*De,a[10]=b*V+S*re+M*Pe+A*ze,a[14]=b*he+S*ee+M*We+A*st,a[3]=I*U+k*Z+N*le+G*Oe,a[7]=I*B+k*J+N*Ce+G*De,a[11]=I*V+k*re+N*Pe+G*ze,a[15]=I*he+k*ee+N*We+G*st,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],r=e[4],i=e[8],a=e[12],c=e[1],u=e[5],h=e[9],p=e[13],m=e[2],g=e[6],y=e[10],x=e[14];return e[3]*(+a*h*g-i*p*g-a*u*y+r*p*y+i*u*x-r*h*x)+e[7]*(+t*h*x-t*p*y+a*c*y-i*c*x+i*p*m-a*h*m)+e[11]*(+t*p*g-t*u*x-a*c*g+r*c*x+a*u*m-r*p*m)+e[15]*(-i*u*m-t*h*g+t*u*y+i*c*g-r*c*y+r*h*m)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,r){const i=this.elements;return e.isVector3?(i[12]=e.x,i[13]=e.y,i[14]=e.z):(i[12]=e,i[13]=t,i[14]=r),this}invert(){const e=this.elements,t=e[0],r=e[1],i=e[2],a=e[3],c=e[4],u=e[5],h=e[6],p=e[7],m=e[8],g=e[9],y=e[10],x=e[11],b=e[12],S=e[13],M=e[14],A=e[15],I=g*M*p-S*y*p+S*h*x-u*M*x-g*h*A+u*y*A,k=b*y*p-m*M*p-b*h*x+c*M*x+m*h*A-c*y*A,N=m*S*p-b*g*p+b*u*x-c*S*x-m*u*A+c*g*A,G=b*g*h-m*S*h-b*u*y+c*S*y+m*u*M-c*g*M,U=t*I+r*k+i*N+a*G;if(U===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const B=1/U;return e[0]=I*B,e[1]=(S*y*a-g*M*a-S*i*x+r*M*x+g*i*A-r*y*A)*B,e[2]=(u*M*a-S*h*a+S*i*p-r*M*p-u*i*A+r*h*A)*B,e[3]=(g*h*a-u*y*a-g*i*p+r*y*p+u*i*x-r*h*x)*B,e[4]=k*B,e[5]=(m*M*a-b*y*a+b*i*x-t*M*x-m*i*A+t*y*A)*B,e[6]=(b*h*a-c*M*a-b*i*p+t*M*p+c*i*A-t*h*A)*B,e[7]=(c*y*a-m*h*a+m*i*p-t*y*p-c*i*x+t*h*x)*B,e[8]=N*B,e[9]=(b*g*a-m*S*a-b*r*x+t*S*x+m*r*A-t*g*A)*B,e[10]=(c*S*a-b*u*a+b*r*p-t*S*p-c*r*A+t*u*A)*B,e[11]=(m*u*a-c*g*a-m*r*p+t*g*p+c*r*x-t*u*x)*B,e[12]=G*B,e[13]=(m*S*i-b*g*i+b*r*y-t*S*y-m*r*M+t*g*M)*B,e[14]=(b*u*i-c*S*i-b*r*h+t*S*h+c*r*M-t*u*M)*B,e[15]=(c*g*i-m*u*i+m*r*h-t*g*h-c*r*y+t*u*y)*B,this}scale(e){const t=this.elements,r=e.x,i=e.y,a=e.z;return t[0]*=r,t[4]*=i,t[8]*=a,t[1]*=r,t[5]*=i,t[9]*=a,t[2]*=r,t[6]*=i,t[10]*=a,t[3]*=r,t[7]*=i,t[11]*=a,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],r=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],i=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,r,i))}makeTranslation(e,t,r){return this.set(1,0,0,e,0,1,0,t,0,0,1,r,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),r=Math.sin(e);return this.set(1,0,0,0,0,t,-r,0,0,r,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),r=Math.sin(e);return this.set(t,0,r,0,0,1,0,0,-r,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),r=Math.sin(e);return this.set(t,-r,0,0,r,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const r=Math.cos(t),i=Math.sin(t),a=1-r,c=e.x,u=e.y,h=e.z,p=a*c,m=a*u;return this.set(p*c+r,p*u-i*h,p*h+i*u,0,p*u+i*h,m*u+r,m*h-i*c,0,p*h-i*u,m*h+i*c,a*h*h+r,0,0,0,0,1),this}makeScale(e,t,r){return this.set(e,0,0,0,0,t,0,0,0,0,r,0,0,0,0,1),this}makeShear(e,t,r){return this.set(1,t,r,0,e,1,r,0,e,t,1,0,0,0,0,1),this}compose(e,t,r){const i=this.elements,a=t._x,c=t._y,u=t._z,h=t._w,p=a+a,m=c+c,g=u+u,y=a*p,x=a*m,b=a*g,S=c*m,M=c*g,A=u*g,I=h*p,k=h*m,N=h*g,G=r.x,U=r.y,B=r.z;return i[0]=(1-(S+A))*G,i[1]=(x+N)*G,i[2]=(b-k)*G,i[3]=0,i[4]=(x-N)*U,i[5]=(1-(y+A))*U,i[6]=(M+I)*U,i[7]=0,i[8]=(b+k)*B,i[9]=(M-I)*B,i[10]=(1-(y+S))*B,i[11]=0,i[12]=e.x,i[13]=e.y,i[14]=e.z,i[15]=1,this}decompose(e,t,r){const i=this.elements;let a=Ss.set(i[0],i[1],i[2]).length();const c=Ss.set(i[4],i[5],i[6]).length(),u=Ss.set(i[8],i[9],i[10]).length();this.determinant()<0&&(a=-a),e.x=i[12],e.y=i[13],e.z=i[14],cr.copy(this);const h=1/a,p=1/c,m=1/u;return cr.elements[0]*=h,cr.elements[1]*=h,cr.elements[2]*=h,cr.elements[4]*=p,cr.elements[5]*=p,cr.elements[6]*=p,cr.elements[8]*=m,cr.elements[9]*=m,cr.elements[10]*=m,t.setFromRotationMatrix(cr),r.x=a,r.y=c,r.z=u,this}makePerspective(e,t,r,i,a,c){c===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const u=this.elements,h=2*a/(t-e),p=2*a/(r-i),m=(t+e)/(t-e),g=(r+i)/(r-i),y=-(c+a)/(c-a),x=-2*c*a/(c-a);return u[0]=h,u[4]=0,u[8]=m,u[12]=0,u[1]=0,u[5]=p,u[9]=g,u[13]=0,u[2]=0,u[6]=0,u[10]=y,u[14]=x,u[3]=0,u[7]=0,u[11]=-1,u[15]=0,this}makeOrthographic(e,t,r,i,a,c){const u=this.elements,h=1/(t-e),p=1/(r-i),m=1/(c-a),g=(t+e)*h,y=(r+i)*p,x=(c+a)*m;return u[0]=2*h,u[4]=0,u[8]=0,u[12]=-g,u[1]=0,u[5]=2*p,u[9]=0,u[13]=-y,u[2]=0,u[6]=0,u[10]=-2*m,u[14]=-x,u[3]=0,u[7]=0,u[11]=0,u[15]=1,this}equals(e){const t=this.elements,r=e.elements;for(let i=0;i<16;i++)if(t[i]!==r[i])return!1;return!0}fromArray(e,t=0){for(let r=0;r<16;r++)this.elements[r]=e[r+t];return this}toArray(e=[],t=0){const r=this.elements;return e[t]=r[0],e[t+1]=r[1],e[t+2]=r[2],e[t+3]=r[3],e[t+4]=r[4],e[t+5]=r[5],e[t+6]=r[6],e[t+7]=r[7],e[t+8]=r[8],e[t+9]=r[9],e[t+10]=r[10],e[t+11]=r[11],e[t+12]=r[12],e[t+13]=r[13],e[t+14]=r[14],e[t+15]=r[15],e}}Ze.prototype.isMatrix4=!0;const Ss=new O,cr=new Ze,Uy=new O(0,0,0),Gy=new O(1,1,1),vi=new O,Oa=new O,$n=new O,Xd=new Ze,Yd=new fn;class Bi{constructor(e=0,t=0,r=0,i=Bi.DefaultOrder){this._x=e,this._y=t,this._z=r,this._order=i}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,r,i){return this._x=e,this._y=t,this._z=r,this._order=i||this._order,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t,r){const i=e.elements,a=i[0],c=i[4],u=i[8],h=i[1],p=i[5],m=i[9],g=i[2],y=i[6],x=i[10];switch(t=t||this._order){case"XYZ":this._y=Math.asin(ct(u,-1,1)),Math.abs(u)<.9999999?(this._x=Math.atan2(-m,x),this._z=Math.atan2(-c,a)):(this._x=Math.atan2(y,p),this._z=0);break;case"YXZ":this._x=Math.asin(-ct(m,-1,1)),Math.abs(m)<.9999999?(this._y=Math.atan2(u,x),this._z=Math.atan2(h,p)):(this._y=Math.atan2(-g,a),this._z=0);break;case"ZXY":this._x=Math.asin(ct(y,-1,1)),Math.abs(y)<.9999999?(this._y=Math.atan2(-g,x),this._z=Math.atan2(-c,p)):(this._y=0,this._z=Math.atan2(h,a));break;case"ZYX":this._y=Math.asin(-ct(g,-1,1)),Math.abs(g)<.9999999?(this._x=Math.atan2(y,x),this._z=Math.atan2(h,a)):(this._x=0,this._z=Math.atan2(-c,p));break;case"YZX":this._z=Math.asin(ct(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(-m,p),this._y=Math.atan2(-g,a)):(this._x=0,this._y=Math.atan2(u,x));break;case"XZY":this._z=Math.asin(-ct(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(y,p),this._y=Math.atan2(u,a)):(this._x=Math.atan2(-m,x),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,r!==!1&&this._onChangeCallback(),this}setFromQuaternion(e,t,r){return Xd.makeRotationFromQuaternion(e),this.setFromRotationMatrix(Xd,t,r)}setFromVector3(e,t){return this.set(e.x,e.y,e.z,t||this._order)}reorder(e){return Yd.setFromEuler(this),this.setFromQuaternion(Yd,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}toVector3(e){return e?e.set(this._x,this._y,this._z):new O(this._x,this._y,this._z)}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}Bi.prototype.isEuler=!0,Bi.DefaultOrder="XYZ",Bi.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class Zc{constructor(){this.mask=1}set(e){this.mask=1<<e|0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!=0}}let Vy=0;const Zd=new O,Es=new fn,qr=new Ze,Da=new O,uo=new O,Wy=new O,jy=new fn,Kd=new O(1,0,0),$d=new O(0,1,0),Jd=new O(0,0,1),qy={type:"added"},Qd={type:"removed"};class yt extends ce{constructor(){super(),Object.defineProperty(this,"id",{value:Vy++}),this.uuid=it(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=yt.DefaultUp.clone();const e=new O,t=new Bi,r=new fn,i=new O(1,1,1);t._onChange(function(){r.setFromEuler(t,!1)}),r._onChange(function(){t.setFromQuaternion(r,void 0,!1)}),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:r},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new Ze},normalMatrix:{value:new St}}),this.matrix=new Ze,this.matrixWorld=new Ze,this.matrixAutoUpdate=yt.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new Zc,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return Es.setFromAxisAngle(e,t),this.quaternion.multiply(Es),this}rotateOnWorldAxis(e,t){return Es.setFromAxisAngle(e,t),this.quaternion.premultiply(Es),this}rotateX(e){return this.rotateOnAxis(Kd,e)}rotateY(e){return this.rotateOnAxis($d,e)}rotateZ(e){return this.rotateOnAxis(Jd,e)}translateOnAxis(e,t){return Zd.copy(e).applyQuaternion(this.quaternion),this.position.add(Zd.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(Kd,e)}translateY(e){return this.translateOnAxis($d,e)}translateZ(e){return this.translateOnAxis(Jd,e)}localToWorld(e){return e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return e.applyMatrix4(qr.copy(this.matrixWorld).invert())}lookAt(e,t,r){e.isVector3?Da.copy(e):Da.set(e,t,r);const i=this.parent;this.updateWorldMatrix(!0,!1),uo.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?qr.lookAt(uo,Da,this.up):qr.lookAt(Da,uo,this.up),this.quaternion.setFromRotationMatrix(qr),i&&(qr.extractRotation(i.matrixWorld),Es.setFromRotationMatrix(qr),this.quaternion.premultiply(Es.invert()))}add(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.parent!==null&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(qy)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let r=0;r<arguments.length;r++)this.remove(arguments[r]);return this}const t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(Qd)),this}clear(){for(let e=0;e<this.children.length;e++){const t=this.children[e];t.parent=null,t.dispatchEvent(Qd)}return this.children.length=0,this}attach(e){return this.updateWorldMatrix(!0,!1),qr.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),qr.multiply(e.parent.matrixWorld)),e.applyMatrix4(qr),this.add(e),e.updateWorldMatrix(!1,!0),this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let r=0,i=this.children.length;r<i;r++){const a=this.children[r].getObjectByProperty(e,t);if(a!==void 0)return a}}getWorldPosition(e){return e===void 0&&(console.warn("THREE.Object3D: .getWorldPosition() target is now required"),e=new O),this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return e===void 0&&(console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),e=new fn),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(uo,e,Wy),e}getWorldScale(e){return e===void 0&&(console.warn("THREE.Object3D: .getWorldScale() target is now required"),e=new O),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(uo,jy,e),e}getWorldDirection(e){e===void 0&&(console.warn("THREE.Object3D: .getWorldDirection() target is now required"),e=new O),this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let r=0,i=t.length;r<i;r++)t[r].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const t=this.children;for(let r=0,i=t.length;r<i;r++)t[r].traverseVisible(e)}traverseAncestors(e){const t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let r=0,i=t.length;r<i;r++)t[r].updateMatrixWorld(e)}updateWorldMatrix(e,t){const r=this.parent;if(e===!0&&r!==null&&r.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),t===!0){const i=this.children;for(let a=0,c=i.length;a<c;a++)i[a].updateWorldMatrix(!1,!0)}}toJSON(e){const t=e===void 0||typeof e=="string",r={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},r.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const i={};function a(u,h){return u[h.uuid]===void 0&&(u[h.uuid]=h.toJSON(e)),h.uuid}if(i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(i.instanceColor=this.instanceColor.toJSON())),this.isMesh||this.isLine||this.isPoints){i.geometry=a(e.geometries,this.geometry);const u=this.geometry.parameters;if(u!==void 0&&u.shapes!==void 0){const h=u.shapes;if(Array.isArray(h))for(let p=0,m=h.length;p<m;p++){const g=h[p];a(e.shapes,g)}else a(e.shapes,h)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(a(e.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const u=[];for(let h=0,p=this.material.length;h<p;h++)u.push(a(e.materials,this.material[h]));i.material=u}else i.material=a(e.materials,this.material);if(this.children.length>0){i.children=[];for(let u=0;u<this.children.length;u++)i.children.push(this.children[u].toJSON(e).object)}if(this.animations.length>0){i.animations=[];for(let u=0;u<this.animations.length;u++){const h=this.animations[u];i.animations.push(a(e.animations,h))}}if(t){const u=c(e.geometries),h=c(e.materials),p=c(e.textures),m=c(e.images),g=c(e.shapes),y=c(e.skeletons),x=c(e.animations);u.length>0&&(r.geometries=u),h.length>0&&(r.materials=h),p.length>0&&(r.textures=p),m.length>0&&(r.images=m),g.length>0&&(r.shapes=g),y.length>0&&(r.skeletons=y),x.length>0&&(r.animations=x)}return r.object=i,r;function c(u){const h=[];for(const p in u){const m=u[p];delete m.metadata,h.push(m)}return h}}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let r=0;r<e.children.length;r++){const i=e.children[r];this.add(i.clone())}return this}}yt.DefaultUp=new O(0,1,0),yt.DefaultMatrixAutoUpdate=!0,yt.prototype.isObject3D=!0;const Kc=new O,Xy=new O,Yy=new St;class ur{constructor(e=new O(1,0,0),t=0){this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,r,i){return this.normal.set(e,t,r),this.constant=i,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,r){const i=Kc.subVectors(r,t).cross(Xy.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(i,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t===void 0&&(console.warn("THREE.Plane: .projectPoint() target is now required"),t=new O),t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)}intersectLine(e,t){t===void 0&&(console.warn("THREE.Plane: .intersectLine() target is now required"),t=new O);const r=e.delta(Kc),i=this.normal.dot(r);if(i===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):null;const a=-(e.start.dot(this.normal)+this.constant)/i;return a<0||a>1?null:t.copy(r).multiplyScalar(a).add(e.start)}intersectsLine(e){const t=this.distanceToPoint(e.start),r=this.distanceToPoint(e.end);return t<0&&r>0||r<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e===void 0&&(console.warn("THREE.Plane: .coplanarPoint() target is now required"),e=new O),e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const r=t||Yy.getNormalMatrix(e),i=this.coplanarPoint(Kc).applyMatrix4(e),a=this.normal.applyMatrix3(r).normalize();return this.constant=-i.dot(a),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}ur.prototype.isPlane=!0;const hr=new O,Xr=new O,$c=new O,Yr=new O,Ts=new O,As=new O,ep=new O,Jc=new O,Qc=new O,eu=new O;class Jt{constructor(e=new O,t=new O,r=new O){this.a=e,this.b=t,this.c=r}static getNormal(e,t,r,i){i===void 0&&(console.warn("THREE.Triangle: .getNormal() target is now required"),i=new O),i.subVectors(r,t),hr.subVectors(e,t),i.cross(hr);const a=i.lengthSq();return a>0?i.multiplyScalar(1/Math.sqrt(a)):i.set(0,0,0)}static getBarycoord(e,t,r,i,a){hr.subVectors(i,t),Xr.subVectors(r,t),$c.subVectors(e,t);const c=hr.dot(hr),u=hr.dot(Xr),h=hr.dot($c),p=Xr.dot(Xr),m=Xr.dot($c),g=c*p-u*u;if(a===void 0&&(console.warn("THREE.Triangle: .getBarycoord() target is now required"),a=new O),g===0)return a.set(-2,-1,-1);const y=1/g,x=(p*h-u*m)*y,b=(c*m-u*h)*y;return a.set(1-x-b,b,x)}static containsPoint(e,t,r,i){return this.getBarycoord(e,t,r,i,Yr),Yr.x>=0&&Yr.y>=0&&Yr.x+Yr.y<=1}static getUV(e,t,r,i,a,c,u,h){return this.getBarycoord(e,t,r,i,Yr),h.set(0,0),h.addScaledVector(a,Yr.x),h.addScaledVector(c,Yr.y),h.addScaledVector(u,Yr.z),h}static isFrontFacing(e,t,r,i){return hr.subVectors(r,t),Xr.subVectors(e,t),hr.cross(Xr).dot(i)<0}set(e,t,r){return this.a.copy(e),this.b.copy(t),this.c.copy(r),this}setFromPointsAndIndices(e,t,r,i){return this.a.copy(e[t]),this.b.copy(e[r]),this.c.copy(e[i]),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return hr.subVectors(this.c,this.b),Xr.subVectors(this.a,this.b),.5*hr.cross(Xr).length()}getMidpoint(e){return e===void 0&&(console.warn("THREE.Triangle: .getMidpoint() target is now required"),e=new O),e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return Jt.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e===void 0&&(console.warn("THREE.Triangle: .getPlane() target is now required"),e=new ur),e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return Jt.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,r,i,a){return Jt.getUV(e,this.a,this.b,this.c,t,r,i,a)}containsPoint(e){return Jt.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return Jt.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){t===void 0&&(console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),t=new O);const r=this.a,i=this.b,a=this.c;let c,u;Ts.subVectors(i,r),As.subVectors(a,r),Jc.subVectors(e,r);const h=Ts.dot(Jc),p=As.dot(Jc);if(h<=0&&p<=0)return t.copy(r);Qc.subVectors(e,i);const m=Ts.dot(Qc),g=As.dot(Qc);if(m>=0&&g<=m)return t.copy(i);const y=h*g-m*p;if(y<=0&&h>=0&&m<=0)return c=h/(h-m),t.copy(r).addScaledVector(Ts,c);eu.subVectors(e,a);const x=Ts.dot(eu),b=As.dot(eu);if(b>=0&&x<=b)return t.copy(a);const S=x*p-h*b;if(S<=0&&p>=0&&b<=0)return u=p/(p-b),t.copy(r).addScaledVector(As,u);const M=m*b-x*g;if(M<=0&&g-m>=0&&x-b>=0)return ep.subVectors(a,i),u=(g-m)/(g-m+(x-b)),t.copy(i).addScaledVector(ep,u);const A=1/(M+S+y);return c=S*A,u=y*A,t.copy(r).addScaledVector(Ts,c).addScaledVector(As,u)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}let Zy=0;function rn(){Object.defineProperty(this,"id",{value:Zy++}),this.uuid=it(),this.name="",this.type="Material",this.fog=!0,this.blending=1,this.side=0,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=204,this.blendDst=205,this.blendEquation=100,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=3,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=519,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=7680,this.stencilZFail=7680,this.stencilZPass=7680,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaTest=0,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0}rn.prototype=Object.assign(Object.create(ce.prototype),{constructor:rn,isMaterial:!0,onBuild:function(){},onBeforeCompile:function(){},customProgramCacheKey:function(){return this.onBeforeCompile.toString()},setValues:function(o){if(o!==void 0)for(const e in o){const t=o[e];if(t===void 0){console.warn("THREE.Material: '"+e+"' parameter is undefined.");continue}if(e==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=t===1;continue}const r=this[e];r!==void 0?r&&r.isColor?r.set(t):r&&r.isVector3&&t&&t.isVector3?r.copy(t):this[e]=t:console.warn("THREE."+this.type+": '"+e+"' is not a property of this material.")}},toJSON:function(o){const e=o===void 0||typeof o=="string";e&&(o={textures:{},images:{}});const t={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};function r(i){const a=[];for(const c in i){const u=i[c];delete u.metadata,a.push(u)}return a}if(t.uuid=this.uuid,t.type=this.type,this.name!==""&&(t.name=this.name),this.color&&this.color.isColor&&(t.color=this.color.getHex()),this.roughness!==void 0&&(t.roughness=this.roughness),this.metalness!==void 0&&(t.metalness=this.metalness),this.sheen&&this.sheen.isColor&&(t.sheen=this.sheen.getHex()),this.emissive&&this.emissive.isColor&&(t.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(t.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(t.specular=this.specular.getHex()),this.shininess!==void 0&&(t.shininess=this.shininess),this.clearcoat!==void 0&&(t.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(t.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(t.clearcoatMap=this.clearcoatMap.toJSON(o).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(t.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(o).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(t.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(o).uuid,t.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(t.map=this.map.toJSON(o).uuid),this.matcap&&this.matcap.isTexture&&(t.matcap=this.matcap.toJSON(o).uuid),this.alphaMap&&this.alphaMap.isTexture&&(t.alphaMap=this.alphaMap.toJSON(o).uuid),this.lightMap&&this.lightMap.isTexture&&(t.lightMap=this.lightMap.toJSON(o).uuid,t.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(t.aoMap=this.aoMap.toJSON(o).uuid,t.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(t.bumpMap=this.bumpMap.toJSON(o).uuid,t.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(t.normalMap=this.normalMap.toJSON(o).uuid,t.normalMapType=this.normalMapType,t.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(t.displacementMap=this.displacementMap.toJSON(o).uuid,t.displacementScale=this.displacementScale,t.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(t.roughnessMap=this.roughnessMap.toJSON(o).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(t.metalnessMap=this.metalnessMap.toJSON(o).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(t.emissiveMap=this.emissiveMap.toJSON(o).uuid),this.specularMap&&this.specularMap.isTexture&&(t.specularMap=this.specularMap.toJSON(o).uuid),this.envMap&&this.envMap.isTexture&&(t.envMap=this.envMap.toJSON(o).uuid,this.combine!==void 0&&(t.combine=this.combine)),this.envMapIntensity!==void 0&&(t.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(t.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(t.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(t.gradientMap=this.gradientMap.toJSON(o).uuid),this.size!==void 0&&(t.size=this.size),this.shadowSide!==null&&(t.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(t.sizeAttenuation=this.sizeAttenuation),this.blending!==1&&(t.blending=this.blending),this.side!==0&&(t.side=this.side),this.vertexColors&&(t.vertexColors=!0),this.opacity<1&&(t.opacity=this.opacity),this.transparent===!0&&(t.transparent=this.transparent),t.depthFunc=this.depthFunc,t.depthTest=this.depthTest,t.depthWrite=this.depthWrite,t.colorWrite=this.colorWrite,t.stencilWrite=this.stencilWrite,t.stencilWriteMask=this.stencilWriteMask,t.stencilFunc=this.stencilFunc,t.stencilRef=this.stencilRef,t.stencilFuncMask=this.stencilFuncMask,t.stencilFail=this.stencilFail,t.stencilZFail=this.stencilZFail,t.stencilZPass=this.stencilZPass,this.rotation&&this.rotation!==0&&(t.rotation=this.rotation),this.polygonOffset===!0&&(t.polygonOffset=!0),this.polygonOffsetFactor!==0&&(t.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(t.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&this.linewidth!==1&&(t.linewidth=this.linewidth),this.dashSize!==void 0&&(t.dashSize=this.dashSize),this.gapSize!==void 0&&(t.gapSize=this.gapSize),this.scale!==void 0&&(t.scale=this.scale),this.dithering===!0&&(t.dithering=!0),this.alphaTest>0&&(t.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(t.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(t.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(t.wireframe=this.wireframe),this.wireframeLinewidth>1&&(t.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(t.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(t.wireframeLinejoin=this.wireframeLinejoin),this.morphTargets===!0&&(t.morphTargets=!0),this.morphNormals===!0&&(t.morphNormals=!0),this.skinning===!0&&(t.skinning=!0),this.flatShading===!0&&(t.flatShading=this.flatShading),this.visible===!1&&(t.visible=!1),this.toneMapped===!1&&(t.toneMapped=!1),JSON.stringify(this.userData)!=="{}"&&(t.userData=this.userData),e){const i=r(o.textures),a=r(o.images);i.length>0&&(t.textures=i),a.length>0&&(t.images=a)}return t},clone:function(){return new this.constructor().copy(this)},copy:function(o){this.name=o.name,this.fog=o.fog,this.blending=o.blending,this.side=o.side,this.vertexColors=o.vertexColors,this.opacity=o.opacity,this.transparent=o.transparent,this.blendSrc=o.blendSrc,this.blendDst=o.blendDst,this.blendEquation=o.blendEquation,this.blendSrcAlpha=o.blendSrcAlpha,this.blendDstAlpha=o.blendDstAlpha,this.blendEquationAlpha=o.blendEquationAlpha,this.depthFunc=o.depthFunc,this.depthTest=o.depthTest,this.depthWrite=o.depthWrite,this.stencilWriteMask=o.stencilWriteMask,this.stencilFunc=o.stencilFunc,this.stencilRef=o.stencilRef,this.stencilFuncMask=o.stencilFuncMask,this.stencilFail=o.stencilFail,this.stencilZFail=o.stencilZFail,this.stencilZPass=o.stencilZPass,this.stencilWrite=o.stencilWrite;const e=o.clippingPlanes;let t=null;if(e!==null){const r=e.length;t=new Array(r);for(let i=0;i!==r;++i)t[i]=e[i].clone()}return this.clippingPlanes=t,this.clipIntersection=o.clipIntersection,this.clipShadows=o.clipShadows,this.shadowSide=o.shadowSide,this.colorWrite=o.colorWrite,this.precision=o.precision,this.polygonOffset=o.polygonOffset,this.polygonOffsetFactor=o.polygonOffsetFactor,this.polygonOffsetUnits=o.polygonOffsetUnits,this.dithering=o.dithering,this.alphaTest=o.alphaTest,this.alphaToCoverage=o.alphaToCoverage,this.premultipliedAlpha=o.premultipliedAlpha,this.visible=o.visible,this.toneMapped=o.toneMapped,this.userData=JSON.parse(JSON.stringify(o.userData)),this},dispose:function(){this.dispatchEvent({type:"dispose"})}}),Object.defineProperty(rn.prototype,"needsUpdate",{set:function(o){o===!0&&this.version++}});const tp={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},dr={h:0,s:0,l:0},Na={h:0,s:0,l:0};function tu(o,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?o+6*(e-o)*t:t<.5?e:t<2/3?o+6*(e-o)*(2/3-t):o}function nu(o){return o<.04045?.0773993808*o:Math.pow(.9478672986*o+.0521327014,2.4)}function ru(o){return o<.0031308?12.92*o:1.055*Math.pow(o,.41666)-.055}class Ge{constructor(e,t,r){return t===void 0&&r===void 0?this.set(e):this.setRGB(e,t,r)}set(e){return e&&e.isColor?this.copy(e):typeof e=="number"?this.setHex(e):typeof e=="string"&&this.setStyle(e),this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(255&e)/255,this}setRGB(e,t,r){return this.r=e,this.g=t,this.b=r,this}setHSL(e,t,r){if(e=Rt(e,1),t=ct(t,0,1),r=ct(r,0,1),t===0)this.r=this.g=this.b=r;else{const i=r<=.5?r*(1+t):r+t-r*t,a=2*r-i;this.r=tu(a,i,e+1/3),this.g=tu(a,i,e),this.b=tu(a,i,e-1/3)}return this}setStyle(e){function t(i){i!==void 0&&parseFloat(i)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let r;if(r=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)){let i;const a=r[1],c=r[2];switch(a){case"rgb":case"rgba":if(i=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(c))return this.r=Math.min(255,parseInt(i[1],10))/255,this.g=Math.min(255,parseInt(i[2],10))/255,this.b=Math.min(255,parseInt(i[3],10))/255,t(i[4]),this;if(i=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(c))return this.r=Math.min(100,parseInt(i[1],10))/100,this.g=Math.min(100,parseInt(i[2],10))/100,this.b=Math.min(100,parseInt(i[3],10))/100,t(i[4]),this;break;case"hsl":case"hsla":if(i=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(c)){const u=parseFloat(i[1])/360,h=parseInt(i[2],10)/100,p=parseInt(i[3],10)/100;return t(i[4]),this.setHSL(u,h,p)}}}else if(r=/^\#([A-Fa-f\d]+)$/.exec(e)){const i=r[1],a=i.length;if(a===3)return this.r=parseInt(i.charAt(0)+i.charAt(0),16)/255,this.g=parseInt(i.charAt(1)+i.charAt(1),16)/255,this.b=parseInt(i.charAt(2)+i.charAt(2),16)/255,this;if(a===6)return this.r=parseInt(i.charAt(0)+i.charAt(1),16)/255,this.g=parseInt(i.charAt(2)+i.charAt(3),16)/255,this.b=parseInt(i.charAt(4)+i.charAt(5),16)/255,this}return e&&e.length>0?this.setColorName(e):this}setColorName(e){const t=tp[e.toLowerCase()];return t!==void 0?this.setHex(t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copyGammaToLinear(e,t=2){return this.r=Math.pow(e.r,t),this.g=Math.pow(e.g,t),this.b=Math.pow(e.b,t),this}copyLinearToGamma(e,t=2){const r=t>0?1/t:1;return this.r=Math.pow(e.r,r),this.g=Math.pow(e.g,r),this.b=Math.pow(e.b,r),this}convertGammaToLinear(e){return this.copyGammaToLinear(this,e),this}convertLinearToGamma(e){return this.copyLinearToGamma(this,e),this}copySRGBToLinear(e){return this.r=nu(e.r),this.g=nu(e.g),this.b=nu(e.b),this}copyLinearToSRGB(e){return this.r=ru(e.r),this.g=ru(e.g),this.b=ru(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return 255*this.r<<16^255*this.g<<8^255*this.b<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(e){e===void 0&&(console.warn("THREE.Color: .getHSL() target is now required"),e={h:0,s:0,l:0});const t=this.r,r=this.g,i=this.b,a=Math.max(t,r,i),c=Math.min(t,r,i);let u,h;const p=(c+a)/2;if(c===a)u=0,h=0;else{const m=a-c;switch(h=p<=.5?m/(a+c):m/(2-a-c),a){case t:u=(r-i)/m+(r<i?6:0);break;case r:u=(i-t)/m+2;break;case i:u=(t-r)/m+4}u/=6}return e.h=u,e.s=h,e.l=p,e}getStyle(){return"rgb("+(255*this.r|0)+","+(255*this.g|0)+","+(255*this.b|0)+")"}offsetHSL(e,t,r){return this.getHSL(dr),dr.h+=e,dr.s+=t,dr.l+=r,this.setHSL(dr.h,dr.s,dr.l),this}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,r){return this.r=e.r+(t.r-e.r)*r,this.g=e.g+(t.g-e.g)*r,this.b=e.b+(t.b-e.b)*r,this}lerpHSL(e,t){this.getHSL(dr),e.getHSL(Na);const r=nn(dr.h,Na.h,t),i=nn(dr.s,Na.s,t),a=nn(dr.l,Na.l,t);return this.setHSL(r,i,a),this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),e.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}Ge.NAMES=tp,Ge.prototype.isColor=!0,Ge.prototype.r=1,Ge.prototype.g=1,Ge.prototype.b=1;class Zr extends rn{constructor(e){super(),this.type="MeshBasicMaterial",this.color=new Ge(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this}}Zr.prototype.isMeshBasicMaterial=!0;const Gt=new O,ka=new Ee;class xt{constructor(e,t,r){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=r===!0,this.usage=35044,this.updateRange={offset:0,count:-1},this.version=0,this.onUploadCallback=function(){}}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this}copyAt(e,t,r){e*=this.itemSize,r*=t.itemSize;for(let i=0,a=this.itemSize;i<a;i++)this.array[e+i]=t.array[r+i];return this}copyArray(e){return this.array.set(e),this}copyColorsArray(e){const t=this.array;let r=0;for(let i=0,a=e.length;i<a;i++){let c=e[i];c===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",i),c=new Ge),t[r++]=c.r,t[r++]=c.g,t[r++]=c.b}return this}copyVector2sArray(e){const t=this.array;let r=0;for(let i=0,a=e.length;i<a;i++){let c=e[i];c===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",i),c=new Ee),t[r++]=c.x,t[r++]=c.y}return this}copyVector3sArray(e){const t=this.array;let r=0;for(let i=0,a=e.length;i<a;i++){let c=e[i];c===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",i),c=new O),t[r++]=c.x,t[r++]=c.y,t[r++]=c.z}return this}copyVector4sArray(e){const t=this.array;let r=0;for(let i=0,a=e.length;i<a;i++){let c=e[i];c===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",i),c=new Dt),t[r++]=c.x,t[r++]=c.y,t[r++]=c.z,t[r++]=c.w}return this}applyMatrix3(e){if(this.itemSize===2)for(let t=0,r=this.count;t<r;t++)ka.fromBufferAttribute(this,t),ka.applyMatrix3(e),this.setXY(t,ka.x,ka.y);else if(this.itemSize===3)for(let t=0,r=this.count;t<r;t++)Gt.fromBufferAttribute(this,t),Gt.applyMatrix3(e),this.setXYZ(t,Gt.x,Gt.y,Gt.z);return this}applyMatrix4(e){for(let t=0,r=this.count;t<r;t++)Gt.x=this.getX(t),Gt.y=this.getY(t),Gt.z=this.getZ(t),Gt.applyMatrix4(e),this.setXYZ(t,Gt.x,Gt.y,Gt.z);return this}applyNormalMatrix(e){for(let t=0,r=this.count;t<r;t++)Gt.x=this.getX(t),Gt.y=this.getY(t),Gt.z=this.getZ(t),Gt.applyNormalMatrix(e),this.setXYZ(t,Gt.x,Gt.y,Gt.z);return this}transformDirection(e){for(let t=0,r=this.count;t<r;t++)Gt.x=this.getX(t),Gt.y=this.getY(t),Gt.z=this.getZ(t),Gt.transformDirection(e),this.setXYZ(t,Gt.x,Gt.y,Gt.z);return this}set(e,t=0){return this.array.set(e,t),this}getX(e){return this.array[e*this.itemSize]}setX(e,t){return this.array[e*this.itemSize]=t,this}getY(e){return this.array[e*this.itemSize+1]}setY(e,t){return this.array[e*this.itemSize+1]=t,this}getZ(e){return this.array[e*this.itemSize+2]}setZ(e,t){return this.array[e*this.itemSize+2]=t,this}getW(e){return this.array[e*this.itemSize+3]}setW(e,t){return this.array[e*this.itemSize+3]=t,this}setXY(e,t,r){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=r,this}setXYZ(e,t,r,i){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=r,this.array[e+2]=i,this}setXYZW(e,t,r,i,a){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=r,this.array[e+2]=i,this.array[e+3]=a,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==35044&&(e.usage=this.usage),this.updateRange.offset===0&&this.updateRange.count===-1||(e.updateRange=this.updateRange),e}}xt.prototype.isBufferAttribute=!0;class np extends xt{constructor(e,t,r){super(new Int8Array(e),t,r)}}class rp extends xt{constructor(e,t,r){super(new Uint8Array(e),t,r)}}class ip extends xt{constructor(e,t,r){super(new Uint8ClampedArray(e),t,r)}}class sp extends xt{constructor(e,t,r){super(new Int16Array(e),t,r)}}class Ha extends xt{constructor(e,t,r){super(new Uint16Array(e),t,r)}}class op extends xt{constructor(e,t,r){super(new Int32Array(e),t,r)}}class Fa extends xt{constructor(e,t,r){super(new Uint32Array(e),t,r)}}class ap extends xt{constructor(e,t,r){super(new Uint16Array(e),t,r)}}ap.prototype.isFloat16BufferAttribute=!0;class qe extends xt{constructor(e,t,r){super(new Float32Array(e),t,r)}}class lp extends xt{constructor(e,t,r){super(new Float64Array(e),t,r)}}function cp(o){if(o.length===0)return-1/0;let e=o[0];for(let t=1,r=o.length;t<r;++t)o[t]>e&&(e=o[t]);return e}const Ky={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function ho(o,e){return new Ky[o](e)}let $y=0;const Tr=new Ze,iu=new yt,Rs=new O,Jn=new Wn,po=new Wn,mn=new O;class Qe extends ce{constructor(){super(),Object.defineProperty(this,"id",{value:$y++}),this.uuid=it(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(cp(e)>65535?Fa:Ha)(e,1):this.index=e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,t,r=0){this.groups.push({start:e,count:t,materialIndex:r})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);const r=this.attributes.normal;if(r!==void 0){const a=new St().getNormalMatrix(e);r.applyNormalMatrix(a),r.needsUpdate=!0}const i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(e),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}rotateX(e){return Tr.makeRotationX(e),this.applyMatrix4(Tr),this}rotateY(e){return Tr.makeRotationY(e),this.applyMatrix4(Tr),this}rotateZ(e){return Tr.makeRotationZ(e),this.applyMatrix4(Tr),this}translate(e,t,r){return Tr.makeTranslation(e,t,r),this.applyMatrix4(Tr),this}scale(e,t,r){return Tr.makeScale(e,t,r),this.applyMatrix4(Tr),this}lookAt(e){return iu.lookAt(e),iu.updateMatrix(),this.applyMatrix4(iu.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Rs).negate(),this.translate(Rs.x,Rs.y,Rs.z),this}setFromPoints(e){const t=[];for(let r=0,i=e.length;r<i;r++){const a=e[r];t.push(a.x,a.y,a.z||0)}return this.setAttribute("position",new qe(t,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Wn);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new O(-1/0,-1/0,-1/0),new O(1/0,1/0,1/0));if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let r=0,i=t.length;r<i;r++){const a=t[r];Jn.setFromBufferAttribute(a),this.morphTargetsRelative?(mn.addVectors(this.boundingBox.min,Jn.min),this.boundingBox.expandByPoint(mn),mn.addVectors(this.boundingBox.max,Jn.max),this.boundingBox.expandByPoint(mn)):(this.boundingBox.expandByPoint(Jn.min),this.boundingBox.expandByPoint(Jn.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new fi);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new O,1/0);if(e){const r=this.boundingSphere.center;if(Jn.setFromBufferAttribute(e),t)for(let a=0,c=t.length;a<c;a++){const u=t[a];po.setFromBufferAttribute(u),this.morphTargetsRelative?(mn.addVectors(Jn.min,po.min),Jn.expandByPoint(mn),mn.addVectors(Jn.max,po.max),Jn.expandByPoint(mn)):(Jn.expandByPoint(po.min),Jn.expandByPoint(po.max))}Jn.getCenter(r);let i=0;for(let a=0,c=e.count;a<c;a++)mn.fromBufferAttribute(e,a),i=Math.max(i,r.distanceToSquared(mn));if(t)for(let a=0,c=t.length;a<c;a++){const u=t[a],h=this.morphTargetsRelative;for(let p=0,m=u.count;p<m;p++)mn.fromBufferAttribute(u,p),h&&(Rs.fromBufferAttribute(e,p),mn.add(Rs)),i=Math.max(i,r.distanceToSquared(mn))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeFaceNormals(){}computeTangents(){const e=this.index,t=this.attributes;if(e===null||t.position===void 0||t.normal===void 0||t.uv===void 0)return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const r=e.array,i=t.position.array,a=t.normal.array,c=t.uv.array,u=i.length/3;t.tangent===void 0&&this.setAttribute("tangent",new xt(new Float32Array(4*u),4));const h=t.tangent.array,p=[],m=[];for(let Z=0;Z<u;Z++)p[Z]=new O,m[Z]=new O;const g=new O,y=new O,x=new O,b=new Ee,S=new Ee,M=new Ee,A=new O,I=new O;function k(Z,J,re){g.fromArray(i,3*Z),y.fromArray(i,3*J),x.fromArray(i,3*re),b.fromArray(c,2*Z),S.fromArray(c,2*J),M.fromArray(c,2*re),y.sub(g),x.sub(g),S.sub(b),M.sub(b);const ee=1/(S.x*M.y-M.x*S.y);isFinite(ee)&&(A.copy(y).multiplyScalar(M.y).addScaledVector(x,-S.y).multiplyScalar(ee),I.copy(x).multiplyScalar(S.x).addScaledVector(y,-M.x).multiplyScalar(ee),p[Z].add(A),p[J].add(A),p[re].add(A),m[Z].add(I),m[J].add(I),m[re].add(I))}let N=this.groups;N.length===0&&(N=[{start:0,count:r.length}]);for(let Z=0,J=N.length;Z<J;++Z){const re=N[Z],ee=re.start;for(let le=ee,Ce=ee+re.count;le<Ce;le+=3)k(r[le+0],r[le+1],r[le+2])}const G=new O,U=new O,B=new O,V=new O;function he(Z){B.fromArray(a,3*Z),V.copy(B);const J=p[Z];G.copy(J),G.sub(B.multiplyScalar(B.dot(J))).normalize(),U.crossVectors(V,J);const re=U.dot(m[Z])<0?-1:1;h[4*Z]=G.x,h[4*Z+1]=G.y,h[4*Z+2]=G.z,h[4*Z+3]=re}for(let Z=0,J=N.length;Z<J;++Z){const re=N[Z],ee=re.start;for(let le=ee,Ce=ee+re.count;le<Ce;le+=3)he(r[le+0]),he(r[le+1]),he(r[le+2])}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(t!==void 0){let r=this.getAttribute("normal");if(r===void 0)r=new xt(new Float32Array(3*t.count),3),this.setAttribute("normal",r);else for(let y=0,x=r.count;y<x;y++)r.setXYZ(y,0,0,0);const i=new O,a=new O,c=new O,u=new O,h=new O,p=new O,m=new O,g=new O;if(e)for(let y=0,x=e.count;y<x;y+=3){const b=e.getX(y+0),S=e.getX(y+1),M=e.getX(y+2);i.fromBufferAttribute(t,b),a.fromBufferAttribute(t,S),c.fromBufferAttribute(t,M),m.subVectors(c,a),g.subVectors(i,a),m.cross(g),u.fromBufferAttribute(r,b),h.fromBufferAttribute(r,S),p.fromBufferAttribute(r,M),u.add(m),h.add(m),p.add(m),r.setXYZ(b,u.x,u.y,u.z),r.setXYZ(S,h.x,h.y,h.z),r.setXYZ(M,p.x,p.y,p.z)}else for(let y=0,x=t.count;y<x;y+=3)i.fromBufferAttribute(t,y+0),a.fromBufferAttribute(t,y+1),c.fromBufferAttribute(t,y+2),m.subVectors(c,a),g.subVectors(i,a),m.cross(g),r.setXYZ(y+0,m.x,m.y,m.z),r.setXYZ(y+1,m.x,m.y,m.z),r.setXYZ(y+2,m.x,m.y,m.z);this.normalizeNormals(),r.needsUpdate=!0}}merge(e,t){if(!e||!e.isBufferGeometry)return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",e);t===void 0&&(t=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const r=this.attributes;for(const i in r){if(e.attributes[i]===void 0)continue;const a=r[i].array,c=e.attributes[i],u=c.array,h=c.itemSize*t,p=Math.min(u.length,a.length-h);for(let m=0,g=h;m<p;m++,g++)a[g]=u[m]}return this}normalizeNormals(){const e=this.attributes.normal;for(let t=0,r=e.count;t<r;t++)mn.fromBufferAttribute(e,t),mn.normalize(),e.setXYZ(t,mn.x,mn.y,mn.z)}toNonIndexed(){function e(u,h){const p=u.array,m=u.itemSize,g=u.normalized,y=new p.constructor(h.length*m);let x=0,b=0;for(let S=0,M=h.length;S<M;S++){x=h[S]*m;for(let A=0;A<m;A++)y[b++]=p[x++]}return new xt(y,m,g)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new Qe,r=this.index.array,i=this.attributes;for(const u in i){const h=e(i[u],r);t.setAttribute(u,h)}const a=this.morphAttributes;for(const u in a){const h=[],p=a[u];for(let m=0,g=p.length;m<g;m++){const y=e(p[m],r);h.push(y)}t.morphAttributes[u]=h}t.morphTargetsRelative=this.morphTargetsRelative;const c=this.groups;for(let u=0,h=c.length;u<h;u++){const p=c[u];t.addGroup(p.start,p.count,p.materialIndex)}return t}toJSON(){const e={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const h=this.parameters;for(const p in h)h[p]!==void 0&&(e[p]=h[p]);return e}e.data={attributes:{}};const t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const r=this.attributes;for(const h in r){const p=r[h];e.data.attributes[h]=p.toJSON(e.data)}const i={};let a=!1;for(const h in this.morphAttributes){const p=this.morphAttributes[h],m=[];for(let g=0,y=p.length;g<y;g++){const x=p[g];m.push(x.toJSON(e.data))}m.length>0&&(i[h]=m,a=!0)}a&&(e.data.morphAttributes=i,e.data.morphTargetsRelative=this.morphTargetsRelative);const c=this.groups;c.length>0&&(e.data.groups=JSON.parse(JSON.stringify(c)));const u=this.boundingSphere;return u!==null&&(e.data.boundingSphere={center:u.center.toArray(),radius:u.radius}),e}clone(){return new Qe().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const r=e.index;r!==null&&this.setIndex(r.clone(t));const i=e.attributes;for(const p in i){const m=i[p];this.setAttribute(p,m.clone(t))}const a=e.morphAttributes;for(const p in a){const m=[],g=a[p];for(let y=0,x=g.length;y<x;y++)m.push(g[y].clone(t));this.morphAttributes[p]=m}this.morphTargetsRelative=e.morphTargetsRelative;const c=e.groups;for(let p=0,m=c.length;p<m;p++){const g=c[p];this.addGroup(g.start,g.count,g.materialIndex)}const u=e.boundingBox;u!==null&&(this.boundingBox=u.clone());const h=e.boundingSphere;return h!==null&&(this.boundingSphere=h.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}Qe.prototype.isBufferGeometry=!0;const up=new Ze,Ls=new gi,su=new fi,yi=new O,xi=new O,_i=new O,ou=new O,au=new O,lu=new O,Ba=new O,za=new O,Ua=new O,Ga=new Ee,Va=new Ee,Wa=new Ee,cu=new O,ja=new O;class sn extends yt{constructor(e=new Qe,t=new Zr){super(),this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=e.material,this.geometry=e.geometry,this}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,r=Object.keys(t);if(r.length>0){const i=t[r[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let a=0,c=i.length;a<c;a++){const u=i[a].name||String(a);this.morphTargetInfluences.push(0),this.morphTargetDictionary[u]=a}}}}else{const t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}raycast(e,t){const r=this.geometry,i=this.material,a=this.matrixWorld;if(i===void 0||(r.boundingSphere===null&&r.computeBoundingSphere(),su.copy(r.boundingSphere),su.applyMatrix4(a),e.ray.intersectsSphere(su)===!1)||(up.copy(a).invert(),Ls.copy(e.ray).applyMatrix4(up),r.boundingBox!==null&&Ls.intersectsBox(r.boundingBox)===!1))return;let c;if(r.isBufferGeometry){const u=r.index,h=r.attributes.position,p=r.morphAttributes.position,m=r.morphTargetsRelative,g=r.attributes.uv,y=r.attributes.uv2,x=r.groups,b=r.drawRange;if(u!==null)if(Array.isArray(i))for(let S=0,M=x.length;S<M;S++){const A=x[S],I=i[A.materialIndex];for(let k=Math.max(A.start,b.start),N=Math.min(A.start+A.count,b.start+b.count);k<N;k+=3){const G=u.getX(k),U=u.getX(k+1),B=u.getX(k+2);c=qa(this,I,e,Ls,h,p,m,g,y,G,U,B),c&&(c.faceIndex=Math.floor(k/3),c.face.materialIndex=A.materialIndex,t.push(c))}}else for(let S=Math.max(0,b.start),M=Math.min(u.count,b.start+b.count);S<M;S+=3){const A=u.getX(S),I=u.getX(S+1),k=u.getX(S+2);c=qa(this,i,e,Ls,h,p,m,g,y,A,I,k),c&&(c.faceIndex=Math.floor(S/3),t.push(c))}else if(h!==void 0)if(Array.isArray(i))for(let S=0,M=x.length;S<M;S++){const A=x[S],I=i[A.materialIndex];for(let k=Math.max(A.start,b.start),N=Math.min(A.start+A.count,b.start+b.count);k<N;k+=3)c=qa(this,I,e,Ls,h,p,m,g,y,k,k+1,k+2),c&&(c.faceIndex=Math.floor(k/3),c.face.materialIndex=A.materialIndex,t.push(c))}else for(let S=Math.max(0,b.start),M=Math.min(h.count,b.start+b.count);S<M;S+=3)c=qa(this,i,e,Ls,h,p,m,g,y,S,S+1,S+2),c&&(c.faceIndex=Math.floor(S/3),t.push(c))}else r.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}function qa(o,e,t,r,i,a,c,u,h,p,m,g){yi.fromBufferAttribute(i,p),xi.fromBufferAttribute(i,m),_i.fromBufferAttribute(i,g);const y=o.morphTargetInfluences;if(e.morphTargets&&a&&y){Ba.set(0,0,0),za.set(0,0,0),Ua.set(0,0,0);for(let b=0,S=a.length;b<S;b++){const M=y[b],A=a[b];M!==0&&(ou.fromBufferAttribute(A,p),au.fromBufferAttribute(A,m),lu.fromBufferAttribute(A,g),c?(Ba.addScaledVector(ou,M),za.addScaledVector(au,M),Ua.addScaledVector(lu,M)):(Ba.addScaledVector(ou.sub(yi),M),za.addScaledVector(au.sub(xi),M),Ua.addScaledVector(lu.sub(_i),M)))}yi.add(Ba),xi.add(za),_i.add(Ua)}o.isSkinnedMesh&&e.skinning&&(o.boneTransform(p,yi),o.boneTransform(m,xi),o.boneTransform(g,_i));const x=function(b,S,M,A,I,k,N,G){let U;if(U=S.side===1?A.intersectTriangle(N,k,I,!0,G):A.intersectTriangle(I,k,N,S.side!==2,G),U===null)return null;ja.copy(G),ja.applyMatrix4(b.matrixWorld);const B=M.ray.origin.distanceTo(ja);return B<M.near||B>M.far?null:{distance:B,point:ja.clone(),object:b}}(o,e,t,r,yi,xi,_i,cu);if(x){u&&(Ga.fromBufferAttribute(u,p),Va.fromBufferAttribute(u,m),Wa.fromBufferAttribute(u,g),x.uv=Jt.getUV(cu,yi,xi,_i,Ga,Va,Wa,new Ee)),h&&(Ga.fromBufferAttribute(h,p),Va.fromBufferAttribute(h,m),Wa.fromBufferAttribute(h,g),x.uv2=Jt.getUV(cu,yi,xi,_i,Ga,Va,Wa,new Ee));const b={a:p,b:m,c:g,normal:new O,materialIndex:0};Jt.getNormal(yi,xi,_i,b.normal),x.face=b}return x}sn.prototype.isMesh=!0;class zi extends Qe{constructor(e=1,t=1,r=1,i=1,a=1,c=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:r,widthSegments:i,heightSegments:a,depthSegments:c};const u=this;i=Math.floor(i),a=Math.floor(a),c=Math.floor(c);const h=[],p=[],m=[],g=[];let y=0,x=0;function b(S,M,A,I,k,N,G,U,B,V,he){const Z=N/B,J=G/V,re=N/2,ee=G/2,le=U/2,Ce=B+1,Pe=V+1;let We=0,Oe=0;const De=new O;for(let ze=0;ze<Pe;ze++){const st=ze*J-ee;for(let q=0;q<Ce;q++){const Y=q*Z-re;De[S]=Y*I,De[M]=st*k,De[A]=le,p.push(De.x,De.y,De.z),De[S]=0,De[M]=0,De[A]=U>0?1:-1,m.push(De.x,De.y,De.z),g.push(q/B),g.push(1-ze/V),We+=1}}for(let ze=0;ze<V;ze++)for(let st=0;st<B;st++){const q=y+st+Ce*ze,Y=y+st+Ce*(ze+1),fe=y+(st+1)+Ce*(ze+1),de=y+(st+1)+Ce*ze;h.push(q,Y,de),h.push(Y,fe,de),Oe+=6}u.addGroup(x,Oe,he),x+=Oe,y+=We}b("z","y","x",-1,-1,r,t,e,c,a,0),b("z","y","x",1,-1,r,t,-e,c,a,1),b("x","z","y",1,1,e,r,t,i,c,2),b("x","z","y",1,-1,e,r,-t,i,c,3),b("x","y","z",1,-1,e,t,r,i,a,4),b("x","y","z",-1,-1,e,t,-r,i,a,5),this.setIndex(h),this.setAttribute("position",new qe(p,3)),this.setAttribute("normal",new qe(m,3)),this.setAttribute("uv",new qe(g,2))}}function Cs(o){const e={};for(const t in o){e[t]={};for(const r in o[t]){const i=o[t][r];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?e[t][r]=i.clone():Array.isArray(i)?e[t][r]=i.slice():e[t][r]=i}}return e}function Tn(o){const e={};for(let t=0;t<o.length;t++){const r=Cs(o[t]);for(const i in r)e[i]=r[i]}return e}const hp={clone:Cs,merge:Tn};class Kr extends rn{constructor(e){super(),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,this.fragmentShader=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&(e.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(e))}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=Cs(e.uniforms),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.lights=e.lights,this.clipping=e.clipping,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const i in this.uniforms){const a=this.uniforms[i].value;a&&a.isTexture?t.uniforms[i]={type:"t",value:a.toJSON(e).uuid}:a&&a.isColor?t.uniforms[i]={type:"c",value:a.getHex()}:a&&a.isVector2?t.uniforms[i]={type:"v2",value:a.toArray()}:a&&a.isVector3?t.uniforms[i]={type:"v3",value:a.toArray()}:a&&a.isVector4?t.uniforms[i]={type:"v4",value:a.toArray()}:a&&a.isMatrix3?t.uniforms[i]={type:"m3",value:a.toArray()}:a&&a.isMatrix4?t.uniforms[i]={type:"m4",value:a.toArray()}:t.uniforms[i]={value:a}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader;const r={};for(const i in this.extensions)this.extensions[i]===!0&&(r[i]=!0);return Object.keys(r).length>0&&(t.extensions=r),t}}Kr.prototype.isShaderMaterial=!0;class fo extends yt{constructor(){super(),this.type="Camera",this.matrixWorldInverse=new Ze,this.projectionMatrix=new Ze,this.projectionMatrixInverse=new Ze}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this}getWorldDirection(e){e===void 0&&(console.warn("THREE.Camera: .getWorldDirection() target is now required"),e=new O),this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(-t[8],-t[9],-t[10]).normalize()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}fo.prototype.isCamera=!0;class gn extends fo{constructor(e=50,t=1,r=.1,i=2e3){super(),this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=r,this.far=i,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=2*tt*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(.5*Ue*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return 2*tt*Math.atan(Math.tan(.5*Ue*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(e,t,r,i,a,c){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=r,this.view.offsetY=i,this.view.width=a,this.view.height=c,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(.5*Ue*this.fov)/this.zoom,r=2*t,i=this.aspect*r,a=-.5*i;const c=this.view;if(this.view!==null&&this.view.enabled){const h=c.fullWidth,p=c.fullHeight;a+=c.offsetX*i/h,t-=c.offsetY*r/p,i*=c.width/h,r*=c.height/p}const u=this.filmOffset;u!==0&&(a+=e*u/this.getFilmWidth()),this.projectionMatrix.makePerspective(a,a+i,t,t-r,e,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}gn.prototype.isPerspectiveCamera=!0;const Ps=90;class Xa extends yt{constructor(e,t,r){if(super(),this.type="CubeCamera",r.isWebGLCubeRenderTarget!==!0)return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");this.renderTarget=r;const i=new gn(Ps,1,e,t);i.layers=this.layers,i.up.set(0,-1,0),i.lookAt(new O(1,0,0)),this.add(i);const a=new gn(Ps,1,e,t);a.layers=this.layers,a.up.set(0,-1,0),a.lookAt(new O(-1,0,0)),this.add(a);const c=new gn(Ps,1,e,t);c.layers=this.layers,c.up.set(0,0,1),c.lookAt(new O(0,1,0)),this.add(c);const u=new gn(Ps,1,e,t);u.layers=this.layers,u.up.set(0,0,-1),u.lookAt(new O(0,-1,0)),this.add(u);const h=new gn(Ps,1,e,t);h.layers=this.layers,h.up.set(0,-1,0),h.lookAt(new O(0,0,1)),this.add(h);const p=new gn(Ps,1,e,t);p.layers=this.layers,p.up.set(0,-1,0),p.lookAt(new O(0,0,-1)),this.add(p)}update(e,t){this.parent===null&&this.updateMatrixWorld();const r=this.renderTarget,[i,a,c,u,h,p]=this.children,m=e.xr.enabled,g=e.getRenderTarget();e.xr.enabled=!1;const y=r.texture.generateMipmaps;r.texture.generateMipmaps=!1,e.setRenderTarget(r,0),e.render(t,i),e.setRenderTarget(r,1),e.render(t,a),e.setRenderTarget(r,2),e.render(t,c),e.setRenderTarget(r,3),e.render(t,u),e.setRenderTarget(r,4),e.render(t,h),r.texture.generateMipmaps=y,e.setRenderTarget(r,5),e.render(t,p),e.setRenderTarget(g),e.xr.enabled=m}}class Is extends un{constructor(e,t,r,i,a,c,u,h,p,m){super(e=e!==void 0?e:[],t=t!==void 0?t:301,r,i,a,c,u=u!==void 0?u:1022,h,p,m),this._needsFlipEnvMap=!0,this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}Is.prototype.isCubeTexture=!0;class Ya extends Vr{constructor(e,t,r){Number.isInteger(t)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),t=r),super(e,e,t),t=t||{},this.texture=new Is(void 0,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),this.texture.generateMipmaps=t.generateMipmaps!==void 0&&t.generateMipmaps,this.texture.minFilter=t.minFilter!==void 0?t.minFilter:1006,this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.format=1023,this.texture.encoding=t.encoding,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const r={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},i=new zi(5,5,5),a=new Kr({name:"CubemapFromEquirect",uniforms:Cs(r.uniforms),vertexShader:r.vertexShader,fragmentShader:r.fragmentShader,side:1,blending:0});a.uniforms.tEquirect.value=t;const c=new sn(i,a),u=t.minFilter;return t.minFilter===1008&&(t.minFilter=1006),new Xa(1,10,this).update(e,c),t.minFilter=u,c.geometry.dispose(),c.material.dispose(),this}clear(e,t,r,i){const a=e.getRenderTarget();for(let c=0;c<6;c++)e.setRenderTarget(this,c),e.clear(t,r,i);e.setRenderTarget(a)}}Ya.prototype.isWebGLCubeRenderTarget=!0;class Os extends un{constructor(e,t,r,i,a,c,u,h,p,m,g,y){super(null,c,u,h,p,m,i,a,g,y),this.image={data:e||null,width:t||1,height:r||1},this.magFilter=p!==void 0?p:1003,this.minFilter=m!==void 0?m:1003,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}Os.prototype.isDataTexture=!0;const Ds=new fi,Za=new O;class mo{constructor(e=new ur,t=new ur,r=new ur,i=new ur,a=new ur,c=new ur){this.planes=[e,t,r,i,a,c]}set(e,t,r,i,a,c){const u=this.planes;return u[0].copy(e),u[1].copy(t),u[2].copy(r),u[3].copy(i),u[4].copy(a),u[5].copy(c),this}copy(e){const t=this.planes;for(let r=0;r<6;r++)t[r].copy(e.planes[r]);return this}setFromProjectionMatrix(e){const t=this.planes,r=e.elements,i=r[0],a=r[1],c=r[2],u=r[3],h=r[4],p=r[5],m=r[6],g=r[7],y=r[8],x=r[9],b=r[10],S=r[11],M=r[12],A=r[13],I=r[14],k=r[15];return t[0].setComponents(u-i,g-h,S-y,k-M).normalize(),t[1].setComponents(u+i,g+h,S+y,k+M).normalize(),t[2].setComponents(u+a,g+p,S+x,k+A).normalize(),t[3].setComponents(u-a,g-p,S-x,k-A).normalize(),t[4].setComponents(u-c,g-m,S-b,k-I).normalize(),t[5].setComponents(u+c,g+m,S+b,k+I).normalize(),this}intersectsObject(e){const t=e.geometry;return t.boundingSphere===null&&t.computeBoundingSphere(),Ds.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),this.intersectsSphere(Ds)}intersectsSprite(e){return Ds.center.set(0,0,0),Ds.radius=.7071067811865476,Ds.applyMatrix4(e.matrixWorld),this.intersectsSphere(Ds)}intersectsSphere(e){const t=this.planes,r=e.center,i=-e.radius;for(let a=0;a<6;a++)if(t[a].distanceToPoint(r)<i)return!1;return!0}intersectsBox(e){const t=this.planes;for(let r=0;r<6;r++){const i=t[r];if(Za.x=i.normal.x>0?e.max.x:e.min.x,Za.y=i.normal.y>0?e.max.y:e.min.y,Za.z=i.normal.z>0?e.max.z:e.min.z,i.distanceToPoint(Za)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let r=0;r<6;r++)if(t[r].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function dp(){let o=null,e=!1,t=null,r=null;function i(a,c){t(a,c),r=o.requestAnimationFrame(i)}return{start:function(){e!==!0&&t!==null&&(r=o.requestAnimationFrame(i),e=!0)},stop:function(){o.cancelAnimationFrame(r),e=!1},setAnimationLoop:function(a){t=a},setContext:function(a){o=a}}}function Jy(o,e){const t=e.isWebGL2,r=new WeakMap;return{get:function(i){return i.isInterleavedBufferAttribute&&(i=i.data),r.get(i)},remove:function(i){i.isInterleavedBufferAttribute&&(i=i.data);const a=r.get(i);a&&(o.deleteBuffer(a.buffer),r.delete(i))},update:function(i,a){if(i.isGLBufferAttribute){const u=r.get(i);return void((!u||u.version<i.version)&&r.set(i,{buffer:i.buffer,type:i.type,bytesPerElement:i.elementSize,version:i.version}))}i.isInterleavedBufferAttribute&&(i=i.data);const c=r.get(i);c===void 0?r.set(i,function(u,h){const p=u.array,m=u.usage,g=o.createBuffer();o.bindBuffer(h,g),o.bufferData(h,p,m),u.onUploadCallback();let y=5126;return p instanceof Float32Array?y=5126:p instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):p instanceof Uint16Array?u.isFloat16BufferAttribute?t?y=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):y=5123:p instanceof Int16Array?y=5122:p instanceof Uint32Array?y=5125:p instanceof Int32Array?y=5124:p instanceof Int8Array?y=5120:p instanceof Uint8Array&&(y=5121),{buffer:g,type:y,bytesPerElement:p.BYTES_PER_ELEMENT,version:u.version}}(i,a)):c.version<i.version&&(function(u,h,p){const m=h.array,g=h.updateRange;o.bindBuffer(p,u),g.count===-1?o.bufferSubData(p,0,m):(t?o.bufferSubData(p,g.offset*m.BYTES_PER_ELEMENT,m,g.offset,g.count):o.bufferSubData(p,g.offset*m.BYTES_PER_ELEMENT,m.subarray(g.offset,g.offset+g.count)),g.count=-1)}(c.buffer,i,a),c.version=i.version)}}}class go extends Qe{constructor(e=1,t=1,r=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:r,heightSegments:i};const a=e/2,c=t/2,u=Math.floor(r),h=Math.floor(i),p=u+1,m=h+1,g=e/u,y=t/h,x=[],b=[],S=[],M=[];for(let A=0;A<m;A++){const I=A*y-c;for(let k=0;k<p;k++){const N=k*g-a;b.push(N,-I,0),S.push(0,0,1),M.push(k/u),M.push(1-A/h)}}for(let A=0;A<h;A++)for(let I=0;I<u;I++){const k=I+p*A,N=I+p*(A+1),G=I+1+p*(A+1),U=I+1+p*A;x.push(k,N,U),x.push(N,G,U)}this.setIndex(x),this.setAttribute("position",new qe(b,3)),this.setAttribute("normal",new qe(S,3)),this.setAttribute("uv",new qe(M,2))}}const _t={alphamap_fragment:`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,alphamap_pars_fragment:`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,alphatest_fragment:`#ifdef ALPHATEST
	if ( diffuseColor.a < ALPHATEST ) discard;
#endif`,aomap_fragment:`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );
	#endif
#endif`,aomap_pars_fragment:`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,begin_vertex:"vec3 transformed = vec3( position );",beginnormal_vertex:`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,bsdfs:`vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	return vec2( -1.04, 1.04 ) * a004 + r.zw;
}
float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
#if defined ( PHYSICALLY_CORRECT_LIGHTS )
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
#else
	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );
	}
	return 1.0;
#endif
}
vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {
	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );
	return ( 1.0 - specularColor ) * fresnel + specularColor;
}
vec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {
	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );
	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;
	return Fr * fresnel + F0;
}
float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	return 1.0 / ( gl * gv );
}
float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( incidentLight.direction + viewDir );
	float dotNL = saturate( dot( normal, incidentLight.direction ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( G * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
vec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	return specularColor * brdf.x + brdf.y;
}
void BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	vec3 FssEss = F * brdf.x + brdf.y;
	float Ess = brdf.x + brdf.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
}
float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
}
#if defined( USE_SHEEN )
float D_Charlie(float roughness, float NoH) {
	float invAlpha = 1.0 / roughness;
	float cos2h = NoH * NoH;
	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
}
float V_Neubelt(float NoV, float NoL) {
	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));
}
vec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {
	vec3 N = geometry.normal;
	vec3 V = geometry.viewDir;
	vec3 H = normalize( V + L );
	float dotNH = saturate( dot( N, H ) );
	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );
}
#endif`,bumpmap_pars_fragment:`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,clipping_planes_fragment:`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,clipping_planes_pars_fragment:`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,clipping_planes_pars_vertex:`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,clipping_planes_vertex:`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,color_fragment:`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,color_pars_fragment:`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,color_pars_vertex:`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,color_vertex:`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,common:`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract(sin(sn) * c);
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	float distance = dot( planeNormal, point - pointOnPlane );
	return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,cube_uv_reflection_fragment:`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );
		vec2 f = fract( uv );
		uv += 0.5 - f;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		if ( mipInt < cubeUV_maxMipLevel ) {
			uv.y += 2.0 * cubeUV_maxTileSize;
		}
		uv.y += filterInt * 2.0 * cubeUV_minTileSize;
		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );
		uv *= texelSize;
		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x += texelSize;
		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.y += texelSize;
		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x -= texelSize;
		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		vec3 tm = mix( tl, tr, f.x );
		vec3 bm = mix( bl, br, f.x );
		return mix( tm, bm, f.y );
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,defaultnormal_vertex:`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,displacementmap_pars_vertex:`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,displacementmap_vertex:`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,emissivemap_fragment:`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,emissivemap_pars_fragment:`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",encodings_pars_fragment:`
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value ) {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}`,envmap_fragment:`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifndef ENVMAP_TYPE_CUBE_UV
		envColor = envMapTexelToLinear( envColor );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,envmap_common_pars_fragment:`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,envmap_pars_fragment:`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,envmap_pars_vertex:`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,envmap_physical_pars_fragment:`#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {
		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );
			#else
				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
		#else
			vec4 envMapColor = vec4( 0.0 );
		#endif
		return PI * envMapColor.rgb * envMapIntensity;
	}
	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {
		float maxMIPLevelScalar = float( maxMIPLevel );
		float sigma = PI * roughness * roughness / ( 1.0 + roughness );
		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );
		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
	}
	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( -viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
		#else
			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );
		#endif
		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );
			#else
				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
		#endif
		return envMapColor.rgb * envMapIntensity;
	}
#endif`,envmap_vertex:`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,fog_vertex:`#ifdef USE_FOG
	fogDepth = - mvPosition.z;
#endif`,fog_pars_vertex:`#ifdef USE_FOG
	varying float fogDepth;
#endif`,fog_fragment:`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,fog_pars_fragment:`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float fogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,gradientmap_pars_fragment:`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return texture2D( gradientMap, coord ).rgb;
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,lightmap_fragment:`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel= texture2D( lightMap, vUv2 );
	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
#endif`,lightmap_pars_fragment:`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,lights_lambert_vertex:`vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );
		#endif
	}
	#pragma unroll_loop_end
#endif`,lights_pars_begin:`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {
	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	return irradiance;
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		directLight.color = directionalLight.color;
		directLight.direction = directionalLight.direction;
		directLight.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = spotLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		float angleCos = dot( directLight.direction, spotLight.direction );
		if ( angleCos > spotLight.coneCos ) {
			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );
			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;
		} else {
			directLight.color = vec3( 0.0 );
			directLight.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {
		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			irradiance *= PI;
		#endif
		return irradiance;
	}
#endif`,lights_toon_fragment:`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,lights_toon_pars_fragment:`varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,lights_phong_fragment:`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,lights_phong_pars_fragment:`varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,lights_physical_fragment:`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;
material.specularRoughness = min( material.specularRoughness, 1.0 );
#ifdef REFLECTIVITY
	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );
#endif
#ifdef CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheen;
#endif`,lights_physical_pars_fragment:`struct PhysicalMaterial {
	vec3 diffuseColor;
	float specularRoughness;
	vec3 specularColor;
#ifdef CLEARCOAT
	float clearcoat;
	float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	vec3 sheenColor;
#endif
};
#define MAXIMUM_SPECULAR_COEFFICIENT 0.16
#define DEFAULT_SPECULAR_COEFFICIENT 0.04
float clearcoatDHRApprox( const in float roughness, const in float dotNL ) {
	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.specularRoughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(		0, 1,		0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	#ifdef CLEARCOAT
		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = ccDotNL * directLight.color;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			ccIrradiance *= PI;
		#endif
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
	#else
		float clearcoatDHR = 0.0;
	#endif
	#ifdef USE_SHEEN
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(
			material.specularRoughness,
			directLight.direction,
			geometry,
			material.sheenColor
		);
	#else
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);
	#endif
	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef CLEARCOAT
		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
		float ccDotNL = ccDotNV;
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
	#else
		float clearcoatDHR = 0.0;
	#endif
	float clearcoatInv = 1.0 - clearcoatDHR;
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,lights_fragment_begin:`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointDirectLightIrradiance( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotDirectLightIrradiance( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,lights_fragment_maps:`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );
	#ifdef CLEARCOAT
		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );
	#endif
#endif`,lights_fragment_end:`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,logdepthbuf_fragment:`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,logdepthbuf_pars_fragment:`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,logdepthbuf_pars_vertex:`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,logdepthbuf_vertex:`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,map_fragment:`#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`,map_pars_fragment:`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,map_particle_fragment:`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,map_particle_pars_fragment:`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,metalnessmap_fragment:`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,metalnessmap_pars_fragment:`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,morphnormal_vertex:`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
#endif`,morphtarget_pars_vertex:`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifndef USE_MORPHNORMALS
		uniform float morphTargetInfluences[ 8 ];
	#else
		uniform float morphTargetInfluences[ 4 ];
	#endif
#endif`,morphtarget_vertex:`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	transformed += morphTarget0 * morphTargetInfluences[ 0 ];
	transformed += morphTarget1 * morphTargetInfluences[ 1 ];
	transformed += morphTarget2 * morphTargetInfluences[ 2 ];
	transformed += morphTarget3 * morphTargetInfluences[ 3 ];
	#ifndef USE_MORPHNORMALS
		transformed += morphTarget4 * morphTargetInfluences[ 4 ];
		transformed += morphTarget5 * morphTargetInfluences[ 5 ];
		transformed += morphTarget6 * morphTargetInfluences[ 6 ];
		transformed += morphTarget7 * morphTargetInfluences[ 7 ];
	#endif
#endif`,normal_fragment_begin:`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,normal_fragment_maps:`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,normalmap_pars_fragment:`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,clearcoat_normal_fragment_begin:`#ifdef CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,clearcoat_normal_fragment_maps:`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,clearcoat_pars_fragment:`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,packing:`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,premultiplied_alpha_fragment:`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,project_vertex:`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,dithering_fragment:`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,dithering_pars_fragment:`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,roughnessmap_fragment:`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,roughnessmap_pars_fragment:`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,shadowmap_pars_fragment:`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
							texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
							f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
							texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
							f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,shadowmap_pars_vertex:`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,shadowmap_vertex:`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,shadowmask_pars_fragment:`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,skinbase_vertex:`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,skinning_pars_vertex:`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`,skinning_vertex:`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,skinnormal_vertex:`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,specularmap_fragment:`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,specularmap_pars_fragment:`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,tonemapping_fragment:`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,tonemapping_pars_fragment:`#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(	1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,	1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,	1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,transmissionmap_fragment:`#ifdef USE_TRANSMISSIONMAP
	totalTransmission *= texture2D( transmissionMap, vUv ).r;
#endif`,transmissionmap_pars_fragment:`#ifdef USE_TRANSMISSIONMAP
	uniform sampler2D transmissionMap;
#endif`,uv_pars_fragment:`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,uv_pars_vertex:`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,uv_vertex:`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,uv2_pars_fragment:`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,uv2_pars_vertex:`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,uv2_vertex:`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,worldpos_vertex:`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,background_frag:`uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,background_vert:`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,cube_frag:`#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,cube_vert:`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,depth_frag:`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,depth_vert:`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,distanceRGBA_frag:`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,distanceRGBA_vert:`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,equirect_frag:`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,equirect_vert:`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,linedashed_frag:`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,linedashed_vert:`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,meshbasic_frag:`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
	
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshbasic_vert:`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <skinbase_vertex>
	#ifdef USE_ENVMAP
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,meshlambert_frag:`uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshlambert_vert:`#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,meshmatcap_frag:`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshmatcap_vert:`#define MATCAP
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#ifndef FLAT_SHADED
		vNormal = normalize( transformedNormal );
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,meshtoon_frag:`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshtoon_vert:`#define TOON
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,meshphong_frag:`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshphong_vert:`#define PHONG
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,meshphysical_frag:`#define STANDARD
#ifdef PHYSICAL
	#define REFLECTIVITY
	#define CLEARCOAT
	#define TRANSMISSION
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef TRANSMISSION
	uniform float transmission;
#endif
#ifdef REFLECTIVITY
	uniform float reflectivity;
#endif
#ifdef CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheen;
#endif
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <transmissionmap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#ifdef TRANSMISSION
		float totalTransmission = transmission;
	#endif
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <transmissionmap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#ifdef TRANSMISSION
		diffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );
	#endif
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshphysical_vert:`#define STANDARD
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,normal_frag:`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <packing>
#include <uv_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`,normal_vert:`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,points_frag:`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,points_vert:`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,shadow_frag:`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,shadow_vert:`#include <common>
#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,sprite_frag:`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,sprite_vert:`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`},Be={common:{diffuse:{value:new Ge(15658734)},opacity:{value:1},map:{value:null},uvTransform:{value:new St},uv2Transform:{value:new St},alphaMap:{value:null}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new Ee(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Ge(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Ge(15658734)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},uvTransform:{value:new St}},sprite:{diffuse:{value:new Ge(15658734)},opacity:{value:1},center:{value:new Ee(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},uvTransform:{value:new St}}},pr={basic:{uniforms:Tn([Be.common,Be.specularmap,Be.envmap,Be.aomap,Be.lightmap,Be.fog]),vertexShader:_t.meshbasic_vert,fragmentShader:_t.meshbasic_frag},lambert:{uniforms:Tn([Be.common,Be.specularmap,Be.envmap,Be.aomap,Be.lightmap,Be.emissivemap,Be.fog,Be.lights,{emissive:{value:new Ge(0)}}]),vertexShader:_t.meshlambert_vert,fragmentShader:_t.meshlambert_frag},phong:{uniforms:Tn([Be.common,Be.specularmap,Be.envmap,Be.aomap,Be.lightmap,Be.emissivemap,Be.bumpmap,Be.normalmap,Be.displacementmap,Be.fog,Be.lights,{emissive:{value:new Ge(0)},specular:{value:new Ge(1118481)},shininess:{value:30}}]),vertexShader:_t.meshphong_vert,fragmentShader:_t.meshphong_frag},standard:{uniforms:Tn([Be.common,Be.envmap,Be.aomap,Be.lightmap,Be.emissivemap,Be.bumpmap,Be.normalmap,Be.displacementmap,Be.roughnessmap,Be.metalnessmap,Be.fog,Be.lights,{emissive:{value:new Ge(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:_t.meshphysical_vert,fragmentShader:_t.meshphysical_frag},toon:{uniforms:Tn([Be.common,Be.aomap,Be.lightmap,Be.emissivemap,Be.bumpmap,Be.normalmap,Be.displacementmap,Be.gradientmap,Be.fog,Be.lights,{emissive:{value:new Ge(0)}}]),vertexShader:_t.meshtoon_vert,fragmentShader:_t.meshtoon_frag},matcap:{uniforms:Tn([Be.common,Be.bumpmap,Be.normalmap,Be.displacementmap,Be.fog,{matcap:{value:null}}]),vertexShader:_t.meshmatcap_vert,fragmentShader:_t.meshmatcap_frag},points:{uniforms:Tn([Be.points,Be.fog]),vertexShader:_t.points_vert,fragmentShader:_t.points_frag},dashed:{uniforms:Tn([Be.common,Be.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:_t.linedashed_vert,fragmentShader:_t.linedashed_frag},depth:{uniforms:Tn([Be.common,Be.displacementmap]),vertexShader:_t.depth_vert,fragmentShader:_t.depth_frag},normal:{uniforms:Tn([Be.common,Be.bumpmap,Be.normalmap,Be.displacementmap,{opacity:{value:1}}]),vertexShader:_t.normal_vert,fragmentShader:_t.normal_frag},sprite:{uniforms:Tn([Be.sprite,Be.fog]),vertexShader:_t.sprite_vert,fragmentShader:_t.sprite_frag},background:{uniforms:{uvTransform:{value:new St},t2D:{value:null}},vertexShader:_t.background_vert,fragmentShader:_t.background_frag},cube:{uniforms:Tn([Be.envmap,{opacity:{value:1}}]),vertexShader:_t.cube_vert,fragmentShader:_t.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:_t.equirect_vert,fragmentShader:_t.equirect_frag},distanceRGBA:{uniforms:Tn([Be.common,Be.displacementmap,{referencePosition:{value:new O},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:_t.distanceRGBA_vert,fragmentShader:_t.distanceRGBA_frag},shadow:{uniforms:Tn([Be.lights,Be.fog,{color:{value:new Ge(0)},opacity:{value:1}}]),vertexShader:_t.shadow_vert,fragmentShader:_t.shadow_frag}};function Qy(o,e,t,r,i){const a=new Ge(0);let c,u,h=0,p=null,m=0,g=null;function y(x,b){t.buffers.color.setClear(x.r,x.g,x.b,b,i)}return{getClearColor:function(){return a},setClearColor:function(x,b=1){a.set(x),h=b,y(a,h)},getClearAlpha:function(){return h},setClearAlpha:function(x){h=x,y(a,h)},render:function(x,b,S,M){let A=b.isScene===!0?b.background:null;A&&A.isTexture&&(A=e.get(A));const I=o.xr,k=I.getSession&&I.getSession();k&&k.environmentBlendMode==="additive"&&(A=null),A===null?y(a,h):A&&A.isColor&&(y(A,1),M=!0),(o.autoClear||M)&&o.clear(o.autoClearColor,o.autoClearDepth,o.autoClearStencil),A&&(A.isCubeTexture||A.mapping===306)?(u===void 0&&(u=new sn(new zi(1,1,1),new Kr({name:"BackgroundCubeMaterial",uniforms:Cs(pr.cube.uniforms),vertexShader:pr.cube.vertexShader,fragmentShader:pr.cube.fragmentShader,side:1,depthTest:!1,depthWrite:!1,fog:!1})),u.geometry.deleteAttribute("normal"),u.geometry.deleteAttribute("uv"),u.onBeforeRender=function(N,G,U){this.matrixWorld.copyPosition(U.matrixWorld)},Object.defineProperty(u.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),r.update(u)),u.material.uniforms.envMap.value=A,u.material.uniforms.flipEnvMap.value=A.isCubeTexture&&A._needsFlipEnvMap?-1:1,p===A&&m===A.version&&g===o.toneMapping||(u.material.needsUpdate=!0,p=A,m=A.version,g=o.toneMapping),x.unshift(u,u.geometry,u.material,0,0,null)):A&&A.isTexture&&(c===void 0&&(c=new sn(new go(2,2),new Kr({name:"BackgroundMaterial",uniforms:Cs(pr.background.uniforms),vertexShader:pr.background.vertexShader,fragmentShader:pr.background.fragmentShader,side:0,depthTest:!1,depthWrite:!1,fog:!1})),c.geometry.deleteAttribute("normal"),Object.defineProperty(c.material,"map",{get:function(){return this.uniforms.t2D.value}}),r.update(c)),c.material.uniforms.t2D.value=A,A.matrixAutoUpdate===!0&&A.updateMatrix(),c.material.uniforms.uvTransform.value.copy(A.matrix),p===A&&m===A.version&&g===o.toneMapping||(c.material.needsUpdate=!0,p=A,m=A.version,g=o.toneMapping),x.unshift(c,c.geometry,c.material,0,0,null))}}}function e0(o,e,t,r){const i=o.getParameter(34921),a=r.isWebGL2?null:e.get("OES_vertex_array_object"),c=r.isWebGL2||a!==null,u={},h=y(null);let p=h;function m(N){return r.isWebGL2?o.bindVertexArray(N):a.bindVertexArrayOES(N)}function g(N){return r.isWebGL2?o.deleteVertexArray(N):a.deleteVertexArrayOES(N)}function y(N){const G=[],U=[],B=[];for(let V=0;V<i;V++)G[V]=0,U[V]=0,B[V]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:G,enabledAttributes:U,attributeDivisors:B,object:N,attributes:{},index:null}}function x(){const N=p.newAttributes;for(let G=0,U=N.length;G<U;G++)N[G]=0}function b(N){S(N,0)}function S(N,G){const U=p.newAttributes,B=p.enabledAttributes,V=p.attributeDivisors;U[N]=1,B[N]===0&&(o.enableVertexAttribArray(N),B[N]=1),V[N]!==G&&((r.isWebGL2?o:e.get("ANGLE_instanced_arrays"))[r.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](N,G),V[N]=G)}function M(){const N=p.newAttributes,G=p.enabledAttributes;for(let U=0,B=G.length;U<B;U++)G[U]!==N[U]&&(o.disableVertexAttribArray(U),G[U]=0)}function A(N,G,U,B,V,he){r.isWebGL2!==!0||U!==5124&&U!==5125?o.vertexAttribPointer(N,G,U,B,V,he):o.vertexAttribIPointer(N,G,U,V,he)}function I(){k(),p!==h&&(p=h,m(p.object))}function k(){h.geometry=null,h.program=null,h.wireframe=!1}return{setup:function(N,G,U,B,V){let he=!1;if(c){const Z=function(J,re,ee){const le=ee.wireframe===!0;let Ce=u[J.id];Ce===void 0&&(Ce={},u[J.id]=Ce);let Pe=Ce[re.id];Pe===void 0&&(Pe={},Ce[re.id]=Pe);let We=Pe[le];return We===void 0&&(We=y(r.isWebGL2?o.createVertexArray():a.createVertexArrayOES()),Pe[le]=We),We}(B,U,G);p!==Z&&(p=Z,m(p.object)),he=function(J,re){const ee=p.attributes,le=J.attributes;let Ce=0;for(const Pe in le){const We=ee[Pe],Oe=le[Pe];if(We===void 0||We.attribute!==Oe||We.data!==Oe.data)return!0;Ce++}return p.attributesNum!==Ce||p.index!==re}(B,V),he&&function(J,re){const ee={},le=J.attributes;let Ce=0;for(const Pe in le){const We=le[Pe],Oe={};Oe.attribute=We,We.data&&(Oe.data=We.data),ee[Pe]=Oe,Ce++}p.attributes=ee,p.attributesNum=Ce,p.index=re}(B,V)}else{const Z=G.wireframe===!0;p.geometry===B.id&&p.program===U.id&&p.wireframe===Z||(p.geometry=B.id,p.program=U.id,p.wireframe=Z,he=!0)}N.isInstancedMesh===!0&&(he=!0),V!==null&&t.update(V,34963),he&&(function(Z,J,re,ee){if(r.isWebGL2===!1&&(Z.isInstancedMesh||ee.isInstancedBufferGeometry)&&e.get("ANGLE_instanced_arrays")===null)return;x();const le=ee.attributes,Ce=re.getAttributes(),Pe=J.defaultAttributeValues;for(const We in Ce){const Oe=Ce[We];if(Oe>=0){const De=le[We];if(De!==void 0){const ze=De.normalized,st=De.itemSize,q=t.get(De);if(q===void 0)continue;const Y=q.buffer,fe=q.type,de=q.bytesPerElement;if(De.isInterleavedBufferAttribute){const oe=De.data,Ve=oe.stride,W=De.offset;oe&&oe.isInstancedInterleavedBuffer?(S(Oe,oe.meshPerAttribute),ee._maxInstanceCount===void 0&&(ee._maxInstanceCount=oe.meshPerAttribute*oe.count)):b(Oe),o.bindBuffer(34962,Y),A(Oe,st,fe,ze,Ve*de,W*de)}else De.isInstancedBufferAttribute?(S(Oe,De.meshPerAttribute),ee._maxInstanceCount===void 0&&(ee._maxInstanceCount=De.meshPerAttribute*De.count)):b(Oe),o.bindBuffer(34962,Y),A(Oe,st,fe,ze,0,0)}else if(We==="instanceMatrix"){const ze=t.get(Z.instanceMatrix);if(ze===void 0)continue;const st=ze.buffer,q=ze.type;S(Oe+0,1),S(Oe+1,1),S(Oe+2,1),S(Oe+3,1),o.bindBuffer(34962,st),o.vertexAttribPointer(Oe+0,4,q,!1,64,0),o.vertexAttribPointer(Oe+1,4,q,!1,64,16),o.vertexAttribPointer(Oe+2,4,q,!1,64,32),o.vertexAttribPointer(Oe+3,4,q,!1,64,48)}else if(We==="instanceColor"){const ze=t.get(Z.instanceColor);if(ze===void 0)continue;const st=ze.buffer,q=ze.type;S(Oe,1),o.bindBuffer(34962,st),o.vertexAttribPointer(Oe,3,q,!1,12,0)}else if(Pe!==void 0){const ze=Pe[We];if(ze!==void 0)switch(ze.length){case 2:o.vertexAttrib2fv(Oe,ze);break;case 3:o.vertexAttrib3fv(Oe,ze);break;case 4:o.vertexAttrib4fv(Oe,ze);break;default:o.vertexAttrib1fv(Oe,ze)}}}}M()}(N,G,U,B),V!==null&&o.bindBuffer(34963,t.get(V).buffer))},reset:I,resetDefaultState:k,dispose:function(){I();for(const N in u){const G=u[N];for(const U in G){const B=G[U];for(const V in B)g(B[V].object),delete B[V];delete G[U]}delete u[N]}},releaseStatesOfGeometry:function(N){if(u[N.id]===void 0)return;const G=u[N.id];for(const U in G){const B=G[U];for(const V in B)g(B[V].object),delete B[V];delete G[U]}delete u[N.id]},releaseStatesOfProgram:function(N){for(const G in u){const U=u[G];if(U[N.id]===void 0)continue;const B=U[N.id];for(const V in B)g(B[V].object),delete B[V];delete U[N.id]}},initAttributes:x,enableAttribute:b,disableUnusedAttributes:M}}function t0(o,e,t,r){const i=r.isWebGL2;let a;this.setMode=function(c){a=c},this.render=function(c,u){o.drawArrays(a,c,u),t.update(u,a,1)},this.renderInstances=function(c,u,h){if(h===0)return;let p,m;if(i)p=o,m="drawArraysInstanced";else if(p=e.get("ANGLE_instanced_arrays"),m="drawArraysInstancedANGLE",p===null)return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");p[m](a,c,u,h),t.update(u,a,h)}}function n0(o,e,t){let r;function i(k){if(k==="highp"){if(o.getShaderPrecisionFormat(35633,36338).precision>0&&o.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";k="mediump"}return k==="mediump"&&o.getShaderPrecisionFormat(35633,36337).precision>0&&o.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const a=typeof WebGL2RenderingContext<"u"&&o instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext<"u"&&o instanceof WebGL2ComputeRenderingContext;let c=t.precision!==void 0?t.precision:"highp";const u=i(c);u!==c&&(console.warn("THREE.WebGLRenderer:",c,"not supported, using",u,"instead."),c=u);const h=t.logarithmicDepthBuffer===!0,p=o.getParameter(34930),m=o.getParameter(35660),g=o.getParameter(3379),y=o.getParameter(34076),x=o.getParameter(34921),b=o.getParameter(36347),S=o.getParameter(36348),M=o.getParameter(36349),A=m>0,I=a||e.has("OES_texture_float");return{isWebGL2:a,getMaxAnisotropy:function(){if(r!==void 0)return r;if(e.has("EXT_texture_filter_anisotropic")===!0){const k=e.get("EXT_texture_filter_anisotropic");r=o.getParameter(k.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else r=0;return r},getMaxPrecision:i,precision:c,logarithmicDepthBuffer:h,maxTextures:p,maxVertexTextures:m,maxTextureSize:g,maxCubemapSize:y,maxAttributes:x,maxVertexUniforms:b,maxVaryings:S,maxFragmentUniforms:M,vertexTextures:A,floatFragmentTextures:I,floatVertexTextures:A&&I,maxSamples:a?o.getParameter(36183):0}}function r0(o){const e=this;let t=null,r=0,i=!1,a=!1;const c=new ur,u=new St,h={value:null,needsUpdate:!1};function p(){h.value!==t&&(h.value=t,h.needsUpdate=r>0),e.numPlanes=r,e.numIntersection=0}function m(g,y,x,b){const S=g!==null?g.length:0;let M=null;if(S!==0){if(M=h.value,b!==!0||M===null){const A=x+4*S,I=y.matrixWorldInverse;u.getNormalMatrix(I),(M===null||M.length<A)&&(M=new Float32Array(A));for(let k=0,N=x;k!==S;++k,N+=4)c.copy(g[k]).applyMatrix4(I,u),c.normal.toArray(M,N),M[N+3]=c.constant}h.value=M,h.needsUpdate=!0}return e.numPlanes=S,e.numIntersection=0,M}this.uniform=h,this.numPlanes=0,this.numIntersection=0,this.init=function(g,y,x){const b=g.length!==0||y||r!==0||i;return i=y,t=m(g,x,0),r=g.length,b},this.beginShadows=function(){a=!0,m(null)},this.endShadows=function(){a=!1,p()},this.setState=function(g,y,x){const b=g.clippingPlanes,S=g.clipIntersection,M=g.clipShadows,A=o.get(g);if(!i||b===null||b.length===0||a&&!M)a?m(null):p();else{const I=a?0:r,k=4*I;let N=A.clippingState||null;h.value=N,N=m(b,y,k,x);for(let G=0;G!==k;++G)N[G]=t[G];A.clippingState=N,this.numIntersection=S?this.numPlanes:0,this.numPlanes+=I}}}function i0(o){let e=new WeakMap;function t(i,a){return a===303?i.mapping=301:a===304&&(i.mapping=302),i}function r(i){const a=i.target;a.removeEventListener("dispose",r);const c=e.get(a);c!==void 0&&(e.delete(a),c.dispose())}return{get:function(i){if(i&&i.isTexture){const a=i.mapping;if(a===303||a===304){if(e.has(i))return t(e.get(i).texture,i.mapping);{const c=i.image;if(c&&c.height>0){const u=o.getRenderTarget(),h=new Ya(c.height/2);return h.fromEquirectangularTexture(o,i),e.set(i,h),o.setRenderTarget(u),i.addEventListener("dispose",r),t(h.texture,i.mapping)}return null}}}return i},dispose:function(){e=new WeakMap}}}function s0(o){const e={};function t(r){if(e[r]!==void 0)return e[r];let i;switch(r){case"WEBGL_depth_texture":i=o.getExtension("WEBGL_depth_texture")||o.getExtension("MOZ_WEBGL_depth_texture")||o.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=o.getExtension("EXT_texture_filter_anisotropic")||o.getExtension("MOZ_EXT_texture_filter_anisotropic")||o.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=o.getExtension("WEBGL_compressed_texture_s3tc")||o.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||o.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=o.getExtension("WEBGL_compressed_texture_pvrtc")||o.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=o.getExtension(r)}return e[r]=i,i}return{has:function(r){return t(r)!==null},init:function(r){r.isWebGL2?t("EXT_color_buffer_float"):(t("WEBGL_depth_texture"),t("OES_texture_float"),t("OES_texture_half_float"),t("OES_texture_half_float_linear"),t("OES_standard_derivatives"),t("OES_element_index_uint"),t("OES_vertex_array_object"),t("ANGLE_instanced_arrays")),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float")},get:function(r){const i=t(r);return i===null&&console.warn("THREE.WebGLRenderer: "+r+" extension not supported."),i}}}function o0(o,e,t,r){const i={},a=new WeakMap;function c(h){const p=h.target;p.index!==null&&e.remove(p.index);for(const g in p.attributes)e.remove(p.attributes[g]);p.removeEventListener("dispose",c),delete i[p.id];const m=a.get(p);m&&(e.remove(m),a.delete(p)),r.releaseStatesOfGeometry(p),p.isInstancedBufferGeometry===!0&&delete p._maxInstanceCount,t.memory.geometries--}function u(h){const p=[],m=h.index,g=h.attributes.position;let y=0;if(m!==null){const S=m.array;y=m.version;for(let M=0,A=S.length;M<A;M+=3){const I=S[M+0],k=S[M+1],N=S[M+2];p.push(I,k,k,N,N,I)}}else{const S=g.array;y=g.version;for(let M=0,A=S.length/3-1;M<A;M+=3){const I=M+0,k=M+1,N=M+2;p.push(I,k,k,N,N,I)}}const x=new(cp(p)>65535?Fa:Ha)(p,1);x.version=y;const b=a.get(h);b&&e.remove(b),a.set(h,x)}return{get:function(h,p){return i[p.id]===!0||(p.addEventListener("dispose",c),i[p.id]=!0,t.memory.geometries++),p},update:function(h){const p=h.attributes;for(const g in p)e.update(p[g],34962);const m=h.morphAttributes;for(const g in m){const y=m[g];for(let x=0,b=y.length;x<b;x++)e.update(y[x],34962)}},getWireframeAttribute:function(h){const p=a.get(h);if(p){const m=h.index;m!==null&&p.version<m.version&&u(h)}else u(h);return a.get(h)}}}function a0(o,e,t,r){const i=r.isWebGL2;let a,c,u;this.setMode=function(h){a=h},this.setIndex=function(h){c=h.type,u=h.bytesPerElement},this.render=function(h,p){o.drawElements(a,p,c,h*u),t.update(p,a,1)},this.renderInstances=function(h,p,m){if(m===0)return;let g,y;if(i)g=o,y="drawElementsInstanced";else if(g=e.get("ANGLE_instanced_arrays"),y="drawElementsInstancedANGLE",g===null)return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");g[y](a,p,c,h*u,m),t.update(p,a,m)}}function l0(o){const e={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:e,programs:null,autoReset:!0,reset:function(){e.frame++,e.calls=0,e.triangles=0,e.points=0,e.lines=0},update:function(t,r,i){switch(e.calls++,r){case 4:e.triangles+=i*(t/3);break;case 1:e.lines+=i*(t/2);break;case 3:e.lines+=i*(t-1);break;case 2:e.lines+=i*t;break;case 0:e.points+=i*t;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",r)}}}}function c0(o,e){return o[0]-e[0]}function u0(o,e){return Math.abs(e[1])-Math.abs(o[1])}function h0(o){const e={},t=new Float32Array(8),r=[];for(let i=0;i<8;i++)r[i]=[i,0];return{update:function(i,a,c,u){const h=i.morphTargetInfluences,p=h===void 0?0:h.length;let m=e[a.id];if(m===void 0){m=[];for(let S=0;S<p;S++)m[S]=[S,0];e[a.id]=m}for(let S=0;S<p;S++){const M=m[S];M[0]=S,M[1]=h[S]}m.sort(u0);for(let S=0;S<8;S++)S<p&&m[S][1]?(r[S][0]=m[S][0],r[S][1]=m[S][1]):(r[S][0]=Number.MAX_SAFE_INTEGER,r[S][1]=0);r.sort(c0);const g=c.morphTargets&&a.morphAttributes.position,y=c.morphNormals&&a.morphAttributes.normal;let x=0;for(let S=0;S<8;S++){const M=r[S],A=M[0],I=M[1];A!==Number.MAX_SAFE_INTEGER&&I?(g&&a.getAttribute("morphTarget"+S)!==g[A]&&a.setAttribute("morphTarget"+S,g[A]),y&&a.getAttribute("morphNormal"+S)!==y[A]&&a.setAttribute("morphNormal"+S,y[A]),t[S]=I,x+=I):(g&&a.hasAttribute("morphTarget"+S)===!0&&a.deleteAttribute("morphTarget"+S),y&&a.hasAttribute("morphNormal"+S)===!0&&a.deleteAttribute("morphNormal"+S),t[S]=0)}const b=a.morphTargetsRelative?1:1-x;u.getUniforms().setValue(o,"morphTargetBaseInfluence",b),u.getUniforms().setValue(o,"morphTargetInfluences",t)}}}function d0(o,e,t,r){let i=new WeakMap;function a(c){const u=c.target;u.removeEventListener("dispose",a),t.remove(u.instanceMatrix),u.instanceColor!==null&&t.remove(u.instanceColor)}return{update:function(c){const u=r.render.frame,h=c.geometry,p=e.get(c,h);return i.get(p)!==u&&(e.update(p),i.set(p,u)),c.isInstancedMesh&&(c.hasEventListener("dispose",a)===!1&&c.addEventListener("dispose",a),t.update(c.instanceMatrix,34962),c.instanceColor!==null&&t.update(c.instanceColor,34962)),p},dispose:function(){i=new WeakMap}}}pr.physical={uniforms:Tn([pr.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new Ee(1,1)},clearcoatNormalMap:{value:null},sheen:{value:new Ge(0)},transmission:{value:0},transmissionMap:{value:null}}]),vertexShader:_t.meshphysical_vert,fragmentShader:_t.meshphysical_frag};class uu extends un{constructor(e=null,t=1,r=1,i=1){super(null),this.image={data:e,width:t,height:r,depth:i},this.magFilter=1003,this.minFilter=1003,this.wrapR=1001,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}uu.prototype.isDataTexture2DArray=!0;class hu extends un{constructor(e=null,t=1,r=1,i=1){super(null),this.image={data:e,width:t,height:r,depth:i},this.magFilter=1003,this.minFilter=1003,this.wrapR=1001,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}hu.prototype.isDataTexture3D=!0;const pp=new un,p0=new uu,f0=new hu,fp=new Is,mp=[],gp=[],vp=new Float32Array(16),yp=new Float32Array(9),xp=new Float32Array(4);function Ns(o,e,t){const r=o[0];if(r<=0||r>0)return o;const i=e*t;let a=mp[i];if(a===void 0&&(a=new Float32Array(i),mp[i]=a),e!==0){r.toArray(a,0);for(let c=1,u=0;c!==e;++c)u+=t,o[c].toArray(a,u)}return a}function Dn(o,e){if(o.length!==e.length)return!1;for(let t=0,r=o.length;t<r;t++)if(o[t]!==e[t])return!1;return!0}function An(o,e){for(let t=0,r=e.length;t<r;t++)o[t]=e[t]}function _p(o,e){let t=gp[e];t===void 0&&(t=new Int32Array(e),gp[e]=t);for(let r=0;r!==e;++r)t[r]=o.allocateTextureUnit();return t}function m0(o,e){const t=this.cache;t[0]!==e&&(o.uniform1f(this.addr,e),t[0]=e)}function g0(o,e){const t=this.cache;if(e.x!==void 0)t[0]===e.x&&t[1]===e.y||(o.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Dn(t,e))return;o.uniform2fv(this.addr,e),An(t,e)}}function v0(o,e){const t=this.cache;if(e.x!==void 0)t[0]===e.x&&t[1]===e.y&&t[2]===e.z||(o.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)t[0]===e.r&&t[1]===e.g&&t[2]===e.b||(o.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(Dn(t,e))return;o.uniform3fv(this.addr,e),An(t,e)}}function y0(o,e){const t=this.cache;if(e.x!==void 0)t[0]===e.x&&t[1]===e.y&&t[2]===e.z&&t[3]===e.w||(o.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Dn(t,e))return;o.uniform4fv(this.addr,e),An(t,e)}}function x0(o,e){const t=this.cache,r=e.elements;if(r===void 0){if(Dn(t,e))return;o.uniformMatrix2fv(this.addr,!1,e),An(t,e)}else{if(Dn(t,r))return;xp.set(r),o.uniformMatrix2fv(this.addr,!1,xp),An(t,r)}}function _0(o,e){const t=this.cache,r=e.elements;if(r===void 0){if(Dn(t,e))return;o.uniformMatrix3fv(this.addr,!1,e),An(t,e)}else{if(Dn(t,r))return;yp.set(r),o.uniformMatrix3fv(this.addr,!1,yp),An(t,r)}}function b0(o,e){const t=this.cache,r=e.elements;if(r===void 0){if(Dn(t,e))return;o.uniformMatrix4fv(this.addr,!1,e),An(t,e)}else{if(Dn(t,r))return;vp.set(r),o.uniformMatrix4fv(this.addr,!1,vp),An(t,r)}}function w0(o,e){const t=this.cache;t[0]!==e&&(o.uniform1i(this.addr,e),t[0]=e)}function M0(o,e){const t=this.cache;Dn(t,e)||(o.uniform2iv(this.addr,e),An(t,e))}function S0(o,e){const t=this.cache;Dn(t,e)||(o.uniform3iv(this.addr,e),An(t,e))}function E0(o,e){const t=this.cache;Dn(t,e)||(o.uniform4iv(this.addr,e),An(t,e))}function T0(o,e){const t=this.cache;t[0]!==e&&(o.uniform1ui(this.addr,e),t[0]=e)}function A0(o,e){const t=this.cache;Dn(t,e)||(o.uniform2uiv(this.addr,e),An(t,e))}function R0(o,e){const t=this.cache;Dn(t,e)||(o.uniform3uiv(this.addr,e),An(t,e))}function L0(o,e){const t=this.cache;Dn(t,e)||(o.uniform4uiv(this.addr,e),An(t,e))}function C0(o,e,t){const r=this.cache,i=t.allocateTextureUnit();r[0]!==i&&(o.uniform1i(this.addr,i),r[0]=i),t.safeSetTexture2D(e||pp,i)}function P0(o,e,t){const r=this.cache,i=t.allocateTextureUnit();r[0]!==i&&(o.uniform1i(this.addr,i),r[0]=i),t.setTexture3D(e||f0,i)}function I0(o,e,t){const r=this.cache,i=t.allocateTextureUnit();r[0]!==i&&(o.uniform1i(this.addr,i),r[0]=i),t.safeSetTextureCube(e||fp,i)}function O0(o,e,t){const r=this.cache,i=t.allocateTextureUnit();r[0]!==i&&(o.uniform1i(this.addr,i),r[0]=i),t.setTexture2DArray(e||p0,i)}function D0(o,e){o.uniform1fv(this.addr,e)}function N0(o,e){const t=Ns(e,this.size,2);o.uniform2fv(this.addr,t)}function k0(o,e){const t=Ns(e,this.size,3);o.uniform3fv(this.addr,t)}function H0(o,e){const t=Ns(e,this.size,4);o.uniform4fv(this.addr,t)}function F0(o,e){const t=Ns(e,this.size,4);o.uniformMatrix2fv(this.addr,!1,t)}function B0(o,e){const t=Ns(e,this.size,9);o.uniformMatrix3fv(this.addr,!1,t)}function z0(o,e){const t=Ns(e,this.size,16);o.uniformMatrix4fv(this.addr,!1,t)}function U0(o,e){o.uniform1iv(this.addr,e)}function G0(o,e){o.uniform2iv(this.addr,e)}function V0(o,e){o.uniform3iv(this.addr,e)}function W0(o,e){o.uniform4iv(this.addr,e)}function j0(o,e){o.uniform1uiv(this.addr,e)}function q0(o,e){o.uniform2uiv(this.addr,e)}function X0(o,e){o.uniform3uiv(this.addr,e)}function Y0(o,e){o.uniform4uiv(this.addr,e)}function Z0(o,e,t){const r=e.length,i=_p(t,r);o.uniform1iv(this.addr,i);for(let a=0;a!==r;++a)t.safeSetTexture2D(e[a]||pp,i[a])}function K0(o,e,t){const r=e.length,i=_p(t,r);o.uniform1iv(this.addr,i);for(let a=0;a!==r;++a)t.safeSetTextureCube(e[a]||fp,i[a])}function $0(o,e,t){this.id=o,this.addr=t,this.cache=[],this.setValue=function(r){switch(r){case 5126:return m0;case 35664:return g0;case 35665:return v0;case 35666:return y0;case 35674:return x0;case 35675:return _0;case 35676:return b0;case 5124:case 35670:return w0;case 35667:case 35671:return M0;case 35668:case 35672:return S0;case 35669:case 35673:return E0;case 5125:return T0;case 36294:return A0;case 36295:return R0;case 36296:return L0;case 35678:case 36198:case 36298:case 36306:case 35682:return C0;case 35679:case 36299:case 36307:return P0;case 35680:case 36300:case 36308:case 36293:return I0;case 36289:case 36303:case 36311:case 36292:return O0}}(e.type)}function bp(o,e,t){this.id=o,this.addr=t,this.cache=[],this.size=e.size,this.setValue=function(r){switch(r){case 5126:return D0;case 35664:return N0;case 35665:return k0;case 35666:return H0;case 35674:return F0;case 35675:return B0;case 35676:return z0;case 5124:case 35670:return U0;case 35667:case 35671:return G0;case 35668:case 35672:return V0;case 35669:case 35673:return W0;case 5125:return j0;case 36294:return q0;case 36295:return X0;case 36296:return Y0;case 35678:case 36198:case 36298:case 36306:case 35682:return Z0;case 35680:case 36300:case 36308:case 36293:return K0}}(e.type)}function wp(o){this.id=o,this.seq=[],this.map={}}bp.prototype.updateCache=function(o){const e=this.cache;o instanceof Float32Array&&e.length!==o.length&&(this.cache=new Float32Array(o.length)),An(e,o)},wp.prototype.setValue=function(o,e,t){const r=this.seq;for(let i=0,a=r.length;i!==a;++i){const c=r[i];c.setValue(o,e[c.id],t)}};const du=/(\w+)(\])?(\[|\.)?/g;function Mp(o,e){o.seq.push(e),o.map[e.id]=e}function J0(o,e,t){const r=o.name,i=r.length;for(du.lastIndex=0;;){const a=du.exec(r),c=du.lastIndex;let u=a[1];const h=a[2]==="]",p=a[3];if(h&&(u|=0),p===void 0||p==="["&&c+2===i){Mp(t,p===void 0?new $0(u,o,e):new bp(u,o,e));break}{let m=t.map[u];m===void 0&&(m=new wp(u),Mp(t,m)),t=m}}}function bi(o,e){this.seq=[],this.map={};const t=o.getProgramParameter(e,35718);for(let r=0;r<t;++r){const i=o.getActiveUniform(e,r);J0(i,o.getUniformLocation(e,i.name),this)}}function Sp(o,e,t){const r=o.createShader(e);return o.shaderSource(r,t),o.compileShader(r),r}bi.prototype.setValue=function(o,e,t,r){const i=this.map[e];i!==void 0&&i.setValue(o,t,r)},bi.prototype.setOptional=function(o,e,t){const r=e[t];r!==void 0&&this.setValue(o,t,r)},bi.upload=function(o,e,t,r){for(let i=0,a=e.length;i!==a;++i){const c=e[i],u=t[c.id];u.needsUpdate!==!1&&c.setValue(o,u.value,r)}},bi.seqWithValue=function(o,e){const t=[];for(let r=0,i=o.length;r!==i;++r){const a=o[r];a.id in e&&t.push(a)}return t};let Q0=0;function Ep(o){switch(o){case 3e3:return["Linear","( value )"];case 3001:return["sRGB","( value )"];case 3002:return["RGBE","( value )"];case 3004:return["RGBM","( value, 7.0 )"];case 3005:return["RGBM","( value, 16.0 )"];case 3006:return["RGBD","( value, 256.0 )"];case 3007:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case 3003:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",o),["Linear","( value )"]}}function Tp(o,e,t){const r=o.getShaderParameter(e,35713),i=o.getShaderInfoLog(e).trim();return r&&i===""?"":"THREE.WebGLShader: gl.getShaderInfoLog() "+t+`
`+i+function(a){const c=a.split(`
`);for(let u=0;u<c.length;u++)c[u]=u+1+": "+c[u];return c.join(`
`)}(o.getShaderSource(e))}function vo(o,e){const t=Ep(e);return"vec4 "+o+"( vec4 value ) { return "+t[0]+"ToLinear"+t[1]+"; }"}function ex(o,e){const t=Ep(e);return"vec4 "+o+"( vec4 value ) { return LinearTo"+t[0]+t[1]+"; }"}function tx(o,e){let t;switch(e){case 1:t="Linear";break;case 2:t="Reinhard";break;case 3:t="OptimizedCineon";break;case 4:t="ACESFilmic";break;case 5:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+o+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}function yo(o){return o!==""}function Ap(o,e){return o.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function Rp(o,e){return o.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const nx=/^[ \t]*#include +<([\w\d./]+)>/gm;function pu(o){return o.replace(nx,rx)}function rx(o,e){const t=_t[e];if(t===void 0)throw new Error("Can not resolve #include <"+e+">");return pu(t)}const ix=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,sx=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function Lp(o){return o.replace(sx,Cp).replace(ix,ox)}function ox(o,e,t,r){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),Cp(o,e,t,r)}function Cp(o,e,t,r){let i="";for(let a=parseInt(e);a<parseInt(t);a++)i+=r.replace(/\[\s*i\s*\]/g,"[ "+a+" ]").replace(/UNROLLED_LOOP_INDEX/g,a);return i}function Pp(o){let e="precision "+o.precision+` float;
precision `+o.precision+" int;";return o.precision==="highp"?e+=`
#define HIGH_PRECISION`:o.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:o.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function ax(o,e,t,r){const i=o.getContext(),a=t.defines;let c=t.vertexShader,u=t.fragmentShader;const h=function(V){let he="SHADOWMAP_TYPE_BASIC";return V.shadowMapType===1?he="SHADOWMAP_TYPE_PCF":V.shadowMapType===2?he="SHADOWMAP_TYPE_PCF_SOFT":V.shadowMapType===3&&(he="SHADOWMAP_TYPE_VSM"),he}(t),p=function(V){let he="ENVMAP_TYPE_CUBE";if(V.envMap)switch(V.envMapMode){case 301:case 302:he="ENVMAP_TYPE_CUBE";break;case 306:case 307:he="ENVMAP_TYPE_CUBE_UV"}return he}(t),m=function(V){let he="ENVMAP_MODE_REFLECTION";if(V.envMap)switch(V.envMapMode){case 302:case 307:he="ENVMAP_MODE_REFRACTION"}return he}(t),g=function(V){let he="ENVMAP_BLENDING_NONE";if(V.envMap)switch(V.combine){case 0:he="ENVMAP_BLENDING_MULTIPLY";break;case 1:he="ENVMAP_BLENDING_MIX";break;case 2:he="ENVMAP_BLENDING_ADD"}return he}(t),y=o.gammaFactor>0?o.gammaFactor:1,x=t.isWebGL2?"":function(V){return[V.extensionDerivatives||V.envMapCubeUV||V.bumpMap||V.tangentSpaceNormalMap||V.clearcoatNormalMap||V.flatShading||V.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(V.extensionFragDepth||V.logarithmicDepthBuffer)&&V.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",V.extensionDrawBuffers&&V.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(V.extensionShaderTextureLOD||V.envMap)&&V.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(yo).join(`
`)}(t),b=function(V){const he=[];for(const Z in V){const J=V[Z];J!==!1&&he.push("#define "+Z+" "+J)}return he.join(`
`)}(a),S=i.createProgram();let M,A,I=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(M=[b].filter(yo).join(`
`),M.length>0&&(M+=`
`),A=[x,b].filter(yo).join(`
`),A.length>0&&(A+=`
`)):(M=[Pp(t),"#define SHADER_NAME "+t.shaderName,b,t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+y,"#define MAX_BONES "+t.maxBones,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+m:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.displacementMap&&t.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.useVertexTexture?"#define BONE_TEXTURE":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+h:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#ifdef USE_MORPHTARGETS","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(yo).join(`
`),A=[x,Pp(t),"#define SHADER_NAME "+t.shaderName,b,t.alphaTest?"#define ALPHATEST "+t.alphaTest+(t.alphaTest%1?"":".0"):"","#define GAMMA_FACTOR "+y,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+p:"",t.envMap?"#define "+m:"",t.envMap?"#define "+g:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.sheen?"#define USE_SHEEN":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+h:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(t.extensionShaderTextureLOD||t.envMap)&&t.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==0?"#define TONE_MAPPING":"",t.toneMapping!==0?_t.tonemapping_pars_fragment:"",t.toneMapping!==0?tx("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",_t.encodings_pars_fragment,t.map?vo("mapTexelToLinear",t.mapEncoding):"",t.matcap?vo("matcapTexelToLinear",t.matcapEncoding):"",t.envMap?vo("envMapTexelToLinear",t.envMapEncoding):"",t.emissiveMap?vo("emissiveMapTexelToLinear",t.emissiveMapEncoding):"",t.lightMap?vo("lightMapTexelToLinear",t.lightMapEncoding):"",ex("linearToOutputTexel",t.outputEncoding),t.depthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(yo).join(`
`)),c=pu(c),c=Ap(c,t),c=Rp(c,t),u=pu(u),u=Ap(u,t),u=Rp(u,t),c=Lp(c),u=Lp(u),t.isWebGL2&&t.isRawShaderMaterial!==!0&&(I=`#version 300 es
`,M=["#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+M,A=["#define varying in",t.glslVersion===we?"":"out highp vec4 pc_fragColor;",t.glslVersion===we?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+A);const k=I+A+u,N=Sp(i,35633,I+M+c),G=Sp(i,35632,k);if(i.attachShader(S,N),i.attachShader(S,G),t.index0AttributeName!==void 0?i.bindAttribLocation(S,0,t.index0AttributeName):t.morphTargets===!0&&i.bindAttribLocation(S,0,"position"),i.linkProgram(S),o.debug.checkShaderErrors){const V=i.getProgramInfoLog(S).trim(),he=i.getShaderInfoLog(N).trim(),Z=i.getShaderInfoLog(G).trim();let J=!0,re=!0;if(i.getProgramParameter(S,35714)===!1){J=!1;const ee=Tp(i,N,"vertex"),le=Tp(i,G,"fragment");console.error("THREE.WebGLProgram: shader error: ",i.getError(),"35715",i.getProgramParameter(S,35715),"gl.getProgramInfoLog",V,ee,le)}else V!==""?console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()",V):he!==""&&Z!==""||(re=!1);re&&(this.diagnostics={runnable:J,programLog:V,vertexShader:{log:he,prefix:M},fragmentShader:{log:Z,prefix:A}})}let U,B;return i.deleteShader(N),i.deleteShader(G),this.getUniforms=function(){return U===void 0&&(U=new bi(i,S)),U},this.getAttributes=function(){return B===void 0&&(B=function(V,he){const Z={},J=V.getProgramParameter(he,35721);for(let re=0;re<J;re++){const ee=V.getActiveAttrib(he,re).name;Z[ee]=V.getAttribLocation(he,ee)}return Z}(i,S)),B},this.destroy=function(){r.releaseStatesOfProgram(this),i.deleteProgram(S),this.program=void 0},this.name=t.shaderName,this.id=Q0++,this.cacheKey=e,this.usedTimes=1,this.program=S,this.vertexShader=N,this.fragmentShader=G,this}function lx(o,e,t,r,i,a){const c=[],u=r.isWebGL2,h=r.logarithmicDepthBuffer,p=r.floatVertexTextures,m=r.maxVertexUniforms,g=r.vertexTextures;let y=r.precision;const x={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},b=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","roughnessMap","metalnessMap","gradientMap","alphaMap","combine","vertexColors","vertexAlphas","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","alphaTest","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","sheen","transmissionMap"];function S(M){let A;return M&&M.isTexture?A=M.encoding:M&&M.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),A=M.texture.encoding):A=3e3,A}return{getParameters:function(M,A,I,k,N){const G=k.fog,U=M.isMeshStandardMaterial?k.environment:null,B=e.get(M.envMap||U),V=x[M.type],he=N.isSkinnedMesh?function(ee){const le=ee.skeleton.bones;if(p)return 1024;{const Ce=m,Pe=Math.floor((Ce-20)/4),We=Math.min(Pe,le.length);return We<le.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+le.length+" bones. This GPU supports "+We+"."),0):We}}(N):0;let Z,J;if(M.precision!==null&&(y=r.getMaxPrecision(M.precision),y!==M.precision&&console.warn("THREE.WebGLProgram.getParameters:",M.precision,"not supported, using",y,"instead.")),V){const ee=pr[V];Z=ee.vertexShader,J=ee.fragmentShader}else Z=M.vertexShader,J=M.fragmentShader;const re=o.getRenderTarget();return{isWebGL2:u,shaderID:V,shaderName:M.type,vertexShader:Z,fragmentShader:J,defines:M.defines,isRawShaderMaterial:M.isRawShaderMaterial===!0,glslVersion:M.glslVersion,precision:y,instancing:N.isInstancedMesh===!0,instancingColor:N.isInstancedMesh===!0&&N.instanceColor!==null,supportsVertexTextures:g,outputEncoding:re!==null?S(re.texture):o.outputEncoding,map:!!M.map,mapEncoding:S(M.map),matcap:!!M.matcap,matcapEncoding:S(M.matcap),envMap:!!B,envMapMode:B&&B.mapping,envMapEncoding:S(B),envMapCubeUV:!!B&&(B.mapping===306||B.mapping===307),lightMap:!!M.lightMap,lightMapEncoding:S(M.lightMap),aoMap:!!M.aoMap,emissiveMap:!!M.emissiveMap,emissiveMapEncoding:S(M.emissiveMap),bumpMap:!!M.bumpMap,normalMap:!!M.normalMap,objectSpaceNormalMap:M.normalMapType===1,tangentSpaceNormalMap:M.normalMapType===0,clearcoatMap:!!M.clearcoatMap,clearcoatRoughnessMap:!!M.clearcoatRoughnessMap,clearcoatNormalMap:!!M.clearcoatNormalMap,displacementMap:!!M.displacementMap,roughnessMap:!!M.roughnessMap,metalnessMap:!!M.metalnessMap,specularMap:!!M.specularMap,alphaMap:!!M.alphaMap,gradientMap:!!M.gradientMap,sheen:!!M.sheen,transmissionMap:!!M.transmissionMap,combine:M.combine,vertexTangents:M.normalMap&&M.vertexTangents,vertexColors:M.vertexColors,vertexAlphas:M.vertexColors===!0&&N.geometry&&N.geometry.attributes.color&&N.geometry.attributes.color.itemSize===4,vertexUvs:!!(M.map||M.bumpMap||M.normalMap||M.specularMap||M.alphaMap||M.emissiveMap||M.roughnessMap||M.metalnessMap||M.clearcoatMap||M.clearcoatRoughnessMap||M.clearcoatNormalMap||M.displacementMap||M.transmissionMap),uvsVertexOnly:!(M.map||M.bumpMap||M.normalMap||M.specularMap||M.alphaMap||M.emissiveMap||M.roughnessMap||M.metalnessMap||M.clearcoatNormalMap||M.transmissionMap||!M.displacementMap),fog:!!G,useFog:M.fog,fogExp2:G&&G.isFogExp2,flatShading:!!M.flatShading,sizeAttenuation:M.sizeAttenuation,logarithmicDepthBuffer:h,skinning:M.skinning&&he>0,maxBones:he,useVertexTexture:p,morphTargets:M.morphTargets,morphNormals:M.morphNormals,numDirLights:A.directional.length,numPointLights:A.point.length,numSpotLights:A.spot.length,numRectAreaLights:A.rectArea.length,numHemiLights:A.hemi.length,numDirLightShadows:A.directionalShadowMap.length,numPointLightShadows:A.pointShadowMap.length,numSpotLightShadows:A.spotShadowMap.length,numClippingPlanes:a.numPlanes,numClipIntersection:a.numIntersection,dithering:M.dithering,shadowMapEnabled:o.shadowMap.enabled&&I.length>0,shadowMapType:o.shadowMap.type,toneMapping:M.toneMapped?o.toneMapping:0,physicallyCorrectLights:o.physicallyCorrectLights,premultipliedAlpha:M.premultipliedAlpha,alphaTest:M.alphaTest,doubleSided:M.side===2,flipSided:M.side===1,depthPacking:M.depthPacking!==void 0&&M.depthPacking,index0AttributeName:M.index0AttributeName,extensionDerivatives:M.extensions&&M.extensions.derivatives,extensionFragDepth:M.extensions&&M.extensions.fragDepth,extensionDrawBuffers:M.extensions&&M.extensions.drawBuffers,extensionShaderTextureLOD:M.extensions&&M.extensions.shaderTextureLOD,rendererExtensionFragDepth:u||t.has("EXT_frag_depth"),rendererExtensionDrawBuffers:u||t.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:u||t.has("EXT_shader_texture_lod"),customProgramCacheKey:M.customProgramCacheKey()}},getProgramCacheKey:function(M){const A=[];if(M.shaderID?A.push(M.shaderID):(A.push(M.fragmentShader),A.push(M.vertexShader)),M.defines!==void 0)for(const I in M.defines)A.push(I),A.push(M.defines[I]);if(M.isRawShaderMaterial===!1){for(let I=0;I<b.length;I++)A.push(M[b[I]]);A.push(o.outputEncoding),A.push(o.gammaFactor)}return A.push(M.customProgramCacheKey),A.join()},getUniforms:function(M){const A=x[M.type];let I;if(A){const k=pr[A];I=hp.clone(k.uniforms)}else I=M.uniforms;return I},acquireProgram:function(M,A){let I;for(let k=0,N=c.length;k<N;k++){const G=c[k];if(G.cacheKey===A){I=G,++I.usedTimes;break}}return I===void 0&&(I=new ax(o,A,M,i),c.push(I)),I},releaseProgram:function(M){if(--M.usedTimes==0){const A=c.indexOf(M);c[A]=c[c.length-1],c.pop(),M.destroy()}},programs:c}}function cx(){let o=new WeakMap;return{get:function(e){let t=o.get(e);return t===void 0&&(t={},o.set(e,t)),t},remove:function(e){o.delete(e)},update:function(e,t,r){o.get(e)[t]=r},dispose:function(){o=new WeakMap}}}function ux(o,e){return o.groupOrder!==e.groupOrder?o.groupOrder-e.groupOrder:o.renderOrder!==e.renderOrder?o.renderOrder-e.renderOrder:o.program!==e.program?o.program.id-e.program.id:o.material.id!==e.material.id?o.material.id-e.material.id:o.z!==e.z?o.z-e.z:o.id-e.id}function hx(o,e){return o.groupOrder!==e.groupOrder?o.groupOrder-e.groupOrder:o.renderOrder!==e.renderOrder?o.renderOrder-e.renderOrder:o.z!==e.z?e.z-o.z:o.id-e.id}function Ip(o){const e=[];let t=0;const r=[],i=[],a={id:-1};function c(u,h,p,m,g,y){let x=e[t];const b=o.get(p);return x===void 0?(x={id:u.id,object:u,geometry:h,material:p,program:b.program||a,groupOrder:m,renderOrder:u.renderOrder,z:g,group:y},e[t]=x):(x.id=u.id,x.object=u,x.geometry=h,x.material=p,x.program=b.program||a,x.groupOrder=m,x.renderOrder=u.renderOrder,x.z=g,x.group=y),t++,x}return{opaque:r,transparent:i,init:function(){t=0,r.length=0,i.length=0},push:function(u,h,p,m,g,y){const x=c(u,h,p,m,g,y);(p.transparent===!0?i:r).push(x)},unshift:function(u,h,p,m,g,y){const x=c(u,h,p,m,g,y);(p.transparent===!0?i:r).unshift(x)},finish:function(){for(let u=t,h=e.length;u<h;u++){const p=e[u];if(p.id===null)break;p.id=null,p.object=null,p.geometry=null,p.material=null,p.program=null,p.group=null}},sort:function(u,h){r.length>1&&r.sort(u||ux),i.length>1&&i.sort(h||hx)}}}function dx(o){let e=new WeakMap;return{get:function(t,r){let i;return e.has(t)===!1?(i=new Ip(o),e.set(t,[i])):r>=e.get(t).length?(i=new Ip(o),e.get(t).push(i)):i=e.get(t)[r],i},dispose:function(){e=new WeakMap}}}function px(){const o={};return{get:function(e){if(o[e.id]!==void 0)return o[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new O,color:new Ge};break;case"SpotLight":t={position:new O,direction:new O,color:new Ge,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new O,color:new Ge,distance:0,decay:0};break;case"HemisphereLight":t={direction:new O,skyColor:new Ge,groundColor:new Ge};break;case"RectAreaLight":t={color:new Ge,position:new O,halfWidth:new O,halfHeight:new O}}return o[e.id]=t,t}}}let fx=0;function mx(o,e){return(e.castShadow?1:0)-(o.castShadow?1:0)}function gx(o,e){const t=new px,r=function(){const h={};return{get:function(p){if(h[p.id]!==void 0)return h[p.id];let m;switch(p.type){case"DirectionalLight":case"SpotLight":m={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Ee};break;case"PointLight":m={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Ee,shadowCameraNear:1,shadowCameraFar:1e3}}return h[p.id]=m,m}}}(),i={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let h=0;h<9;h++)i.probe.push(new O);const a=new O,c=new Ze,u=new Ze;return{setup:function(h){let p=0,m=0,g=0;for(let G=0;G<9;G++)i.probe[G].set(0,0,0);let y=0,x=0,b=0,S=0,M=0,A=0,I=0,k=0;h.sort(mx);for(let G=0,U=h.length;G<U;G++){const B=h[G],V=B.color,he=B.intensity,Z=B.distance,J=B.shadow&&B.shadow.map?B.shadow.map.texture:null;if(B.isAmbientLight)p+=V.r*he,m+=V.g*he,g+=V.b*he;else if(B.isLightProbe)for(let re=0;re<9;re++)i.probe[re].addScaledVector(B.sh.coefficients[re],he);else if(B.isDirectionalLight){const re=t.get(B);if(re.color.copy(B.color).multiplyScalar(B.intensity),B.castShadow){const ee=B.shadow,le=r.get(B);le.shadowBias=ee.bias,le.shadowNormalBias=ee.normalBias,le.shadowRadius=ee.radius,le.shadowMapSize=ee.mapSize,i.directionalShadow[y]=le,i.directionalShadowMap[y]=J,i.directionalShadowMatrix[y]=B.shadow.matrix,A++}i.directional[y]=re,y++}else if(B.isSpotLight){const re=t.get(B);if(re.position.setFromMatrixPosition(B.matrixWorld),re.color.copy(V).multiplyScalar(he),re.distance=Z,re.coneCos=Math.cos(B.angle),re.penumbraCos=Math.cos(B.angle*(1-B.penumbra)),re.decay=B.decay,B.castShadow){const ee=B.shadow,le=r.get(B);le.shadowBias=ee.bias,le.shadowNormalBias=ee.normalBias,le.shadowRadius=ee.radius,le.shadowMapSize=ee.mapSize,i.spotShadow[b]=le,i.spotShadowMap[b]=J,i.spotShadowMatrix[b]=B.shadow.matrix,k++}i.spot[b]=re,b++}else if(B.isRectAreaLight){const re=t.get(B);re.color.copy(V).multiplyScalar(he),re.halfWidth.set(.5*B.width,0,0),re.halfHeight.set(0,.5*B.height,0),i.rectArea[S]=re,S++}else if(B.isPointLight){const re=t.get(B);if(re.color.copy(B.color).multiplyScalar(B.intensity),re.distance=B.distance,re.decay=B.decay,B.castShadow){const ee=B.shadow,le=r.get(B);le.shadowBias=ee.bias,le.shadowNormalBias=ee.normalBias,le.shadowRadius=ee.radius,le.shadowMapSize=ee.mapSize,le.shadowCameraNear=ee.camera.near,le.shadowCameraFar=ee.camera.far,i.pointShadow[x]=le,i.pointShadowMap[x]=J,i.pointShadowMatrix[x]=B.shadow.matrix,I++}i.point[x]=re,x++}else if(B.isHemisphereLight){const re=t.get(B);re.skyColor.copy(B.color).multiplyScalar(he),re.groundColor.copy(B.groundColor).multiplyScalar(he),i.hemi[M]=re,M++}}S>0&&(e.isWebGL2||o.has("OES_texture_float_linear")===!0?(i.rectAreaLTC1=Be.LTC_FLOAT_1,i.rectAreaLTC2=Be.LTC_FLOAT_2):o.has("OES_texture_half_float_linear")===!0?(i.rectAreaLTC1=Be.LTC_HALF_1,i.rectAreaLTC2=Be.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),i.ambient[0]=p,i.ambient[1]=m,i.ambient[2]=g;const N=i.hash;N.directionalLength===y&&N.pointLength===x&&N.spotLength===b&&N.rectAreaLength===S&&N.hemiLength===M&&N.numDirectionalShadows===A&&N.numPointShadows===I&&N.numSpotShadows===k||(i.directional.length=y,i.spot.length=b,i.rectArea.length=S,i.point.length=x,i.hemi.length=M,i.directionalShadow.length=A,i.directionalShadowMap.length=A,i.pointShadow.length=I,i.pointShadowMap.length=I,i.spotShadow.length=k,i.spotShadowMap.length=k,i.directionalShadowMatrix.length=A,i.pointShadowMatrix.length=I,i.spotShadowMatrix.length=k,N.directionalLength=y,N.pointLength=x,N.spotLength=b,N.rectAreaLength=S,N.hemiLength=M,N.numDirectionalShadows=A,N.numPointShadows=I,N.numSpotShadows=k,i.version=fx++)},setupView:function(h,p){let m=0,g=0,y=0,x=0,b=0;const S=p.matrixWorldInverse;for(let M=0,A=h.length;M<A;M++){const I=h[M];if(I.isDirectionalLight){const k=i.directional[m];k.direction.setFromMatrixPosition(I.matrixWorld),a.setFromMatrixPosition(I.target.matrixWorld),k.direction.sub(a),k.direction.transformDirection(S),m++}else if(I.isSpotLight){const k=i.spot[y];k.position.setFromMatrixPosition(I.matrixWorld),k.position.applyMatrix4(S),k.direction.setFromMatrixPosition(I.matrixWorld),a.setFromMatrixPosition(I.target.matrixWorld),k.direction.sub(a),k.direction.transformDirection(S),y++}else if(I.isRectAreaLight){const k=i.rectArea[x];k.position.setFromMatrixPosition(I.matrixWorld),k.position.applyMatrix4(S),u.identity(),c.copy(I.matrixWorld),c.premultiply(S),u.extractRotation(c),k.halfWidth.set(.5*I.width,0,0),k.halfHeight.set(0,.5*I.height,0),k.halfWidth.applyMatrix4(u),k.halfHeight.applyMatrix4(u),x++}else if(I.isPointLight){const k=i.point[g];k.position.setFromMatrixPosition(I.matrixWorld),k.position.applyMatrix4(S),g++}else if(I.isHemisphereLight){const k=i.hemi[b];k.direction.setFromMatrixPosition(I.matrixWorld),k.direction.transformDirection(S),k.direction.normalize(),b++}}},state:i}}function Op(o,e){const t=new gx(o,e),r=[],i=[];return{init:function(){r.length=0,i.length=0},state:{lightsArray:r,shadowsArray:i,lights:t},setupLights:function(){t.setup(r)},setupLightsView:function(a){t.setupView(r,a)},pushLight:function(a){r.push(a)},pushShadow:function(a){i.push(a)}}}function vx(o,e){let t=new WeakMap;return{get:function(r,i=0){let a;return t.has(r)===!1?(a=new Op(o,e),t.set(r,[a])):i>=t.get(r).length?(a=new Op(o,e),t.get(r).push(a)):a=t.get(r)[i],a},dispose:function(){t=new WeakMap}}}class Ka extends rn{constructor(e){super(),this.type="MeshDepthMaterial",this.depthPacking=3200,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}Ka.prototype.isMeshDepthMaterial=!0;class $a extends rn{constructor(e){super(),this.type="MeshDistanceMaterial",this.referencePosition=new O,this.nearDistance=1,this.farDistance=1e3,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(e)}copy(e){return super.copy(e),this.referencePosition.copy(e.referencePosition),this.nearDistance=e.nearDistance,this.farDistance=e.farDistance,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}$a.prototype.isMeshDistanceMaterial=!0;function Dp(o,e,t){let r=new mo;const i=new Ee,a=new Ee,c=new Dt,u=[],h=[],p={},m=t.maxTextureSize,g={0:1,1:0,2:2},y=new Kr({defines:{SAMPLE_RATE:2/8,HALF_SAMPLE_RATE:1/8},uniforms:{shadow_pass:{value:null},resolution:{value:new Ee},radius:{value:4}},vertexShader:`void main() {
	gl_Position = vec4( position, 1.0 );
}`,fragmentShader:`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	float mean = 0.0;
	float squared_mean = 0.0;
	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );
	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean * HALF_SAMPLE_RATE;
	squared_mean = squared_mean * HALF_SAMPLE_RATE;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`}),x=y.clone();x.defines.HORIZONTAL_PASS=1;const b=new Qe;b.setAttribute("position",new xt(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const S=new sn(b,y),M=this;function A(U,B){const V=e.update(S);y.uniforms.shadow_pass.value=U.map.texture,y.uniforms.resolution.value=U.mapSize,y.uniforms.radius.value=U.radius,o.setRenderTarget(U.mapPass),o.clear(),o.renderBufferDirect(B,null,V,y,S,null),x.uniforms.shadow_pass.value=U.mapPass.texture,x.uniforms.resolution.value=U.mapSize,x.uniforms.radius.value=U.radius,o.setRenderTarget(U.map),o.clear(),o.renderBufferDirect(B,null,V,x,S,null)}function I(U,B,V){const he=U<<0|B<<1|V<<2;let Z=u[he];return Z===void 0&&(Z=new Ka({depthPacking:3201,morphTargets:U,skinning:B}),u[he]=Z),Z}function k(U,B,V){const he=U<<0|B<<1|V<<2;let Z=h[he];return Z===void 0&&(Z=new $a({morphTargets:U,skinning:B}),h[he]=Z),Z}function N(U,B,V,he,Z,J,re){let ee=null,le=I,Ce=U.customDepthMaterial;if(he.isPointLight===!0&&(le=k,Ce=U.customDistanceMaterial),Ce===void 0){let Pe=!1;V.morphTargets===!0&&(Pe=B.morphAttributes&&B.morphAttributes.position&&B.morphAttributes.position.length>0);let We=!1;U.isSkinnedMesh===!0&&(V.skinning===!0?We=!0:console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",U)),ee=le(Pe,We,U.isInstancedMesh===!0)}else ee=Ce;if(o.localClippingEnabled&&V.clipShadows===!0&&V.clippingPlanes.length!==0){const Pe=ee.uuid,We=V.uuid;let Oe=p[Pe];Oe===void 0&&(Oe={},p[Pe]=Oe);let De=Oe[We];De===void 0&&(De=ee.clone(),Oe[We]=De),ee=De}return ee.visible=V.visible,ee.wireframe=V.wireframe,ee.side=re===3?V.shadowSide!==null?V.shadowSide:V.side:V.shadowSide!==null?V.shadowSide:g[V.side],ee.clipShadows=V.clipShadows,ee.clippingPlanes=V.clippingPlanes,ee.clipIntersection=V.clipIntersection,ee.wireframeLinewidth=V.wireframeLinewidth,ee.linewidth=V.linewidth,he.isPointLight===!0&&ee.isMeshDistanceMaterial===!0&&(ee.referencePosition.setFromMatrixPosition(he.matrixWorld),ee.nearDistance=Z,ee.farDistance=J),ee}function G(U,B,V,he,Z){if(U.visible===!1)return;if(U.layers.test(B.layers)&&(U.isMesh||U.isLine||U.isPoints)&&(U.castShadow||U.receiveShadow&&Z===3)&&(!U.frustumCulled||r.intersectsObject(U))){U.modelViewMatrix.multiplyMatrices(V.matrixWorldInverse,U.matrixWorld);const re=e.update(U),ee=U.material;if(Array.isArray(ee)){const le=re.groups;for(let Ce=0,Pe=le.length;Ce<Pe;Ce++){const We=le[Ce],Oe=ee[We.materialIndex];if(Oe&&Oe.visible){const De=N(U,re,Oe,he,V.near,V.far,Z);o.renderBufferDirect(V,null,re,De,U,We)}}}else if(ee.visible){const le=N(U,re,ee,he,V.near,V.far,Z);o.renderBufferDirect(V,null,re,le,U,null)}}const J=U.children;for(let re=0,ee=J.length;re<ee;re++)G(J[re],B,V,he,Z)}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=1,this.render=function(U,B,V){if(M.enabled===!1||M.autoUpdate===!1&&M.needsUpdate===!1||U.length===0)return;const he=o.getRenderTarget(),Z=o.getActiveCubeFace(),J=o.getActiveMipmapLevel(),re=o.state;re.setBlending(0),re.buffers.color.setClear(1,1,1,1),re.buffers.depth.setTest(!0),re.setScissorTest(!1);for(let ee=0,le=U.length;ee<le;ee++){const Ce=U[ee],Pe=Ce.shadow;if(Pe===void 0){console.warn("THREE.WebGLShadowMap:",Ce,"has no shadow.");continue}if(Pe.autoUpdate===!1&&Pe.needsUpdate===!1)continue;i.copy(Pe.mapSize);const We=Pe.getFrameExtents();if(i.multiply(We),a.copy(Pe.mapSize),(i.x>m||i.y>m)&&(i.x>m&&(a.x=Math.floor(m/We.x),i.x=a.x*We.x,Pe.mapSize.x=a.x),i.y>m&&(a.y=Math.floor(m/We.y),i.y=a.y*We.y,Pe.mapSize.y=a.y)),Pe.map===null&&!Pe.isPointLightShadow&&this.type===3){const De={minFilter:1006,magFilter:1006,format:1023};Pe.map=new Vr(i.x,i.y,De),Pe.map.texture.name=Ce.name+".shadowMap",Pe.mapPass=new Vr(i.x,i.y,De),Pe.camera.updateProjectionMatrix()}if(Pe.map===null){const De={minFilter:1003,magFilter:1003,format:1023};Pe.map=new Vr(i.x,i.y,De),Pe.map.texture.name=Ce.name+".shadowMap",Pe.camera.updateProjectionMatrix()}o.setRenderTarget(Pe.map),o.clear();const Oe=Pe.getViewportCount();for(let De=0;De<Oe;De++){const ze=Pe.getViewport(De);c.set(a.x*ze.x,a.y*ze.y,a.x*ze.z,a.y*ze.w),re.viewport(c),Pe.updateMatrices(Ce,De),r=Pe.getFrustum(),G(B,V,Pe.camera,Ce,this.type)}Pe.isPointLightShadow||this.type!==3||A(Pe,V),Pe.needsUpdate=!1}M.needsUpdate=!1,o.setRenderTarget(he,Z,J)}}function yx(o,e,t){const r=t.isWebGL2,i=new function(){let W=!1;const K=new Dt;let Q=null;const ge=new Dt(0,0,0,0);return{setMask:function(ve){Q===ve||W||(o.colorMask(ve,ve,ve,ve),Q=ve)},setLocked:function(ve){W=ve},setClear:function(ve,Me,Ie,Xe,ht){ht===!0&&(ve*=Xe,Me*=Xe,Ie*=Xe),K.set(ve,Me,Ie,Xe),ge.equals(K)===!1&&(o.clearColor(ve,Me,Ie,Xe),ge.copy(K))},reset:function(){W=!1,Q=null,ge.set(-1,0,0,0)}}},a=new function(){let W=!1,K=null,Q=null,ge=null;return{setTest:function(ve){ve?De(2929):ze(2929)},setMask:function(ve){K===ve||W||(o.depthMask(ve),K=ve)},setFunc:function(ve){if(Q!==ve){if(ve)switch(ve){case 0:o.depthFunc(512);break;case 1:o.depthFunc(519);break;case 2:o.depthFunc(513);break;case 3:o.depthFunc(515);break;case 4:o.depthFunc(514);break;case 5:o.depthFunc(518);break;case 6:o.depthFunc(516);break;case 7:o.depthFunc(517);break;default:o.depthFunc(515)}else o.depthFunc(515);Q=ve}},setLocked:function(ve){W=ve},setClear:function(ve){ge!==ve&&(o.clearDepth(ve),ge=ve)},reset:function(){W=!1,K=null,Q=null,ge=null}}},c=new function(){let W=!1,K=null,Q=null,ge=null,ve=null,Me=null,Ie=null,Xe=null,ht=null;return{setTest:function(je){W||(je?De(2960):ze(2960))},setMask:function(je){K===je||W||(o.stencilMask(je),K=je)},setFunc:function(je,rt,wt){Q===je&&ge===rt&&ve===wt||(o.stencilFunc(je,rt,wt),Q=je,ge=rt,ve=wt)},setOp:function(je,rt,wt){Me===je&&Ie===rt&&Xe===wt||(o.stencilOp(je,rt,wt),Me=je,Ie=rt,Xe=wt)},setLocked:function(je){W=je},setClear:function(je){ht!==je&&(o.clearStencil(je),ht=je)},reset:function(){W=!1,K=null,Q=null,ge=null,ve=null,Me=null,Ie=null,Xe=null,ht=null}}};let u={},h=null,p={},m=null,g=!1,y=null,x=null,b=null,S=null,M=null,A=null,I=null,k=!1,N=null,G=null,U=null,B=null,V=null;const he=o.getParameter(35661);let Z=!1,J=0;const re=o.getParameter(7938);re.indexOf("WebGL")!==-1?(J=parseFloat(/^WebGL (\d)/.exec(re)[1]),Z=J>=1):re.indexOf("OpenGL ES")!==-1&&(J=parseFloat(/^OpenGL ES (\d)/.exec(re)[1]),Z=J>=2);let ee=null,le={};const Ce=new Dt(0,0,o.canvas.width,o.canvas.height),Pe=new Dt(0,0,o.canvas.width,o.canvas.height);function We(W,K,Q){const ge=new Uint8Array(4),ve=o.createTexture();o.bindTexture(W,ve),o.texParameteri(W,10241,9728),o.texParameteri(W,10240,9728);for(let Me=0;Me<Q;Me++)o.texImage2D(K+Me,0,6408,1,1,0,6408,5121,ge);return ve}const Oe={};function De(W){u[W]!==!0&&(o.enable(W),u[W]=!0)}function ze(W){u[W]!==!1&&(o.disable(W),u[W]=!1)}Oe[3553]=We(3553,3553,1),Oe[34067]=We(34067,34069,6),i.setClear(0,0,0,1),a.setClear(1),c.setClear(0),De(2929),a.setFunc(3),fe(!1),de(1),De(2884),Y(0);const st={100:32774,101:32778,102:32779};if(r)st[103]=32775,st[104]=32776;else{const W=e.get("EXT_blend_minmax");W!==null&&(st[103]=W.MIN_EXT,st[104]=W.MAX_EXT)}const q={200:0,201:1,202:768,204:770,210:776,208:774,206:772,203:769,205:771,209:775,207:773};function Y(W,K,Q,ge,ve,Me,Ie,Xe){if(W!==0){if(g===!1&&(De(3042),g=!0),W===5)ve=ve||K,Me=Me||Q,Ie=Ie||ge,K===x&&ve===M||(o.blendEquationSeparate(st[K],st[ve]),x=K,M=ve),Q===b&&ge===S&&Me===A&&Ie===I||(o.blendFuncSeparate(q[Q],q[ge],q[Me],q[Ie]),b=Q,S=ge,A=Me,I=Ie),y=W,k=null;else if(W!==y||Xe!==k){if(x===100&&M===100||(o.blendEquation(32774),x=100,M=100),Xe)switch(W){case 1:o.blendFuncSeparate(1,771,1,771);break;case 2:o.blendFunc(1,1);break;case 3:o.blendFuncSeparate(0,0,769,771);break;case 4:o.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",W)}else switch(W){case 1:o.blendFuncSeparate(770,771,1,771);break;case 2:o.blendFunc(770,1);break;case 3:o.blendFunc(0,769);break;case 4:o.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",W)}b=null,S=null,A=null,I=null,y=W,k=Xe}}else g===!0&&(ze(3042),g=!1)}function fe(W){N!==W&&(W?o.frontFace(2304):o.frontFace(2305),N=W)}function de(W){W!==0?(De(2884),W!==G&&(W===1?o.cullFace(1029):W===2?o.cullFace(1028):o.cullFace(1032))):ze(2884),G=W}function oe(W,K,Q){W?(De(32823),B===K&&V===Q||(o.polygonOffset(K,Q),B=K,V=Q)):ze(32823)}function Ve(W){W===void 0&&(W=33984+he-1),ee!==W&&(o.activeTexture(W),ee=W)}return{buffers:{color:i,depth:a,stencil:c},enable:De,disable:ze,bindFramebuffer:function(W,K){K===null&&h!==null&&(K=h),p[W]!==K&&(o.bindFramebuffer(W,K),p[W]=K,r&&(W===36009&&(p[36160]=K),W===36160&&(p[36009]=K)))},bindXRFramebuffer:function(W){W!==h&&(o.bindFramebuffer(36160,W),h=W)},useProgram:function(W){return m!==W&&(o.useProgram(W),m=W,!0)},setBlending:Y,setMaterial:function(W,K){W.side===2?ze(2884):De(2884);let Q=W.side===1;K&&(Q=!Q),fe(Q),W.blending===1&&W.transparent===!1?Y(0):Y(W.blending,W.blendEquation,W.blendSrc,W.blendDst,W.blendEquationAlpha,W.blendSrcAlpha,W.blendDstAlpha,W.premultipliedAlpha),a.setFunc(W.depthFunc),a.setTest(W.depthTest),a.setMask(W.depthWrite),i.setMask(W.colorWrite);const ge=W.stencilWrite;c.setTest(ge),ge&&(c.setMask(W.stencilWriteMask),c.setFunc(W.stencilFunc,W.stencilRef,W.stencilFuncMask),c.setOp(W.stencilFail,W.stencilZFail,W.stencilZPass)),oe(W.polygonOffset,W.polygonOffsetFactor,W.polygonOffsetUnits),W.alphaToCoverage===!0?De(32926):ze(32926)},setFlipSided:fe,setCullFace:de,setLineWidth:function(W){W!==U&&(Z&&o.lineWidth(W),U=W)},setPolygonOffset:oe,setScissorTest:function(W){W?De(3089):ze(3089)},activeTexture:Ve,bindTexture:function(W,K){ee===null&&Ve();let Q=le[ee];Q===void 0&&(Q={type:void 0,texture:void 0},le[ee]=Q),Q.type===W&&Q.texture===K||(o.bindTexture(W,K||Oe[W]),Q.type=W,Q.texture=K)},unbindTexture:function(){const W=le[ee];W!==void 0&&W.type!==void 0&&(o.bindTexture(W.type,null),W.type=void 0,W.texture=void 0)},compressedTexImage2D:function(){try{o.compressedTexImage2D.apply(o,arguments)}catch(W){console.error("THREE.WebGLState:",W)}},texImage2D:function(){try{o.texImage2D.apply(o,arguments)}catch(W){console.error("THREE.WebGLState:",W)}},texImage3D:function(){try{o.texImage3D.apply(o,arguments)}catch(W){console.error("THREE.WebGLState:",W)}},scissor:function(W){Ce.equals(W)===!1&&(o.scissor(W.x,W.y,W.z,W.w),Ce.copy(W))},viewport:function(W){Pe.equals(W)===!1&&(o.viewport(W.x,W.y,W.z,W.w),Pe.copy(W))},reset:function(){o.disable(3042),o.disable(2884),o.disable(2929),o.disable(32823),o.disable(3089),o.disable(2960),o.disable(32926),o.blendEquation(32774),o.blendFunc(1,0),o.blendFuncSeparate(1,0,1,0),o.colorMask(!0,!0,!0,!0),o.clearColor(0,0,0,0),o.depthMask(!0),o.depthFunc(513),o.clearDepth(1),o.stencilMask(4294967295),o.stencilFunc(519,0,4294967295),o.stencilOp(7680,7680,7680),o.clearStencil(0),o.cullFace(1029),o.frontFace(2305),o.polygonOffset(0,0),o.activeTexture(33984),o.bindFramebuffer(36160,null),r===!0&&(o.bindFramebuffer(36009,null),o.bindFramebuffer(36008,null)),o.useProgram(null),o.lineWidth(1),o.scissor(0,0,o.canvas.width,o.canvas.height),o.viewport(0,0,o.canvas.width,o.canvas.height),u={},ee=null,le={},h=null,p={},m=null,g=!1,y=null,x=null,b=null,S=null,M=null,A=null,I=null,k=!1,N=null,G=null,U=null,B=null,V=null,Ce.set(0,0,o.canvas.width,o.canvas.height),Pe.set(0,0,o.canvas.width,o.canvas.height),i.reset(),a.reset(),c.reset()}}}function xx(o,e,t,r,i,a,c){const u=i.isWebGL2,h=i.maxTextures,p=i.maxCubemapSize,m=i.maxTextureSize,g=i.maxSamples,y=new WeakMap;let x,b=!1;try{b=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function S(q,Y){return b?new OffscreenCanvas(q,Y):document.createElementNS("http://www.w3.org/1999/xhtml","canvas")}function M(q,Y,fe,de){let oe=1;if((q.width>de||q.height>de)&&(oe=de/Math.max(q.width,q.height)),oe<1||Y===!0){if(typeof HTMLImageElement<"u"&&q instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&q instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&q instanceof ImageBitmap){const Ve=Y?Kn:Math.floor,W=Ve(oe*q.width),K=Ve(oe*q.height);x===void 0&&(x=S(W,K));const Q=fe?S(W,K):x;return Q.width=W,Q.height=K,Q.getContext("2d").drawImage(q,0,0,W,K),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+q.width+"x"+q.height+") to ("+W+"x"+K+")."),Q}return"data"in q&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+q.width+"x"+q.height+")."),q}return q}function A(q){return pn(q.width)&&pn(q.height)}function I(q,Y){return q.generateMipmaps&&Y&&q.minFilter!==1003&&q.minFilter!==1006}function k(q,Y,fe,de){o.generateMipmap(q),r.get(Y).__maxMipLevel=Math.log2(Math.max(fe,de))}function N(q,Y,fe){if(u===!1)return Y;if(q!==null){if(o[q]!==void 0)return o[q];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+q+"'")}let de=Y;return Y===6403&&(fe===5126&&(de=33326),fe===5131&&(de=33325),fe===5121&&(de=33321)),Y===6407&&(fe===5126&&(de=34837),fe===5131&&(de=34843),fe===5121&&(de=32849)),Y===6408&&(fe===5126&&(de=34836),fe===5131&&(de=34842),fe===5121&&(de=32856)),de!==33325&&de!==33326&&de!==34842&&de!==34836||e.get("EXT_color_buffer_float"),de}function G(q){return q===1003||q===1004||q===1005?9728:9729}function U(q){const Y=q.target;Y.removeEventListener("dispose",U),function(fe){const de=r.get(fe);de.__webglInit!==void 0&&(o.deleteTexture(de.__webglTexture),r.remove(fe))}(Y),Y.isVideoTexture&&y.delete(Y),c.memory.textures--}function B(q){const Y=q.target;Y.removeEventListener("dispose",B),function(fe){const de=fe.texture,oe=r.get(fe),Ve=r.get(de);if(fe){if(Ve.__webglTexture!==void 0&&o.deleteTexture(Ve.__webglTexture),fe.depthTexture&&fe.depthTexture.dispose(),fe.isWebGLCubeRenderTarget)for(let W=0;W<6;W++)o.deleteFramebuffer(oe.__webglFramebuffer[W]),oe.__webglDepthbuffer&&o.deleteRenderbuffer(oe.__webglDepthbuffer[W]);else o.deleteFramebuffer(oe.__webglFramebuffer),oe.__webglDepthbuffer&&o.deleteRenderbuffer(oe.__webglDepthbuffer),oe.__webglMultisampledFramebuffer&&o.deleteFramebuffer(oe.__webglMultisampledFramebuffer),oe.__webglColorRenderbuffer&&o.deleteRenderbuffer(oe.__webglColorRenderbuffer),oe.__webglDepthRenderbuffer&&o.deleteRenderbuffer(oe.__webglDepthRenderbuffer);r.remove(de),r.remove(fe)}}(Y),c.memory.textures--}let V=0;function he(q,Y){const fe=r.get(q);if(q.isVideoTexture&&function(de){const oe=c.render.frame;y.get(de)!==oe&&(y.set(de,oe),de.update())}(q),q.version>0&&fe.__version!==q.version){const de=q.image;if(de===void 0)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else{if(de.complete!==!1)return void Ce(fe,q,Y);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}t.activeTexture(33984+Y),t.bindTexture(3553,fe.__webglTexture)}function Z(q,Y){const fe=r.get(q);q.version>0&&fe.__version!==q.version?function(de,oe,Ve){if(oe.image.length!==6)return;le(de,oe),t.activeTexture(33984+Ve),t.bindTexture(34067,de.__webglTexture),o.pixelStorei(37440,oe.flipY),o.pixelStorei(37441,oe.premultiplyAlpha),o.pixelStorei(3317,oe.unpackAlignment),o.pixelStorei(37443,0);const W=oe&&(oe.isCompressedTexture||oe.image[0].isCompressedTexture),K=oe.image[0]&&oe.image[0].isDataTexture,Q=[];for(let je=0;je<6;je++)Q[je]=W||K?K?oe.image[je].image:oe.image[je]:M(oe.image[je],!1,!0,p);const ge=Q[0],ve=A(ge)||u,Me=a.convert(oe.format),Ie=a.convert(oe.type),Xe=N(oe.internalFormat,Me,Ie);let ht;if(ee(34067,oe,ve),W){for(let je=0;je<6;je++){ht=Q[je].mipmaps;for(let rt=0;rt<ht.length;rt++){const wt=ht[rt];oe.format!==1023&&oe.format!==1022?Me!==null?t.compressedTexImage2D(34069+je,rt,Xe,wt.width,wt.height,0,wt.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):t.texImage2D(34069+je,rt,Xe,wt.width,wt.height,0,Me,Ie,wt.data)}}de.__maxMipLevel=ht.length-1}else{ht=oe.mipmaps;for(let je=0;je<6;je++)if(K){t.texImage2D(34069+je,0,Xe,Q[je].width,Q[je].height,0,Me,Ie,Q[je].data);for(let rt=0;rt<ht.length;rt++){const wt=ht[rt].image[je].image;t.texImage2D(34069+je,rt+1,Xe,wt.width,wt.height,0,Me,Ie,wt.data)}}else{t.texImage2D(34069+je,0,Xe,Me,Ie,Q[je]);for(let rt=0;rt<ht.length;rt++){const wt=ht[rt];t.texImage2D(34069+je,rt+1,Xe,Me,Ie,wt.image[je])}}de.__maxMipLevel=ht.length}I(oe,ve)&&k(34067,oe,ge.width,ge.height),de.__version=oe.version,oe.onUpdate&&oe.onUpdate(oe)}(fe,q,Y):(t.activeTexture(33984+Y),t.bindTexture(34067,fe.__webglTexture))}const J={1e3:10497,1001:33071,1002:33648},re={1003:9728,1004:9984,1005:9986,1006:9729,1007:9985,1008:9987};function ee(q,Y,fe){if(fe?(o.texParameteri(q,10242,J[Y.wrapS]),o.texParameteri(q,10243,J[Y.wrapT]),q!==32879&&q!==35866||o.texParameteri(q,32882,J[Y.wrapR]),o.texParameteri(q,10240,re[Y.magFilter]),o.texParameteri(q,10241,re[Y.minFilter])):(o.texParameteri(q,10242,33071),o.texParameteri(q,10243,33071),q!==32879&&q!==35866||o.texParameteri(q,32882,33071),Y.wrapS===1001&&Y.wrapT===1001||console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),o.texParameteri(q,10240,G(Y.magFilter)),o.texParameteri(q,10241,G(Y.minFilter)),Y.minFilter!==1003&&Y.minFilter!==1006&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),e.has("EXT_texture_filter_anisotropic")===!0){const de=e.get("EXT_texture_filter_anisotropic");if(Y.type===1015&&e.has("OES_texture_float_linear")===!1||u===!1&&Y.type===1016&&e.has("OES_texture_half_float_linear")===!1)return;(Y.anisotropy>1||r.get(Y).__currentAnisotropy)&&(o.texParameterf(q,de.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(Y.anisotropy,i.getMaxAnisotropy())),r.get(Y).__currentAnisotropy=Y.anisotropy)}}function le(q,Y){q.__webglInit===void 0&&(q.__webglInit=!0,Y.addEventListener("dispose",U),q.__webglTexture=o.createTexture(),c.memory.textures++)}function Ce(q,Y,fe){let de=3553;Y.isDataTexture2DArray&&(de=35866),Y.isDataTexture3D&&(de=32879),le(q,Y),t.activeTexture(33984+fe),t.bindTexture(de,q.__webglTexture),o.pixelStorei(37440,Y.flipY),o.pixelStorei(37441,Y.premultiplyAlpha),o.pixelStorei(3317,Y.unpackAlignment),o.pixelStorei(37443,0);const oe=function(Ie){return!u&&(Ie.wrapS!==1001||Ie.wrapT!==1001||Ie.minFilter!==1003&&Ie.minFilter!==1006)}(Y)&&A(Y.image)===!1,Ve=M(Y.image,oe,!1,m),W=A(Ve)||u,K=a.convert(Y.format);let Q,ge=a.convert(Y.type),ve=N(Y.internalFormat,K,ge);ee(de,Y,W);const Me=Y.mipmaps;if(Y.isDepthTexture)ve=6402,u?ve=Y.type===1015?36012:Y.type===1014?33190:Y.type===1020?35056:33189:Y.type===1015&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),Y.format===1026&&ve===6402&&Y.type!==1012&&Y.type!==1014&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),Y.type=1012,ge=a.convert(Y.type)),Y.format===1027&&ve===6402&&(ve=34041,Y.type!==1020&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),Y.type=1020,ge=a.convert(Y.type))),t.texImage2D(3553,0,ve,Ve.width,Ve.height,0,K,ge,null);else if(Y.isDataTexture)if(Me.length>0&&W){for(let Ie=0,Xe=Me.length;Ie<Xe;Ie++)Q=Me[Ie],t.texImage2D(3553,Ie,ve,Q.width,Q.height,0,K,ge,Q.data);Y.generateMipmaps=!1,q.__maxMipLevel=Me.length-1}else t.texImage2D(3553,0,ve,Ve.width,Ve.height,0,K,ge,Ve.data),q.__maxMipLevel=0;else if(Y.isCompressedTexture){for(let Ie=0,Xe=Me.length;Ie<Xe;Ie++)Q=Me[Ie],Y.format!==1023&&Y.format!==1022?K!==null?t.compressedTexImage2D(3553,Ie,ve,Q.width,Q.height,0,Q.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):t.texImage2D(3553,Ie,ve,Q.width,Q.height,0,K,ge,Q.data);q.__maxMipLevel=Me.length-1}else if(Y.isDataTexture2DArray)t.texImage3D(35866,0,ve,Ve.width,Ve.height,Ve.depth,0,K,ge,Ve.data),q.__maxMipLevel=0;else if(Y.isDataTexture3D)t.texImage3D(32879,0,ve,Ve.width,Ve.height,Ve.depth,0,K,ge,Ve.data),q.__maxMipLevel=0;else if(Me.length>0&&W){for(let Ie=0,Xe=Me.length;Ie<Xe;Ie++)Q=Me[Ie],t.texImage2D(3553,Ie,ve,K,ge,Q);Y.generateMipmaps=!1,q.__maxMipLevel=Me.length-1}else t.texImage2D(3553,0,ve,K,ge,Ve),q.__maxMipLevel=0;I(Y,W)&&k(de,Y,Ve.width,Ve.height),q.__version=Y.version,Y.onUpdate&&Y.onUpdate(Y)}function Pe(q,Y,fe,de){const oe=Y.texture,Ve=a.convert(oe.format),W=a.convert(oe.type),K=N(oe.internalFormat,Ve,W);de===32879||de===35866?t.texImage3D(de,0,K,Y.width,Y.height,Y.depth,0,Ve,W,null):t.texImage2D(de,0,K,Y.width,Y.height,0,Ve,W,null),t.bindFramebuffer(36160,q),o.framebufferTexture2D(36160,fe,de,r.get(oe).__webglTexture,0),t.bindFramebuffer(36160,null)}function We(q,Y,fe){if(o.bindRenderbuffer(36161,q),Y.depthBuffer&&!Y.stencilBuffer){let de=33189;if(fe){const oe=Y.depthTexture;oe&&oe.isDepthTexture&&(oe.type===1015?de=36012:oe.type===1014&&(de=33190));const Ve=De(Y);o.renderbufferStorageMultisample(36161,Ve,de,Y.width,Y.height)}else o.renderbufferStorage(36161,de,Y.width,Y.height);o.framebufferRenderbuffer(36160,36096,36161,q)}else if(Y.depthBuffer&&Y.stencilBuffer){if(fe){const de=De(Y);o.renderbufferStorageMultisample(36161,de,35056,Y.width,Y.height)}else o.renderbufferStorage(36161,34041,Y.width,Y.height);o.framebufferRenderbuffer(36160,33306,36161,q)}else{const de=Y.texture,oe=a.convert(de.format),Ve=a.convert(de.type),W=N(de.internalFormat,oe,Ve);if(fe){const K=De(Y);o.renderbufferStorageMultisample(36161,K,W,Y.width,Y.height)}else o.renderbufferStorage(36161,W,Y.width,Y.height)}o.bindRenderbuffer(36161,null)}function Oe(q){const Y=r.get(q),fe=q.isWebGLCubeRenderTarget===!0;if(q.depthTexture){if(fe)throw new Error("target.depthTexture not supported in Cube render targets");(function(de,oe){if(oe&&oe.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(36160,de),!oe.depthTexture||!oe.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");r.get(oe.depthTexture).__webglTexture&&oe.depthTexture.image.width===oe.width&&oe.depthTexture.image.height===oe.height||(oe.depthTexture.image.width=oe.width,oe.depthTexture.image.height=oe.height,oe.depthTexture.needsUpdate=!0),he(oe.depthTexture,0);const Ve=r.get(oe.depthTexture).__webglTexture;if(oe.depthTexture.format===1026)o.framebufferTexture2D(36160,36096,3553,Ve,0);else{if(oe.depthTexture.format!==1027)throw new Error("Unknown depthTexture format");o.framebufferTexture2D(36160,33306,3553,Ve,0)}})(Y.__webglFramebuffer,q)}else if(fe){Y.__webglDepthbuffer=[];for(let de=0;de<6;de++)t.bindFramebuffer(36160,Y.__webglFramebuffer[de]),Y.__webglDepthbuffer[de]=o.createRenderbuffer(),We(Y.__webglDepthbuffer[de],q,!1)}else t.bindFramebuffer(36160,Y.__webglFramebuffer),Y.__webglDepthbuffer=o.createRenderbuffer(),We(Y.__webglDepthbuffer,q,!1);t.bindFramebuffer(36160,null)}function De(q){return u&&q.isWebGLMultisampleRenderTarget?Math.min(g,q.samples):0}let ze=!1,st=!1;this.allocateTextureUnit=function(){const q=V;return q>=h&&console.warn("THREE.WebGLTextures: Trying to use "+q+" texture units while this GPU supports only "+h),V+=1,q},this.resetTextureUnits=function(){V=0},this.setTexture2D=he,this.setTexture2DArray=function(q,Y){const fe=r.get(q);q.version>0&&fe.__version!==q.version?Ce(fe,q,Y):(t.activeTexture(33984+Y),t.bindTexture(35866,fe.__webglTexture))},this.setTexture3D=function(q,Y){const fe=r.get(q);q.version>0&&fe.__version!==q.version?Ce(fe,q,Y):(t.activeTexture(33984+Y),t.bindTexture(32879,fe.__webglTexture))},this.setTextureCube=Z,this.setupRenderTarget=function(q){const Y=q.texture,fe=r.get(q),de=r.get(Y);q.addEventListener("dispose",B),de.__webglTexture=o.createTexture(),de.__version=Y.version,c.memory.textures++;const oe=q.isWebGLCubeRenderTarget===!0,Ve=q.isWebGLMultisampleRenderTarget===!0,W=Y.isDataTexture3D||Y.isDataTexture2DArray,K=A(q)||u;if(!u||Y.format!==1022||Y.type!==1015&&Y.type!==1016||(Y.format=1023,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),oe){fe.__webglFramebuffer=[];for(let Q=0;Q<6;Q++)fe.__webglFramebuffer[Q]=o.createFramebuffer()}else if(fe.__webglFramebuffer=o.createFramebuffer(),Ve)if(u){fe.__webglMultisampledFramebuffer=o.createFramebuffer(),fe.__webglColorRenderbuffer=o.createRenderbuffer(),o.bindRenderbuffer(36161,fe.__webglColorRenderbuffer);const Q=a.convert(Y.format),ge=a.convert(Y.type),ve=N(Y.internalFormat,Q,ge),Me=De(q);o.renderbufferStorageMultisample(36161,Me,ve,q.width,q.height),t.bindFramebuffer(36160,fe.__webglMultisampledFramebuffer),o.framebufferRenderbuffer(36160,36064,36161,fe.__webglColorRenderbuffer),o.bindRenderbuffer(36161,null),q.depthBuffer&&(fe.__webglDepthRenderbuffer=o.createRenderbuffer(),We(fe.__webglDepthRenderbuffer,q,!0)),t.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(oe){t.bindTexture(34067,de.__webglTexture),ee(34067,Y,K);for(let Q=0;Q<6;Q++)Pe(fe.__webglFramebuffer[Q],q,36064,34069+Q);I(Y,K)&&k(34067,Y,q.width,q.height),t.bindTexture(34067,null)}else{let Q=3553;W&&(u?Q=Y.isDataTexture3D?32879:35866:console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")),t.bindTexture(Q,de.__webglTexture),ee(Q,Y,K),Pe(fe.__webglFramebuffer,q,36064,Q),I(Y,K)&&k(3553,Y,q.width,q.height),t.bindTexture(3553,null)}q.depthBuffer&&Oe(q)},this.updateRenderTargetMipmap=function(q){const Y=q.texture;if(I(Y,A(q)||u)){const fe=q.isWebGLCubeRenderTarget?34067:3553,de=r.get(Y).__webglTexture;t.bindTexture(fe,de),k(fe,Y,q.width,q.height),t.bindTexture(fe,null)}},this.updateMultisampleRenderTarget=function(q){if(q.isWebGLMultisampleRenderTarget)if(u){const Y=q.width,fe=q.height;let de=16384;q.depthBuffer&&(de|=256),q.stencilBuffer&&(de|=1024);const oe=r.get(q);t.bindFramebuffer(36008,oe.__webglMultisampledFramebuffer),t.bindFramebuffer(36009,oe.__webglFramebuffer),o.blitFramebuffer(0,0,Y,fe,0,0,Y,fe,de,9728),t.bindFramebuffer(36008,null),t.bindFramebuffer(36009,oe.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")},this.safeSetTexture2D=function(q,Y){q&&q.isWebGLRenderTarget&&(ze===!1&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),ze=!0),q=q.texture),he(q,Y)},this.safeSetTextureCube=function(q,Y){q&&q.isWebGLCubeRenderTarget&&(st===!1&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),st=!0),q=q.texture),Z(q,Y)}}function Np(o,e,t){const r=t.isWebGL2;return{convert:function(i){let a;if(i===1009)return 5121;if(i===1017)return 32819;if(i===1018)return 32820;if(i===1019)return 33635;if(i===1010)return 5120;if(i===1011)return 5122;if(i===1012)return 5123;if(i===1013)return 5124;if(i===1014)return 5125;if(i===1015)return 5126;if(i===1016)return r?5131:(a=e.get("OES_texture_half_float"),a!==null?a.HALF_FLOAT_OES:null);if(i===1021)return 6406;if(i===1022)return 6407;if(i===1023)return 6408;if(i===1024)return 6409;if(i===1025)return 6410;if(i===1026)return 6402;if(i===1027)return 34041;if(i===1028)return 6403;if(i===1029)return 36244;if(i===1030)return 33319;if(i===1031)return 33320;if(i===1032)return 36248;if(i===1033)return 36249;if(i===33776||i===33777||i===33778||i===33779){if(a=e.get("WEBGL_compressed_texture_s3tc"),a===null)return null;if(i===33776)return a.COMPRESSED_RGB_S3TC_DXT1_EXT;if(i===33777)return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(i===33778)return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(i===33779)return a.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(i===35840||i===35841||i===35842||i===35843){if(a=e.get("WEBGL_compressed_texture_pvrtc"),a===null)return null;if(i===35840)return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(i===35841)return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(i===35842)return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(i===35843)return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(i===36196)return a=e.get("WEBGL_compressed_texture_etc1"),a!==null?a.COMPRESSED_RGB_ETC1_WEBGL:null;if((i===37492||i===37496)&&(a=e.get("WEBGL_compressed_texture_etc"),a!==null)){if(i===37492)return a.COMPRESSED_RGB8_ETC2;if(i===37496)return a.COMPRESSED_RGBA8_ETC2_EAC}return i===37808||i===37809||i===37810||i===37811||i===37812||i===37813||i===37814||i===37815||i===37816||i===37817||i===37818||i===37819||i===37820||i===37821||i===37840||i===37841||i===37842||i===37843||i===37844||i===37845||i===37846||i===37847||i===37848||i===37849||i===37850||i===37851||i===37852||i===37853?(a=e.get("WEBGL_compressed_texture_astc"),a!==null?i:null):i===36492?(a=e.get("EXT_texture_compression_bptc"),a!==null?i:null):i===1020?r?34042:(a=e.get("WEBGL_depth_texture"),a!==null?a.UNSIGNED_INT_24_8_WEBGL:null):void 0}}}class fu extends gn{constructor(e=[]){super(),this.cameras=e}}fu.prototype.isArrayCamera=!0;class Ui extends yt{constructor(){super(),this.type="Group"}}Ui.prototype.isGroup=!0;const _x={type:"move"};class mu{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new Ui,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new Ui,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new O,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new O),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new Ui,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new O,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new O),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,t,r){let i=null,a=null,c=null;const u=this._targetRay,h=this._grip,p=this._hand;if(e&&t.session.visibilityState!=="visible-blurred")if(u!==null&&(i=t.getPose(e.targetRaySpace,r),i!==null&&(u.matrix.fromArray(i.transform.matrix),u.matrix.decompose(u.position,u.rotation,u.scale),i.linearVelocity?(u.hasLinearVelocity=!0,u.linearVelocity.copy(i.linearVelocity)):u.hasLinearVelocity=!1,i.angularVelocity?(u.hasAngularVelocity=!0,u.angularVelocity.copy(i.angularVelocity)):u.hasAngularVelocity=!1,this.dispatchEvent(_x))),p&&e.hand){c=!0;for(const S of e.hand.values()){const M=t.getJointPose(S,r);if(p.joints[S.jointName]===void 0){const I=new Ui;I.matrixAutoUpdate=!1,I.visible=!1,p.joints[S.jointName]=I,p.add(I)}const A=p.joints[S.jointName];M!==null&&(A.matrix.fromArray(M.transform.matrix),A.matrix.decompose(A.position,A.rotation,A.scale),A.jointRadius=M.radius),A.visible=M!==null}const m=p.joints["index-finger-tip"],g=p.joints["thumb-tip"],y=m.position.distanceTo(g.position),x=.02,b=.005;p.inputState.pinching&&y>x+b?(p.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!p.inputState.pinching&&y<=x-b&&(p.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else h!==null&&e.gripSpace&&(a=t.getPose(e.gripSpace,r),a!==null&&(h.matrix.fromArray(a.transform.matrix),h.matrix.decompose(h.position,h.rotation,h.scale),a.linearVelocity?(h.hasLinearVelocity=!0,h.linearVelocity.copy(a.linearVelocity)):h.hasLinearVelocity=!1,a.angularVelocity?(h.hasAngularVelocity=!0,h.angularVelocity.copy(a.angularVelocity)):h.hasAngularVelocity=!1));return u!==null&&(u.visible=i!==null),h!==null&&(h.visible=a!==null),p!==null&&(p.visible=c!==null),this}}class bx extends ce{constructor(e,t){super();const r=this,i=e.state;let a=null,c=1,u=null,h="local-floor",p=null;const m=[],g=new Map,y=new gn;y.layers.enable(1),y.viewport=new Dt;const x=new gn;x.layers.enable(2),x.viewport=new Dt;const b=[y,x],S=new fu;S.layers.enable(1),S.layers.enable(2);let M=null,A=null;function I(Z){const J=g.get(Z.inputSource);J&&J.dispatchEvent({type:Z.type,data:Z.inputSource})}function k(){g.forEach(function(Z,J){Z.disconnect(J)}),g.clear(),M=null,A=null,i.bindXRFramebuffer(null),e.setRenderTarget(e.getRenderTarget()),he.stop(),r.isPresenting=!1,r.dispatchEvent({type:"sessionend"})}function N(Z){const J=a.inputSources;for(let re=0;re<m.length;re++)g.set(J[re],m[re]);for(let re=0;re<Z.removed.length;re++){const ee=Z.removed[re],le=g.get(ee);le&&(le.dispatchEvent({type:"disconnected",data:ee}),g.delete(ee))}for(let re=0;re<Z.added.length;re++){const ee=Z.added[re],le=g.get(ee);le&&le.dispatchEvent({type:"connected",data:ee})}}this.enabled=!1,this.isPresenting=!1,this.getController=function(Z){let J=m[Z];return J===void 0&&(J=new mu,m[Z]=J),J.getTargetRaySpace()},this.getControllerGrip=function(Z){let J=m[Z];return J===void 0&&(J=new mu,m[Z]=J),J.getGripSpace()},this.getHand=function(Z){let J=m[Z];return J===void 0&&(J=new mu,m[Z]=J),J.getHandSpace()},this.setFramebufferScaleFactor=function(Z){c=Z,r.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(Z){h=Z,r.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return u},this.getSession=function(){return a},this.setSession=async function(Z){if(a=Z,a!==null){a.addEventListener("select",I),a.addEventListener("selectstart",I),a.addEventListener("selectend",I),a.addEventListener("squeeze",I),a.addEventListener("squeezestart",I),a.addEventListener("squeezeend",I),a.addEventListener("end",k),a.addEventListener("inputsourceschange",N);const J=t.getContextAttributes();J.xrCompatible!==!0&&await t.makeXRCompatible();const re={antialias:J.antialias,alpha:J.alpha,depth:J.depth,stencil:J.stencil,framebufferScaleFactor:c},ee=new XRWebGLLayer(a,t,re);a.updateRenderState({baseLayer:ee}),u=await a.requestReferenceSpace(h),he.setContext(a),he.start(),r.isPresenting=!0,r.dispatchEvent({type:"sessionstart"})}};const G=new O,U=new O;function B(Z,J){J===null?Z.matrixWorld.copy(Z.matrix):Z.matrixWorld.multiplyMatrices(J.matrixWorld,Z.matrix),Z.matrixWorldInverse.copy(Z.matrixWorld).invert()}this.getCamera=function(Z){S.near=x.near=y.near=Z.near,S.far=x.far=y.far=Z.far,M===S.near&&A===S.far||(a.updateRenderState({depthNear:S.near,depthFar:S.far}),M=S.near,A=S.far);const J=Z.parent,re=S.cameras;B(S,J);for(let le=0;le<re.length;le++)B(re[le],J);Z.matrixWorld.copy(S.matrixWorld),Z.matrix.copy(S.matrix),Z.matrix.decompose(Z.position,Z.quaternion,Z.scale);const ee=Z.children;for(let le=0,Ce=ee.length;le<Ce;le++)ee[le].updateMatrixWorld(!0);return re.length===2?function(le,Ce,Pe){G.setFromMatrixPosition(Ce.matrixWorld),U.setFromMatrixPosition(Pe.matrixWorld);const We=G.distanceTo(U),Oe=Ce.projectionMatrix.elements,De=Pe.projectionMatrix.elements,ze=Oe[14]/(Oe[10]-1),st=Oe[14]/(Oe[10]+1),q=(Oe[9]+1)/Oe[5],Y=(Oe[9]-1)/Oe[5],fe=(Oe[8]-1)/Oe[0],de=(De[8]+1)/De[0],oe=ze*fe,Ve=ze*de,W=We/(-fe+de),K=W*-fe;Ce.matrixWorld.decompose(le.position,le.quaternion,le.scale),le.translateX(K),le.translateZ(W),le.matrixWorld.compose(le.position,le.quaternion,le.scale),le.matrixWorldInverse.copy(le.matrixWorld).invert();const Q=ze+W,ge=st+W,ve=oe-K,Me=Ve+(We-K),Ie=q*st/ge*Q,Xe=Y*st/ge*Q;le.projectionMatrix.makePerspective(ve,Me,Ie,Xe,Q,ge)}(S,y,x):S.projectionMatrix.copy(y.projectionMatrix),S};let V=null;const he=new dp;he.setAnimationLoop(function(Z,J){if(p=J.getViewerPose(u),p!==null){const ee=p.views,le=a.renderState.baseLayer;i.bindXRFramebuffer(le.framebuffer);let Ce=!1;ee.length!==S.cameras.length&&(S.cameras.length=0,Ce=!0);for(let Pe=0;Pe<ee.length;Pe++){const We=ee[Pe],Oe=le.getViewport(We),De=b[Pe];De.matrix.fromArray(We.transform.matrix),De.projectionMatrix.fromArray(We.projectionMatrix),De.viewport.set(Oe.x,Oe.y,Oe.width,Oe.height),Pe===0&&S.matrix.copy(De.matrix),Ce===!0&&S.cameras.push(De)}}const re=a.inputSources;for(let ee=0;ee<m.length;ee++){const le=m[ee],Ce=re[ee];le.update(Ce,J,u)}V&&V(Z,J)}),this.setAnimationLoop=function(Z){V=Z},this.dispose=function(){}}}function wx(o){function e(r,i){r.opacity.value=i.opacity,i.color&&r.diffuse.value.copy(i.color),i.emissive&&r.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity),i.map&&(r.map.value=i.map),i.alphaMap&&(r.alphaMap.value=i.alphaMap),i.specularMap&&(r.specularMap.value=i.specularMap);const a=o.get(i).envMap;if(a){r.envMap.value=a,r.flipEnvMap.value=a.isCubeTexture&&a._needsFlipEnvMap?-1:1,r.reflectivity.value=i.reflectivity,r.refractionRatio.value=i.refractionRatio;const h=o.get(a).__maxMipLevel;h!==void 0&&(r.maxMipLevel.value=h)}let c,u;i.lightMap&&(r.lightMap.value=i.lightMap,r.lightMapIntensity.value=i.lightMapIntensity),i.aoMap&&(r.aoMap.value=i.aoMap,r.aoMapIntensity.value=i.aoMapIntensity),i.map?c=i.map:i.specularMap?c=i.specularMap:i.displacementMap?c=i.displacementMap:i.normalMap?c=i.normalMap:i.bumpMap?c=i.bumpMap:i.roughnessMap?c=i.roughnessMap:i.metalnessMap?c=i.metalnessMap:i.alphaMap?c=i.alphaMap:i.emissiveMap?c=i.emissiveMap:i.clearcoatMap?c=i.clearcoatMap:i.clearcoatNormalMap?c=i.clearcoatNormalMap:i.clearcoatRoughnessMap&&(c=i.clearcoatRoughnessMap),c!==void 0&&(c.isWebGLRenderTarget&&(c=c.texture),c.matrixAutoUpdate===!0&&c.updateMatrix(),r.uvTransform.value.copy(c.matrix)),i.aoMap?u=i.aoMap:i.lightMap&&(u=i.lightMap),u!==void 0&&(u.isWebGLRenderTarget&&(u=u.texture),u.matrixAutoUpdate===!0&&u.updateMatrix(),r.uv2Transform.value.copy(u.matrix))}function t(r,i){r.roughness.value=i.roughness,r.metalness.value=i.metalness,i.roughnessMap&&(r.roughnessMap.value=i.roughnessMap),i.metalnessMap&&(r.metalnessMap.value=i.metalnessMap),i.emissiveMap&&(r.emissiveMap.value=i.emissiveMap),i.bumpMap&&(r.bumpMap.value=i.bumpMap,r.bumpScale.value=i.bumpScale,i.side===1&&(r.bumpScale.value*=-1)),i.normalMap&&(r.normalMap.value=i.normalMap,r.normalScale.value.copy(i.normalScale),i.side===1&&r.normalScale.value.negate()),i.displacementMap&&(r.displacementMap.value=i.displacementMap,r.displacementScale.value=i.displacementScale,r.displacementBias.value=i.displacementBias),o.get(i).envMap&&(r.envMapIntensity.value=i.envMapIntensity)}return{refreshFogUniforms:function(r,i){r.fogColor.value.copy(i.color),i.isFog?(r.fogNear.value=i.near,r.fogFar.value=i.far):i.isFogExp2&&(r.fogDensity.value=i.density)},refreshMaterialUniforms:function(r,i,a,c){i.isMeshBasicMaterial?e(r,i):i.isMeshLambertMaterial?(e(r,i),function(u,h){h.emissiveMap&&(u.emissiveMap.value=h.emissiveMap)}(r,i)):i.isMeshToonMaterial?(e(r,i),function(u,h){h.gradientMap&&(u.gradientMap.value=h.gradientMap),h.emissiveMap&&(u.emissiveMap.value=h.emissiveMap),h.bumpMap&&(u.bumpMap.value=h.bumpMap,u.bumpScale.value=h.bumpScale,h.side===1&&(u.bumpScale.value*=-1)),h.normalMap&&(u.normalMap.value=h.normalMap,u.normalScale.value.copy(h.normalScale),h.side===1&&u.normalScale.value.negate()),h.displacementMap&&(u.displacementMap.value=h.displacementMap,u.displacementScale.value=h.displacementScale,u.displacementBias.value=h.displacementBias)}(r,i)):i.isMeshPhongMaterial?(e(r,i),function(u,h){u.specular.value.copy(h.specular),u.shininess.value=Math.max(h.shininess,1e-4),h.emissiveMap&&(u.emissiveMap.value=h.emissiveMap),h.bumpMap&&(u.bumpMap.value=h.bumpMap,u.bumpScale.value=h.bumpScale,h.side===1&&(u.bumpScale.value*=-1)),h.normalMap&&(u.normalMap.value=h.normalMap,u.normalScale.value.copy(h.normalScale),h.side===1&&u.normalScale.value.negate()),h.displacementMap&&(u.displacementMap.value=h.displacementMap,u.displacementScale.value=h.displacementScale,u.displacementBias.value=h.displacementBias)}(r,i)):i.isMeshStandardMaterial?(e(r,i),i.isMeshPhysicalMaterial?function(u,h){t(u,h),u.reflectivity.value=h.reflectivity,u.clearcoat.value=h.clearcoat,u.clearcoatRoughness.value=h.clearcoatRoughness,h.sheen&&u.sheen.value.copy(h.sheen),h.clearcoatMap&&(u.clearcoatMap.value=h.clearcoatMap),h.clearcoatRoughnessMap&&(u.clearcoatRoughnessMap.value=h.clearcoatRoughnessMap),h.clearcoatNormalMap&&(u.clearcoatNormalScale.value.copy(h.clearcoatNormalScale),u.clearcoatNormalMap.value=h.clearcoatNormalMap,h.side===1&&u.clearcoatNormalScale.value.negate()),u.transmission.value=h.transmission,h.transmissionMap&&(u.transmissionMap.value=h.transmissionMap)}(r,i):t(r,i)):i.isMeshMatcapMaterial?(e(r,i),function(u,h){h.matcap&&(u.matcap.value=h.matcap),h.bumpMap&&(u.bumpMap.value=h.bumpMap,u.bumpScale.value=h.bumpScale,h.side===1&&(u.bumpScale.value*=-1)),h.normalMap&&(u.normalMap.value=h.normalMap,u.normalScale.value.copy(h.normalScale),h.side===1&&u.normalScale.value.negate()),h.displacementMap&&(u.displacementMap.value=h.displacementMap,u.displacementScale.value=h.displacementScale,u.displacementBias.value=h.displacementBias)}(r,i)):i.isMeshDepthMaterial?(e(r,i),function(u,h){h.displacementMap&&(u.displacementMap.value=h.displacementMap,u.displacementScale.value=h.displacementScale,u.displacementBias.value=h.displacementBias)}(r,i)):i.isMeshDistanceMaterial?(e(r,i),function(u,h){h.displacementMap&&(u.displacementMap.value=h.displacementMap,u.displacementScale.value=h.displacementScale,u.displacementBias.value=h.displacementBias),u.referencePosition.value.copy(h.referencePosition),u.nearDistance.value=h.nearDistance,u.farDistance.value=h.farDistance}(r,i)):i.isMeshNormalMaterial?(e(r,i),function(u,h){h.bumpMap&&(u.bumpMap.value=h.bumpMap,u.bumpScale.value=h.bumpScale,h.side===1&&(u.bumpScale.value*=-1)),h.normalMap&&(u.normalMap.value=h.normalMap,u.normalScale.value.copy(h.normalScale),h.side===1&&u.normalScale.value.negate()),h.displacementMap&&(u.displacementMap.value=h.displacementMap,u.displacementScale.value=h.displacementScale,u.displacementBias.value=h.displacementBias)}(r,i)):i.isLineBasicMaterial?(function(u,h){u.diffuse.value.copy(h.color),u.opacity.value=h.opacity}(r,i),i.isLineDashedMaterial&&function(u,h){u.dashSize.value=h.dashSize,u.totalSize.value=h.dashSize+h.gapSize,u.scale.value=h.scale}(r,i)):i.isPointsMaterial?function(u,h,p,m){u.diffuse.value.copy(h.color),u.opacity.value=h.opacity,u.size.value=h.size*p,u.scale.value=.5*m,h.map&&(u.map.value=h.map),h.alphaMap&&(u.alphaMap.value=h.alphaMap);let g;h.map?g=h.map:h.alphaMap&&(g=h.alphaMap),g!==void 0&&(g.matrixAutoUpdate===!0&&g.updateMatrix(),u.uvTransform.value.copy(g.matrix))}(r,i,a,c):i.isSpriteMaterial?function(u,h){u.diffuse.value.copy(h.color),u.opacity.value=h.opacity,u.rotation.value=h.rotation,h.map&&(u.map.value=h.map),h.alphaMap&&(u.alphaMap.value=h.alphaMap);let p;h.map?p=h.map:h.alphaMap&&(p=h.alphaMap),p!==void 0&&(p.matrixAutoUpdate===!0&&p.updateMatrix(),u.uvTransform.value.copy(p.matrix))}(r,i):i.isShadowMaterial?(r.color.value.copy(i.color),r.opacity.value=i.opacity):i.isShaderMaterial&&(i.uniformsNeedUpdate=!1)}}}function Ut(o){const e=(o=o||{}).canvas!==void 0?o.canvas:function(){const H=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");return H.style.display="block",H}(),t=o.context!==void 0?o.context:null,r=o.alpha!==void 0&&o.alpha,i=o.depth===void 0||o.depth,a=o.stencil===void 0||o.stencil,c=o.antialias!==void 0&&o.antialias,u=o.premultipliedAlpha===void 0||o.premultipliedAlpha,h=o.preserveDrawingBuffer!==void 0&&o.preserveDrawingBuffer,p=o.powerPreference!==void 0?o.powerPreference:"default",m=o.failIfMajorPerformanceCaveat!==void 0&&o.failIfMajorPerformanceCaveat;let g=null,y=null;const x=[],b=[];this.domElement=e,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=3e3,this.physicallyCorrectLights=!1,this.toneMapping=0,this.toneMappingExposure=1;const S=this;let M=!1,A=0,I=0,k=null,N=-1,G=null;const U=new Dt,B=new Dt;let V=null,he=e.width,Z=e.height,J=1,re=null,ee=null;const le=new Dt(0,0,he,Z),Ce=new Dt(0,0,he,Z);let Pe=!1;const We=new mo;let Oe=!1,De=!1;const ze=new Ze,st=new O,q={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function Y(){return k===null?J:1}let fe,de,oe,Ve,W,K,Q,ge,ve,Me,Ie,Xe,ht,je,rt,wt,Pr,Ir,Wo,jo,qn,Mn,Ae=t;function wm(H,ye){for(let te=0;te<H.length;te++){const me=H[te],ke=e.getContext(me,ye);if(ke!==null)return ke}return null}try{const H={alpha:r,depth:i,stencil:a,antialias:c,premultipliedAlpha:u,preserveDrawingBuffer:h,powerPreference:p,failIfMajorPerformanceCaveat:m};if(e.addEventListener("webglcontextlost",Sm,!1),e.addEventListener("webglcontextrestored",Em,!1),Ae===null){const ye=["webgl2","webgl","experimental-webgl"];if(S.isWebGL1Renderer===!0&&ye.shift(),Ae=wm(ye,H),Ae===null)throw wm(ye)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}Ae.getShaderPrecisionFormat===void 0&&(Ae.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(H){throw console.error("THREE.WebGLRenderer: "+H.message),H}function Mm(){fe=new s0(Ae),de=new n0(Ae,fe,o),fe.init(de),qn=new Np(Ae,fe,de),oe=new yx(Ae,fe,de),Ve=new l0,W=new cx,K=new xx(Ae,fe,oe,W,de,qn,Ve),Q=new i0(S),ge=new Jy(Ae,de),Mn=new e0(Ae,fe,ge,de),ve=new o0(Ae,ge,Ve,Mn),Me=new d0(Ae,ve,ge,Ve),Ir=new h0(Ae),rt=new r0(W),Ie=new lx(S,Q,fe,de,Mn,rt),Xe=new wx(W),ht=new dx(W),je=new vx(fe,de),Pr=new Qy(S,Q,oe,Me,u),wt=new Dp(S,Me,de),Wo=new t0(Ae,fe,Ve,de),jo=new a0(Ae,fe,Ve,de),Ve.programs=Ie.programs,S.capabilities=de,S.extensions=fe,S.properties=W,S.renderLists=ht,S.shadowMap=wt,S.state=oe,S.info=Ve}Mm();const vr=new bx(S,Ae);function Sm(H){H.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),M=!0}function Em(){console.log("THREE.WebGLRenderer: Context Restored."),M=!1;const H=Ve.autoReset,ye=wt.enabled,te=wt.autoUpdate,me=wt.needsUpdate,ke=wt.type;Mm(),Ve.autoReset=H,wt.enabled=ye,wt.autoUpdate=te,wt.needsUpdate=me,wt.type=ke}function Tm(H){const ye=H.target;ye.removeEventListener("dispose",Tm),function(te){(function(me){const ke=W.get(me).programs;ke!==void 0&&ke.forEach(function(mt){Ie.releaseProgram(mt)})})(te),W.remove(te)}(ye)}this.xr=vr,this.getContext=function(){return Ae},this.getContextAttributes=function(){return Ae.getContextAttributes()},this.forceContextLoss=function(){const H=fe.get("WEBGL_lose_context");H&&H.loseContext()},this.forceContextRestore=function(){const H=fe.get("WEBGL_lose_context");H&&H.restoreContext()},this.getPixelRatio=function(){return J},this.setPixelRatio=function(H){H!==void 0&&(J=H,this.setSize(he,Z,!1))},this.getSize=function(H){return H===void 0&&(console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"),H=new Ee),H.set(he,Z)},this.setSize=function(H,ye,te){vr.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(he=H,Z=ye,e.width=Math.floor(H*J),e.height=Math.floor(ye*J),te!==!1&&(e.style.width=H+"px",e.style.height=ye+"px"),this.setViewport(0,0,H,ye))},this.getDrawingBufferSize=function(H){return H===void 0&&(console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),H=new Ee),H.set(he*J,Z*J).floor()},this.setDrawingBufferSize=function(H,ye,te){he=H,Z=ye,J=te,e.width=Math.floor(H*te),e.height=Math.floor(ye*te),this.setViewport(0,0,H,ye)},this.getCurrentViewport=function(H){return H===void 0&&(console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"),H=new Dt),H.copy(U)},this.getViewport=function(H){return H.copy(le)},this.setViewport=function(H,ye,te,me){H.isVector4?le.set(H.x,H.y,H.z,H.w):le.set(H,ye,te,me),oe.viewport(U.copy(le).multiplyScalar(J).floor())},this.getScissor=function(H){return H.copy(Ce)},this.setScissor=function(H,ye,te,me){H.isVector4?Ce.set(H.x,H.y,H.z,H.w):Ce.set(H,ye,te,me),oe.scissor(B.copy(Ce).multiplyScalar(J).floor())},this.getScissorTest=function(){return Pe},this.setScissorTest=function(H){oe.setScissorTest(Pe=H)},this.setOpaqueSort=function(H){re=H},this.setTransparentSort=function(H){ee=H},this.getClearColor=function(H){return H===void 0&&(console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"),H=new Ge),H.copy(Pr.getClearColor())},this.setClearColor=function(){Pr.setClearColor.apply(Pr,arguments)},this.getClearAlpha=function(){return Pr.getClearAlpha()},this.setClearAlpha=function(){Pr.setClearAlpha.apply(Pr,arguments)},this.clear=function(H,ye,te){let me=0;(H===void 0||H)&&(me|=16384),(ye===void 0||ye)&&(me|=256),(te===void 0||te)&&(me|=1024),Ae.clear(me)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",Sm,!1),e.removeEventListener("webglcontextrestored",Em,!1),ht.dispose(),je.dispose(),W.dispose(),Q.dispose(),Me.dispose(),Mn.dispose(),vr.dispose(),vr.removeEventListener("sessionstart",Am),vr.removeEventListener("sessionend",Rm),Ji.stop()},this.renderBufferImmediate=function(H,ye){Mn.initAttributes();const te=W.get(H);H.hasPositions&&!te.position&&(te.position=Ae.createBuffer()),H.hasNormals&&!te.normal&&(te.normal=Ae.createBuffer()),H.hasUvs&&!te.uv&&(te.uv=Ae.createBuffer()),H.hasColors&&!te.color&&(te.color=Ae.createBuffer());const me=ye.getAttributes();H.hasPositions&&(Ae.bindBuffer(34962,te.position),Ae.bufferData(34962,H.positionArray,35048),Mn.enableAttribute(me.position),Ae.vertexAttribPointer(me.position,3,5126,!1,0,0)),H.hasNormals&&(Ae.bindBuffer(34962,te.normal),Ae.bufferData(34962,H.normalArray,35048),Mn.enableAttribute(me.normal),Ae.vertexAttribPointer(me.normal,3,5126,!1,0,0)),H.hasUvs&&(Ae.bindBuffer(34962,te.uv),Ae.bufferData(34962,H.uvArray,35048),Mn.enableAttribute(me.uv),Ae.vertexAttribPointer(me.uv,2,5126,!1,0,0)),H.hasColors&&(Ae.bindBuffer(34962,te.color),Ae.bufferData(34962,H.colorArray,35048),Mn.enableAttribute(me.color),Ae.vertexAttribPointer(me.color,3,5126,!1,0,0)),Mn.disableUnusedAttributes(),Ae.drawArrays(4,0,H.count),H.count=0},this.renderBufferDirect=function(H,ye,te,me,ke,mt){ye===null&&(ye=q);const dt=ke.isMesh&&ke.matrixWorld.determinant()<0,bt=Om(H,ye,me,ke);oe.setMaterial(me,dt);let Nt=te.index;const ft=te.attributes.position;if(Nt===null){if(ft===void 0||ft.count===0)return}else if(Nt.count===0)return;let kt,ut=1;me.wireframe===!0&&(Nt=ve.getWireframeAttribute(te),ut=2),(me.morphTargets||me.morphNormals)&&Ir.update(ke,te,me,bt),Mn.setup(ke,me,bt,te,Nt);let jt=Wo;Nt!==null&&(kt=ge.get(Nt),jt=jo,jt.setIndex(kt));const Or=Nt!==null?Nt.count:ft.count,Xt=te.drawRange.start*ut,Qi=te.drawRange.count*ut,hn=mt!==null?mt.start*ut:0,es=mt!==null?mt.count*ut:1/0,kn=Math.max(Xt,hn),er=Math.min(Or,Xt+Qi,hn+es)-1,on=Math.max(0,er-kn+1);if(on!==0){if(ke.isMesh)me.wireframe===!0?(oe.setLineWidth(me.wireframeLinewidth*Y()),jt.setMode(1)):jt.setMode(4);else if(ke.isLine){let ts=me.linewidth;ts===void 0&&(ts=1),oe.setLineWidth(ts*Y()),ke.isLineSegments?jt.setMode(1):ke.isLineLoop?jt.setMode(2):jt.setMode(3)}else ke.isPoints?jt.setMode(0):ke.isSprite&&jt.setMode(4);if(ke.isInstancedMesh)jt.renderInstances(kn,on,ke.count);else if(te.isInstancedBufferGeometry){const ts=Math.min(te.instanceCount,te._maxInstanceCount);jt.renderInstances(kn,on,ts)}else jt.render(kn,on)}},this.compile=function(H,ye){y=je.get(H),y.init(),H.traverseVisible(function(te){te.isLight&&te.layers.test(ye.layers)&&(y.pushLight(te),te.castShadow&&y.pushShadow(te))}),y.setupLights(),H.traverse(function(te){const me=te.material;if(me)if(Array.isArray(me))for(let ke=0;ke<me.length;ke++)vh(me[ke],H,te);else vh(me,H,te)})};let gh=null;function Am(){Ji.stop()}function Rm(){Ji.start()}const Ji=new dp;function Lm(H,ye,te,me){if(H.visible===!1)return;if(H.layers.test(ye.layers)){if(H.isGroup)te=H.renderOrder;else if(H.isLOD)H.autoUpdate===!0&&H.update(ye);else if(H.isLight)y.pushLight(H),H.castShadow&&y.pushShadow(H);else if(H.isSprite){if(!H.frustumCulled||We.intersectsSprite(H)){me&&st.setFromMatrixPosition(H.matrixWorld).applyMatrix4(ze);const mt=Me.update(H),dt=H.material;dt.visible&&g.push(H,mt,dt,te,st.z,null)}}else if(H.isImmediateRenderObject)me&&st.setFromMatrixPosition(H.matrixWorld).applyMatrix4(ze),g.push(H,null,H.material,te,st.z,null);else if((H.isMesh||H.isLine||H.isPoints)&&(H.isSkinnedMesh&&H.skeleton.frame!==Ve.render.frame&&(H.skeleton.update(),H.skeleton.frame=Ve.render.frame),!H.frustumCulled||We.intersectsObject(H))){me&&st.setFromMatrixPosition(H.matrixWorld).applyMatrix4(ze);const mt=Me.update(H),dt=H.material;if(Array.isArray(dt)){const bt=mt.groups;for(let Nt=0,ft=bt.length;Nt<ft;Nt++){const kt=bt[Nt],ut=dt[kt.materialIndex];ut&&ut.visible&&g.push(H,mt,ut,te,st.z,kt)}}else dt.visible&&g.push(H,mt,dt,te,st.z,null)}}const ke=H.children;for(let mt=0,dt=ke.length;mt<dt;mt++)Lm(ke[mt],ye,te,me)}function Cm(H,ye,te){const me=ye.isScene===!0?ye.overrideMaterial:null;for(let ke=0,mt=H.length;ke<mt;ke++){const dt=H[ke],bt=dt.object,Nt=dt.geometry,ft=me===null?dt.material:me,kt=dt.group;if(te.isArrayCamera){const ut=te.cameras;for(let jt=0,Or=ut.length;jt<Or;jt++){const Xt=ut[jt];bt.layers.test(Xt.layers)&&(oe.viewport(U.copy(Xt.viewport)),y.setupLightsView(Xt),Pm(bt,ye,Xt,Nt,ft,kt))}}else Pm(bt,ye,te,Nt,ft,kt)}}function Pm(H,ye,te,me,ke,mt){if(H.onBeforeRender(S,ye,te,me,ke,mt),H.modelViewMatrix.multiplyMatrices(te.matrixWorldInverse,H.matrixWorld),H.normalMatrix.getNormalMatrix(H.modelViewMatrix),H.isImmediateRenderObject){const dt=Om(te,ye,ke,H);oe.setMaterial(ke),Mn.reset(),function(bt,Nt){bt.render(function(ft){S.renderBufferImmediate(ft,Nt)})}(H,dt)}else S.renderBufferDirect(te,ye,me,ke,H,mt);H.onAfterRender(S,ye,te,me,ke,mt)}function vh(H,ye,te){ye.isScene!==!0&&(ye=q);const me=W.get(H),ke=y.state.lights,mt=y.state.shadowsArray,dt=ke.state.version,bt=Ie.getParameters(H,ke.state,mt,ye,te),Nt=Ie.getProgramCacheKey(bt);let ft=me.programs;me.environment=H.isMeshStandardMaterial?ye.environment:null,me.fog=ye.fog,me.envMap=Q.get(H.envMap||me.environment),ft===void 0&&(H.addEventListener("dispose",Tm),ft=new Map,me.programs=ft);let kt=ft.get(Nt);if(kt!==void 0){if(me.currentProgram===kt&&me.lightsStateVersion===dt)return Im(H,bt),kt}else bt.uniforms=Ie.getUniforms(H),H.onBuild(bt,S),H.onBeforeCompile(bt,S),kt=Ie.acquireProgram(bt,Nt),ft.set(Nt,kt),me.uniforms=bt.uniforms;const ut=me.uniforms;(H.isShaderMaterial||H.isRawShaderMaterial)&&H.clipping!==!0||(ut.clippingPlanes=rt.uniform),Im(H,bt),me.needsLights=function(Xt){return Xt.isMeshLambertMaterial||Xt.isMeshToonMaterial||Xt.isMeshPhongMaterial||Xt.isMeshStandardMaterial||Xt.isShadowMaterial||Xt.isShaderMaterial&&Xt.lights===!0}(H),me.lightsStateVersion=dt,me.needsLights&&(ut.ambientLightColor.value=ke.state.ambient,ut.lightProbe.value=ke.state.probe,ut.directionalLights.value=ke.state.directional,ut.directionalLightShadows.value=ke.state.directionalShadow,ut.spotLights.value=ke.state.spot,ut.spotLightShadows.value=ke.state.spotShadow,ut.rectAreaLights.value=ke.state.rectArea,ut.ltc_1.value=ke.state.rectAreaLTC1,ut.ltc_2.value=ke.state.rectAreaLTC2,ut.pointLights.value=ke.state.point,ut.pointLightShadows.value=ke.state.pointShadow,ut.hemisphereLights.value=ke.state.hemi,ut.directionalShadowMap.value=ke.state.directionalShadowMap,ut.directionalShadowMatrix.value=ke.state.directionalShadowMatrix,ut.spotShadowMap.value=ke.state.spotShadowMap,ut.spotShadowMatrix.value=ke.state.spotShadowMatrix,ut.pointShadowMap.value=ke.state.pointShadowMap,ut.pointShadowMatrix.value=ke.state.pointShadowMatrix);const jt=kt.getUniforms(),Or=bi.seqWithValue(jt.seq,ut);return me.currentProgram=kt,me.uniformsList=Or,kt}function Im(H,ye){const te=W.get(H);te.outputEncoding=ye.outputEncoding,te.instancing=ye.instancing,te.numClippingPlanes=ye.numClippingPlanes,te.numIntersection=ye.numClipIntersection,te.vertexAlphas=ye.vertexAlphas}function Om(H,ye,te,me){ye.isScene!==!0&&(ye=q),K.resetTextureUnits();const ke=ye.fog,mt=te.isMeshStandardMaterial?ye.environment:null,dt=k===null?S.outputEncoding:k.texture.encoding,bt=Q.get(te.envMap||mt),Nt=te.vertexColors===!0&&me.geometry&&me.geometry.attributes.color&&me.geometry.attributes.color.itemSize===4,ft=W.get(te),kt=y.state.lights;if(Oe===!0&&(De===!0||H!==G)){const on=H===G&&te.id===N;rt.setState(te,H,on)}let ut=!1;te.version===ft.__version?ft.needsLights&&ft.lightsStateVersion!==kt.state.version||ft.outputEncoding!==dt||me.isInstancedMesh&&ft.instancing===!1?ut=!0:me.isInstancedMesh||ft.instancing!==!0?ft.envMap!==bt||te.fog&&ft.fog!==ke?ut=!0:ft.numClippingPlanes===void 0||ft.numClippingPlanes===rt.numPlanes&&ft.numIntersection===rt.numIntersection?ft.vertexAlphas!==Nt&&(ut=!0):ut=!0:ut=!0:(ut=!0,ft.__version=te.version);let jt=ft.currentProgram;ut===!0&&(jt=vh(te,ye,me));let Or=!1,Xt=!1,Qi=!1;const hn=jt.getUniforms(),es=ft.uniforms;if(oe.useProgram(jt.program)&&(Or=!0,Xt=!0,Qi=!0),te.id!==N&&(N=te.id,Xt=!0),Or||G!==H){if(hn.setValue(Ae,"projectionMatrix",H.projectionMatrix),de.logarithmicDepthBuffer&&hn.setValue(Ae,"logDepthBufFC",2/(Math.log(H.far+1)/Math.LN2)),G!==H&&(G=H,Xt=!0,Qi=!0),te.isShaderMaterial||te.isMeshPhongMaterial||te.isMeshToonMaterial||te.isMeshStandardMaterial||te.envMap){const on=hn.map.cameraPosition;on!==void 0&&on.setValue(Ae,st.setFromMatrixPosition(H.matrixWorld))}(te.isMeshPhongMaterial||te.isMeshToonMaterial||te.isMeshLambertMaterial||te.isMeshBasicMaterial||te.isMeshStandardMaterial||te.isShaderMaterial)&&hn.setValue(Ae,"isOrthographic",H.isOrthographicCamera===!0),(te.isMeshPhongMaterial||te.isMeshToonMaterial||te.isMeshLambertMaterial||te.isMeshBasicMaterial||te.isMeshStandardMaterial||te.isShaderMaterial||te.isShadowMaterial||te.skinning)&&hn.setValue(Ae,"viewMatrix",H.matrixWorldInverse)}if(te.skinning){hn.setOptional(Ae,me,"bindMatrix"),hn.setOptional(Ae,me,"bindMatrixInverse");const on=me.skeleton;if(on){const ts=on.bones;if(de.floatVertexTextures){if(on.boneTexture===null){let ti=Math.sqrt(4*ts.length);ti=Zn(ti),ti=Math.max(ti,4);const yh=new Float32Array(ti*ti*4);yh.set(on.boneMatrices);const i_=new Os(yh,ti,ti,1023,1015);on.boneMatrices=yh,on.boneTexture=i_,on.boneTextureSize=ti}hn.setValue(Ae,"boneTexture",on.boneTexture,K),hn.setValue(Ae,"boneTextureSize",on.boneTextureSize)}else hn.setOptional(Ae,on,"boneMatrices")}}var kn,er;return(Xt||ft.receiveShadow!==me.receiveShadow)&&(ft.receiveShadow=me.receiveShadow,hn.setValue(Ae,"receiveShadow",me.receiveShadow)),Xt&&(hn.setValue(Ae,"toneMappingExposure",S.toneMappingExposure),ft.needsLights&&(er=Qi,(kn=es).ambientLightColor.needsUpdate=er,kn.lightProbe.needsUpdate=er,kn.directionalLights.needsUpdate=er,kn.directionalLightShadows.needsUpdate=er,kn.pointLights.needsUpdate=er,kn.pointLightShadows.needsUpdate=er,kn.spotLights.needsUpdate=er,kn.spotLightShadows.needsUpdate=er,kn.rectAreaLights.needsUpdate=er,kn.hemisphereLights.needsUpdate=er),ke&&te.fog&&Xe.refreshFogUniforms(es,ke),Xe.refreshMaterialUniforms(es,te,J,Z),bi.upload(Ae,ft.uniformsList,es,K)),te.isShaderMaterial&&te.uniformsNeedUpdate===!0&&(bi.upload(Ae,ft.uniformsList,es,K),te.uniformsNeedUpdate=!1),te.isSpriteMaterial&&hn.setValue(Ae,"center",me.center),hn.setValue(Ae,"modelViewMatrix",me.modelViewMatrix),hn.setValue(Ae,"normalMatrix",me.normalMatrix),hn.setValue(Ae,"modelMatrix",me.matrixWorld),jt}Ji.setAnimationLoop(function(H){gh&&gh(H)}),typeof window<"u"&&Ji.setContext(window),this.setAnimationLoop=function(H){gh=H,vr.setAnimationLoop(H),H===null?Ji.stop():Ji.start()},vr.addEventListener("sessionstart",Am),vr.addEventListener("sessionend",Rm),this.render=function(H,ye){let te,me;if(arguments[2]!==void 0&&(console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."),te=arguments[2]),arguments[3]!==void 0&&(console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."),me=arguments[3]),ye!==void 0&&ye.isCamera!==!0)return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");if(M===!0)return;H.autoUpdate===!0&&H.updateMatrixWorld(),ye.parent===null&&ye.updateMatrixWorld(),vr.enabled===!0&&vr.isPresenting===!0&&(ye=vr.getCamera(ye)),H.isScene===!0&&H.onBeforeRender(S,H,ye,te||k),y=je.get(H,b.length),y.init(),b.push(y),ze.multiplyMatrices(ye.projectionMatrix,ye.matrixWorldInverse),We.setFromProjectionMatrix(ze),De=this.localClippingEnabled,Oe=rt.init(this.clippingPlanes,De,ye),g=ht.get(H,x.length),g.init(),x.push(g),Lm(H,ye,0,S.sortObjects),g.finish(),S.sortObjects===!0&&g.sort(re,ee),Oe===!0&&rt.beginShadows();const ke=y.state.shadowsArray;wt.render(ke,H,ye),y.setupLights(),y.setupLightsView(ye),Oe===!0&&rt.endShadows(),this.info.autoReset===!0&&this.info.reset(),te!==void 0&&this.setRenderTarget(te),Pr.render(g,H,ye,me);const mt=g.opaque,dt=g.transparent;mt.length>0&&Cm(mt,H,ye),dt.length>0&&Cm(dt,H,ye),k!==null&&(K.updateRenderTargetMipmap(k),K.updateMultisampleRenderTarget(k)),H.isScene===!0&&H.onAfterRender(S,H,ye),oe.buffers.depth.setTest(!0),oe.buffers.depth.setMask(!0),oe.buffers.color.setMask(!0),oe.setPolygonOffset(!1),Mn.resetDefaultState(),N=-1,G=null,b.pop(),y=b.length>0?b[b.length-1]:null,x.pop(),g=x.length>0?x[x.length-1]:null},this.getActiveCubeFace=function(){return A},this.getActiveMipmapLevel=function(){return I},this.getRenderTarget=function(){return k},this.setRenderTarget=function(H,ye=0,te=0){k=H,A=ye,I=te,H&&W.get(H).__webglFramebuffer===void 0&&K.setupRenderTarget(H);let me=null,ke=!1,mt=!1;if(H){const dt=H.texture;(dt.isDataTexture3D||dt.isDataTexture2DArray)&&(mt=!0);const bt=W.get(H).__webglFramebuffer;H.isWebGLCubeRenderTarget?(me=bt[ye],ke=!0):me=H.isWebGLMultisampleRenderTarget?W.get(H).__webglMultisampledFramebuffer:bt,U.copy(H.viewport),B.copy(H.scissor),V=H.scissorTest}else U.copy(le).multiplyScalar(J).floor(),B.copy(Ce).multiplyScalar(J).floor(),V=Pe;if(oe.bindFramebuffer(36160,me),oe.viewport(U),oe.scissor(B),oe.setScissorTest(V),ke){const dt=W.get(H.texture);Ae.framebufferTexture2D(36160,36064,34069+ye,dt.__webglTexture,te)}else if(mt){const dt=W.get(H.texture),bt=ye||0;Ae.framebufferTextureLayer(36160,36064,dt.__webglTexture,te||0,bt)}},this.readRenderTargetPixels=function(H,ye,te,me,ke,mt,dt){if(!H||!H.isWebGLRenderTarget)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let bt=W.get(H).__webglFramebuffer;if(H.isWebGLCubeRenderTarget&&dt!==void 0&&(bt=bt[dt]),bt){oe.bindFramebuffer(36160,bt);try{const Nt=H.texture,ft=Nt.format,kt=Nt.type;if(ft!==1023&&qn.convert(ft)!==Ae.getParameter(35739))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");const ut=kt===1016&&(fe.has("EXT_color_buffer_half_float")||de.isWebGL2&&fe.has("EXT_color_buffer_float"));if(!(kt===1009||qn.convert(kt)===Ae.getParameter(35738)||kt===1015&&(de.isWebGL2||fe.has("OES_texture_float")||fe.has("WEBGL_color_buffer_float"))||ut))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");Ae.checkFramebufferStatus(36160)===36053?ye>=0&&ye<=H.width-me&&te>=0&&te<=H.height-ke&&Ae.readPixels(ye,te,me,ke,qn.convert(ft),qn.convert(kt),mt):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{const Nt=k!==null?W.get(k).__webglFramebuffer:null;oe.bindFramebuffer(36160,Nt)}}},this.copyFramebufferToTexture=function(H,ye,te=0){const me=Math.pow(2,-te),ke=Math.floor(ye.image.width*me),mt=Math.floor(ye.image.height*me),dt=qn.convert(ye.format);K.setTexture2D(ye,0),Ae.copyTexImage2D(3553,te,dt,H.x,H.y,ke,mt,0),oe.unbindTexture()},this.copyTextureToTexture=function(H,ye,te,me=0){const ke=ye.image.width,mt=ye.image.height,dt=qn.convert(te.format),bt=qn.convert(te.type);K.setTexture2D(te,0),Ae.pixelStorei(37440,te.flipY),Ae.pixelStorei(37441,te.premultiplyAlpha),Ae.pixelStorei(3317,te.unpackAlignment),ye.isDataTexture?Ae.texSubImage2D(3553,me,H.x,H.y,ke,mt,dt,bt,ye.image.data):ye.isCompressedTexture?Ae.compressedTexSubImage2D(3553,me,H.x,H.y,ye.mipmaps[0].width,ye.mipmaps[0].height,dt,ye.mipmaps[0].data):Ae.texSubImage2D(3553,me,H.x,H.y,dt,bt,ye.image),me===0&&te.generateMipmaps&&Ae.generateMipmap(3553),oe.unbindTexture()},this.copyTextureToTexture3D=function(H,ye,te,me,ke=0){if(S.isWebGL1Renderer)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");const{width:mt,height:dt,data:bt}=te.image,Nt=qn.convert(me.format),ft=qn.convert(me.type);let kt;if(me.isDataTexture3D)K.setTexture3D(me,0),kt=32879;else{if(!me.isDataTexture2DArray)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");K.setTexture2DArray(me,0),kt=35866}Ae.pixelStorei(37440,me.flipY),Ae.pixelStorei(37441,me.premultiplyAlpha),Ae.pixelStorei(3317,me.unpackAlignment);const ut=Ae.getParameter(3314),jt=Ae.getParameter(32878),Or=Ae.getParameter(3316),Xt=Ae.getParameter(3315),Qi=Ae.getParameter(32877);Ae.pixelStorei(3314,mt),Ae.pixelStorei(32878,dt),Ae.pixelStorei(3316,H.min.x),Ae.pixelStorei(3315,H.min.y),Ae.pixelStorei(32877,H.min.z),Ae.texSubImage3D(kt,ke,ye.x,ye.y,ye.z,H.max.x-H.min.x+1,H.max.y-H.min.y+1,H.max.z-H.min.z+1,Nt,ft,bt),Ae.pixelStorei(3314,ut),Ae.pixelStorei(32878,jt),Ae.pixelStorei(3316,Or),Ae.pixelStorei(3315,Xt),Ae.pixelStorei(32877,Qi),ke===0&&me.generateMipmaps&&Ae.generateMipmap(kt),oe.unbindTexture()},this.initTexture=function(H){K.setTexture2D(H,0),oe.unbindTexture()},this.resetState=function(){A=0,I=0,k=null,oe.reset(),Mn.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}class kp extends Ut{}kp.prototype.isWebGL1Renderer=!0;class xo{constructor(e,t=25e-5){this.name="",this.color=new Ge(e),this.density=t}clone(){return new xo(this.color,this.density)}toJSON(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}xo.prototype.isFogExp2=!0;class _o{constructor(e,t=1,r=1e3){this.name="",this.color=new Ge(e),this.near=t,this.far=r}clone(){return new _o(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}_o.prototype.isFog=!0;class Ja extends yt{constructor(){super(),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.autoUpdate=e.autoUpdate,this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.background!==null&&(t.object.background=this.background.toJSON(e)),this.environment!==null&&(t.object.environment=this.environment.toJSON(e)),this.fog!==null&&(t.object.fog=this.fog.toJSON()),t}}Ja.prototype.isScene=!0;class $r{constructor(e,t){this.array=e,this.stride=t,this.count=e!==void 0?e.length/t:0,this.usage=35044,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=it(),this.onUploadCallback=function(){}}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,t,r){e*=this.stride,r*=t.stride;for(let i=0,a=this.stride;i<a;i++)this.array[e+i]=t.array[r+i];return this}set(e,t=0){return this.array.set(e,t),this}clone(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=it()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),r=new $r(t,this.stride);return r.setUsage(this.usage),r}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=it()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}$r.prototype.isInterleavedBuffer=!0;const Qt=new O;class wi{constructor(e,t,r,i){this.name="",this.data=e,this.itemSize=t,this.offset=r,this.normalized=i===!0}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let t=0,r=this.data.count;t<r;t++)Qt.x=this.getX(t),Qt.y=this.getY(t),Qt.z=this.getZ(t),Qt.applyMatrix4(e),this.setXYZ(t,Qt.x,Qt.y,Qt.z);return this}applyNormalMatrix(e){for(let t=0,r=this.count;t<r;t++)Qt.x=this.getX(t),Qt.y=this.getY(t),Qt.z=this.getZ(t),Qt.applyNormalMatrix(e),this.setXYZ(t,Qt.x,Qt.y,Qt.z);return this}transformDirection(e){for(let t=0,r=this.count;t<r;t++)Qt.x=this.getX(t),Qt.y=this.getY(t),Qt.z=this.getZ(t),Qt.transformDirection(e),this.setXYZ(t,Qt.x,Qt.y,Qt.z);return this}setX(e,t){return this.data.array[e*this.data.stride+this.offset]=t,this}setY(e,t){return this.data.array[e*this.data.stride+this.offset+1]=t,this}setZ(e,t){return this.data.array[e*this.data.stride+this.offset+2]=t,this}setW(e,t){return this.data.array[e*this.data.stride+this.offset+3]=t,this}getX(e){return this.data.array[e*this.data.stride+this.offset]}getY(e){return this.data.array[e*this.data.stride+this.offset+1]}getZ(e){return this.data.array[e*this.data.stride+this.offset+2]}getW(e){return this.data.array[e*this.data.stride+this.offset+3]}setXY(e,t,r){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=r,this}setXYZ(e,t,r,i){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=r,this.data.array[e+2]=i,this}setXYZW(e,t,r,i,a){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=r,this.data.array[e+2]=i,this.data.array[e+3]=a,this}clone(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let r=0;r<this.count;r++){const i=r*this.data.stride+this.offset;for(let a=0;a<this.itemSize;a++)t.push(this.data.array[i+a])}return new xt(new this.array.constructor(t),this.itemSize,this.normalized)}return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new wi(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let r=0;r<this.count;r++){const i=r*this.data.stride+this.offset;for(let a=0;a<this.itemSize;a++)t.push(this.data.array[i+a])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}wi.prototype.isInterleavedBufferAttribute=!0;class Qa extends rn{constructor(e){super(),this.type="SpriteMaterial",this.color=new Ge(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this}}let ks;Qa.prototype.isSpriteMaterial=!0;const bo=new O,Hs=new O,Fs=new O,Bs=new Ee,wo=new Ee,Hp=new Ze,el=new O,Mo=new O,tl=new O,Fp=new Ee,gu=new Ee,Bp=new Ee;class nl extends yt{constructor(e){if(super(),this.type="Sprite",ks===void 0){ks=new Qe;const t=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),r=new $r(t,5);ks.setIndex([0,1,2,0,2,3]),ks.setAttribute("position",new wi(r,3,0,!1)),ks.setAttribute("uv",new wi(r,2,3,!1))}this.geometry=ks,this.material=e!==void 0?e:new Qa,this.center=new Ee(.5,.5)}raycast(e,t){e.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Hs.setFromMatrixScale(this.matrixWorld),Hp.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),Fs.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&Hs.multiplyScalar(-Fs.z);const r=this.material.rotation;let i,a;r!==0&&(a=Math.cos(r),i=Math.sin(r));const c=this.center;rl(el.set(-.5,-.5,0),Fs,c,Hs,i,a),rl(Mo.set(.5,-.5,0),Fs,c,Hs,i,a),rl(tl.set(.5,.5,0),Fs,c,Hs,i,a),Fp.set(0,0),gu.set(1,0),Bp.set(1,1);let u=e.ray.intersectTriangle(el,Mo,tl,!1,bo);if(u===null&&(rl(Mo.set(-.5,.5,0),Fs,c,Hs,i,a),gu.set(0,1),u=e.ray.intersectTriangle(el,tl,Mo,!1,bo),u===null))return;const h=e.ray.origin.distanceTo(bo);h<e.near||h>e.far||t.push({distance:h,point:bo.clone(),uv:Jt.getUV(bo,el,Mo,tl,Fp,gu,Bp,new Ee),face:null,object:this})}copy(e){return super.copy(e),e.center!==void 0&&this.center.copy(e.center),this.material=e.material,this}}function rl(o,e,t,r,i,a){Bs.subVectors(o,t).addScalar(.5).multiply(r),i!==void 0?(wo.x=a*Bs.x-i*Bs.y,wo.y=i*Bs.x+a*Bs.y):wo.copy(Bs),o.copy(e),o.x+=wo.x,o.y+=wo.y,o.applyMatrix4(Hp)}nl.prototype.isSprite=!0;const il=new O,zp=new O;class Up extends yt{constructor(){super(),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),this.autoUpdate=!0}copy(e){super.copy(e,!1);const t=e.levels;for(let r=0,i=t.length;r<i;r++){const a=t[r];this.addLevel(a.object.clone(),a.distance)}return this.autoUpdate=e.autoUpdate,this}addLevel(e,t=0){t=Math.abs(t);const r=this.levels;let i;for(i=0;i<r.length&&!(t<r[i].distance);i++);return r.splice(i,0,{distance:t,object:e}),this.add(e),this}getCurrentLevel(){return this._currentLevel}getObjectForDistance(e){const t=this.levels;if(t.length>0){let r,i;for(r=1,i=t.length;r<i&&!(e<t[r].distance);r++);return t[r-1].object}return null}raycast(e,t){if(this.levels.length>0){il.setFromMatrixPosition(this.matrixWorld);const r=e.ray.origin.distanceTo(il);this.getObjectForDistance(r).raycast(e,t)}}update(e){const t=this.levels;if(t.length>1){il.setFromMatrixPosition(e.matrixWorld),zp.setFromMatrixPosition(this.matrixWorld);const r=il.distanceTo(zp)/e.zoom;let i,a;for(t[0].object.visible=!0,i=1,a=t.length;i<a&&r>=t[i].distance;i++)t[i-1].object.visible=!1,t[i].object.visible=!0;for(this._currentLevel=i-1;i<a;i++)t[i].object.visible=!1}}toJSON(e){const t=super.toJSON(e);this.autoUpdate===!1&&(t.object.autoUpdate=!1),t.object.levels=[];const r=this.levels;for(let i=0,a=r.length;i<a;i++){const c=r[i];t.object.levels.push({object:c.object.uuid,distance:c.distance})}return t}}const Gp=new O,Vp=new Dt,Wp=new Dt,Mx=new O,jp=new Ze;class sl extends sn{constructor(e,t){super(e,t),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new Ze,this.bindMatrixInverse=new Ze}copy(e){return super.copy(e),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,this}bind(e,t){this.skeleton=e,t===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new Dt,t=this.geometry.attributes.skinWeight;for(let r=0,i=t.count;r<i;r++){e.x=t.getX(r),e.y=t.getY(r),e.z=t.getZ(r),e.w=t.getW(r);const a=1/e.manhattanLength();a!==1/0?e.multiplyScalar(a):e.set(1,0,0,0),t.setXYZW(r,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.bindMode==="attached"?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode==="detached"?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(e,t){const r=this.skeleton,i=this.geometry;Vp.fromBufferAttribute(i.attributes.skinIndex,e),Wp.fromBufferAttribute(i.attributes.skinWeight,e),Gp.fromBufferAttribute(i.attributes.position,e).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let a=0;a<4;a++){const c=Wp.getComponent(a);if(c!==0){const u=Vp.getComponent(a);jp.multiplyMatrices(r.bones[u].matrixWorld,r.boneInverses[u]),t.addScaledVector(Mx.copy(Gp).applyMatrix4(jp),c)}}return t.applyMatrix4(this.bindMatrixInverse)}}sl.prototype.isSkinnedMesh=!0;class ol extends yt{constructor(){super(),this.type="Bone"}}ol.prototype.isBone=!0;const qp=new Ze,Sx=new Ze;class al{constructor(e=[],t=[]){this.uuid=it(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}init(){const e=this.bones,t=this.boneInverses;if(this.boneMatrices=new Float32Array(16*e.length),t.length===0)this.calculateInverses();else if(e.length!==t.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let r=0,i=this.bones.length;r<i;r++)this.boneInverses.push(new Ze)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,t=this.bones.length;e<t;e++){const r=new Ze;this.bones[e]&&r.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(r)}}pose(){for(let e=0,t=this.bones.length;e<t;e++){const r=this.bones[e];r&&r.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,t=this.bones.length;e<t;e++){const r=this.bones[e];r&&(r.parent&&r.parent.isBone?(r.matrix.copy(r.parent.matrixWorld).invert(),r.matrix.multiply(r.matrixWorld)):r.matrix.copy(r.matrixWorld),r.matrix.decompose(r.position,r.quaternion,r.scale))}}update(){const e=this.bones,t=this.boneInverses,r=this.boneMatrices,i=this.boneTexture;for(let a=0,c=e.length;a<c;a++){const u=e[a]?e[a].matrixWorld:Sx;qp.multiplyMatrices(u,t[a]),qp.toArray(r,16*a)}i!==null&&(i.needsUpdate=!0)}clone(){return new al(this.bones,this.boneInverses)}getBoneByName(e){for(let t=0,r=this.bones.length;t<r;t++){const i=this.bones[t];if(i.name===e)return i}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(e,t){this.uuid=e.uuid;for(let r=0,i=e.bones.length;r<i;r++){const a=e.bones[r];let c=t[a];c===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",a),c=new ol),this.bones.push(c),this.boneInverses.push(new Ze().fromArray(e.boneInverses[r]))}return this.init(),this}toJSON(){const e={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const t=this.bones,r=this.boneInverses;for(let i=0,a=t.length;i<a;i++){const c=t[i];e.bones.push(c.uuid);const u=r[i];e.boneInverses.push(u.toArray())}return e}}const Xp=new Ze,Yp=new Ze,ll=[],So=new sn;class vu extends sn{constructor(e,t,r){super(e,t),this.instanceMatrix=new xt(new Float32Array(16*r),16),this.instanceColor=null,this.count=r,this.frustumCulled=!1}copy(e){return super.copy(e),this.instanceMatrix.copy(e.instanceMatrix),e.instanceColor!==null&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,this}getColorAt(e,t){t.fromArray(this.instanceColor.array,3*e)}getMatrixAt(e,t){t.fromArray(this.instanceMatrix.array,16*e)}raycast(e,t){const r=this.matrixWorld,i=this.count;if(So.geometry=this.geometry,So.material=this.material,So.material!==void 0)for(let a=0;a<i;a++){this.getMatrixAt(a,Xp),Yp.multiplyMatrices(r,Xp),So.matrixWorld=Yp,So.raycast(e,ll);for(let c=0,u=ll.length;c<u;c++){const h=ll[c];h.instanceId=a,h.object=this,t.push(h)}ll.length=0}}setColorAt(e,t){this.instanceColor===null&&(this.instanceColor=new xt(new Float32Array(3*this.count),3)),t.toArray(this.instanceColor.array,3*e)}setMatrixAt(e,t){t.toArray(this.instanceMatrix.array,16*e)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}vu.prototype.isInstancedMesh=!0;class vn extends rn{constructor(e){super(),this.type="LineBasicMaterial",this.color=new Ge(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.morphTargets=!1,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.morphTargets=e.morphTargets,this}}vn.prototype.isLineBasicMaterial=!0;const Zp=new O,Kp=new O,$p=new Ze,yu=new gi,cl=new fi;class Jr extends yt{constructor(e=new Qe,t=new vn){super(),this.type="Line",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),this.material=e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(e.isBufferGeometry)if(e.index===null){const t=e.attributes.position,r=[0];for(let i=1,a=t.count;i<a;i++)Zp.fromBufferAttribute(t,i-1),Kp.fromBufferAttribute(t,i),r[i]=r[i-1],r[i]+=Zp.distanceTo(Kp);e.setAttribute("lineDistance",new qe(r,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else e.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}raycast(e,t){const r=this.geometry,i=this.matrixWorld,a=e.params.Line.threshold,c=r.drawRange;if(r.boundingSphere===null&&r.computeBoundingSphere(),cl.copy(r.boundingSphere),cl.applyMatrix4(i),cl.radius+=a,e.ray.intersectsSphere(cl)===!1)return;$p.copy(i).invert(),yu.copy(e.ray).applyMatrix4($p);const u=a/((this.scale.x+this.scale.y+this.scale.z)/3),h=u*u,p=new O,m=new O,g=new O,y=new O,x=this.isLineSegments?2:1;if(r.isBufferGeometry){const b=r.index,S=r.attributes.position;if(b!==null)for(let M=Math.max(0,c.start),A=Math.min(b.count,c.start+c.count)-1;M<A;M+=x){const I=b.getX(M),k=b.getX(M+1);if(p.fromBufferAttribute(S,I),m.fromBufferAttribute(S,k),yu.distanceSqToSegment(p,m,y,g)>h)continue;y.applyMatrix4(this.matrixWorld);const N=e.ray.origin.distanceTo(y);N<e.near||N>e.far||t.push({distance:N,point:g.clone().applyMatrix4(this.matrixWorld),index:M,face:null,faceIndex:null,object:this})}else for(let M=Math.max(0,c.start),A=Math.min(S.count,c.start+c.count)-1;M<A;M+=x){if(p.fromBufferAttribute(S,M),m.fromBufferAttribute(S,M+1),yu.distanceSqToSegment(p,m,y,g)>h)continue;y.applyMatrix4(this.matrixWorld);const I=e.ray.origin.distanceTo(y);I<e.near||I>e.far||t.push({distance:I,point:g.clone().applyMatrix4(this.matrixWorld),index:M,face:null,faceIndex:null,object:this})}}else r.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,r=Object.keys(t);if(r.length>0){const i=t[r[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let a=0,c=i.length;a<c;a++){const u=i[a].name||String(a);this.morphTargetInfluences.push(0),this.morphTargetDictionary[u]=a}}}}else{const t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}Jr.prototype.isLine=!0;const Jp=new O,Qp=new O;class jn extends Jr{constructor(e,t){super(e,t),this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(e.isBufferGeometry)if(e.index===null){const t=e.attributes.position,r=[];for(let i=0,a=t.count;i<a;i+=2)Jp.fromBufferAttribute(t,i),Qp.fromBufferAttribute(t,i+1),r[i]=i===0?0:r[i-1],r[i+1]=r[i]+Jp.distanceTo(Qp);e.setAttribute("lineDistance",new qe(r,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else e.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}}jn.prototype.isLineSegments=!0;class xu extends Jr{constructor(e,t){super(e,t),this.type="LineLoop"}}xu.prototype.isLineLoop=!0;class Gi extends rn{constructor(e){super(),this.type="PointsMaterial",this.color=new Ge(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.morphTargets=!1,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.morphTargets=e.morphTargets,this}}Gi.prototype.isPointsMaterial=!0;const ef=new Ze,_u=new gi,ul=new fi,hl=new O;class Eo extends yt{constructor(e=new Qe,t=new Gi){super(),this.type="Points",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),this.material=e.material,this.geometry=e.geometry,this}raycast(e,t){const r=this.geometry,i=this.matrixWorld,a=e.params.Points.threshold,c=r.drawRange;if(r.boundingSphere===null&&r.computeBoundingSphere(),ul.copy(r.boundingSphere),ul.applyMatrix4(i),ul.radius+=a,e.ray.intersectsSphere(ul)===!1)return;ef.copy(i).invert(),_u.copy(e.ray).applyMatrix4(ef);const u=a/((this.scale.x+this.scale.y+this.scale.z)/3),h=u*u;if(r.isBufferGeometry){const p=r.index,m=r.attributes.position;if(p!==null)for(let g=Math.max(0,c.start),y=Math.min(p.count,c.start+c.count);g<y;g++){const x=p.getX(g);hl.fromBufferAttribute(m,x),tf(hl,x,h,i,e,t,this)}else for(let g=Math.max(0,c.start),y=Math.min(m.count,c.start+c.count);g<y;g++)hl.fromBufferAttribute(m,g),tf(hl,g,h,i,e,t,this)}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,r=Object.keys(t);if(r.length>0){const i=t[r[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let a=0,c=i.length;a<c;a++){const u=i[a].name||String(a);this.morphTargetInfluences.push(0),this.morphTargetDictionary[u]=a}}}}else{const t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}function tf(o,e,t,r,i,a,c){const u=_u.distanceSqToPoint(o);if(u<t){const h=new O;_u.closestPointToPoint(o,h),h.applyMatrix4(r);const p=i.ray.origin.distanceTo(h);if(p<i.near||p>i.far)return;a.push({distance:p,distanceToRay:Math.sqrt(u),point:h,index:e,face:null,object:c})}}Eo.prototype.isPoints=!0;class nf extends un{constructor(e,t,r,i,a,c,u,h,p){super(e,t,r,i,a,c,u,h,p),this.format=u!==void 0?u:1022,this.minFilter=c!==void 0?c:1006,this.magFilter=a!==void 0?a:1006,this.generateMipmaps=!1;const m=this;"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback(function g(){m.needsUpdate=!0,e.requestVideoFrameCallback(g)})}clone(){return new this.constructor(this.image).copy(this)}update(){const e=this.image;!("requestVideoFrameCallback"in e)&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}nf.prototype.isVideoTexture=!0;class bu extends un{constructor(e,t,r,i,a,c,u,h,p,m,g,y){super(null,c,u,h,p,m,i,a,g,y),this.image={width:t,height:r},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}}bu.prototype.isCompressedTexture=!0;class rf extends un{constructor(e,t,r,i,a,c,u,h,p){super(e,t,r,i,a,c,u,h,p),this.needsUpdate=!0}}rf.prototype.isCanvasTexture=!0;class sf extends un{constructor(e,t,r,i,a,c,u,h,p,m){if((m=m!==void 0?m:1026)!==1026&&m!==1027)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");r===void 0&&m===1026&&(r=1012),r===void 0&&m===1027&&(r=1020),super(null,i,a,c,u,h,m,r,p),this.image={width:e,height:t},this.magFilter=u!==void 0?u:1003,this.minFilter=h!==void 0?h:1003,this.flipY=!1,this.generateMipmaps=!1}}sf.prototype.isDepthTexture=!0;class dl extends Qe{constructor(e=1,t=8,r=0,i=2*Math.PI){super(),this.type="CircleGeometry",this.parameters={radius:e,segments:t,thetaStart:r,thetaLength:i},t=Math.max(3,t);const a=[],c=[],u=[],h=[],p=new O,m=new Ee;c.push(0,0,0),u.push(0,0,1),h.push(.5,.5);for(let g=0,y=3;g<=t;g++,y+=3){const x=r+g/t*i;p.x=e*Math.cos(x),p.y=e*Math.sin(x),c.push(p.x,p.y,p.z),u.push(0,0,1),m.x=(c[y]/e+1)/2,m.y=(c[y+1]/e+1)/2,h.push(m.x,m.y)}for(let g=1;g<=t;g++)a.push(g,g+1,0);this.setIndex(a),this.setAttribute("position",new qe(c,3)),this.setAttribute("normal",new qe(u,3)),this.setAttribute("uv",new qe(h,2))}}class zs extends Qe{constructor(e=1,t=1,r=1,i=8,a=1,c=!1,u=0,h=2*Math.PI){super(),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:r,radialSegments:i,heightSegments:a,openEnded:c,thetaStart:u,thetaLength:h};const p=this;i=Math.floor(i),a=Math.floor(a);const m=[],g=[],y=[],x=[];let b=0;const S=[],M=r/2;let A=0;function I(k){const N=b,G=new Ee,U=new O;let B=0;const V=k===!0?e:t,he=k===!0?1:-1;for(let J=1;J<=i;J++)g.push(0,M*he,0),y.push(0,he,0),x.push(.5,.5),b++;const Z=b;for(let J=0;J<=i;J++){const re=J/i*h+u,ee=Math.cos(re),le=Math.sin(re);U.x=V*le,U.y=M*he,U.z=V*ee,g.push(U.x,U.y,U.z),y.push(0,he,0),G.x=.5*ee+.5,G.y=.5*le*he+.5,x.push(G.x,G.y),b++}for(let J=0;J<i;J++){const re=N+J,ee=Z+J;k===!0?m.push(ee,ee+1,re):m.push(ee+1,ee,re),B+=3}p.addGroup(A,B,k===!0?1:2),A+=B}(function(){const k=new O,N=new O;let G=0;const U=(t-e)/r;for(let B=0;B<=a;B++){const V=[],he=B/a,Z=he*(t-e)+e;for(let J=0;J<=i;J++){const re=J/i,ee=re*h+u,le=Math.sin(ee),Ce=Math.cos(ee);N.x=Z*le,N.y=-he*r+M,N.z=Z*Ce,g.push(N.x,N.y,N.z),k.set(le,U,Ce).normalize(),y.push(k.x,k.y,k.z),x.push(re,1-he),V.push(b++)}S.push(V)}for(let B=0;B<i;B++)for(let V=0;V<a;V++){const he=S[V][B],Z=S[V+1][B],J=S[V+1][B+1],re=S[V][B+1];m.push(he,Z,re),m.push(Z,J,re),G+=6}p.addGroup(A,G,0),A+=G})(),c===!1&&(e>0&&I(!0),t>0&&I(!1)),this.setIndex(m),this.setAttribute("position",new qe(g,3)),this.setAttribute("normal",new qe(y,3)),this.setAttribute("uv",new qe(x,2))}}class pl extends zs{constructor(e=1,t=1,r=8,i=1,a=!1,c=0,u=2*Math.PI){super(0,e,t,r,i,a,c,u),this.type="ConeGeometry",this.parameters={radius:e,height:t,radialSegments:r,heightSegments:i,openEnded:a,thetaStart:c,thetaLength:u}}}class Mi extends Qe{constructor(e,t,r=1,i=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:e,indices:t,radius:r,detail:i};const a=[],c=[];function u(y,x,b,S){const M=S+1,A=[];for(let I=0;I<=M;I++){A[I]=[];const k=y.clone().lerp(b,I/M),N=x.clone().lerp(b,I/M),G=M-I;for(let U=0;U<=G;U++)A[I][U]=U===0&&I===M?k:k.clone().lerp(N,U/G)}for(let I=0;I<M;I++)for(let k=0;k<2*(M-I)-1;k++){const N=Math.floor(k/2);k%2==0?(h(A[I][N+1]),h(A[I+1][N]),h(A[I][N])):(h(A[I][N+1]),h(A[I+1][N+1]),h(A[I+1][N]))}}function h(y){a.push(y.x,y.y,y.z)}function p(y,x){const b=3*y;x.x=e[b+0],x.y=e[b+1],x.z=e[b+2]}function m(y,x,b,S){S<0&&y.x===1&&(c[x]=y.x-1),b.x===0&&b.z===0&&(c[x]=S/2/Math.PI+.5)}function g(y){return Math.atan2(y.z,-y.x)}(function(y){const x=new O,b=new O,S=new O;for(let M=0;M<t.length;M+=3)p(t[M+0],x),p(t[M+1],b),p(t[M+2],S),u(x,b,S,y)})(i),function(y){const x=new O;for(let b=0;b<a.length;b+=3)x.x=a[b+0],x.y=a[b+1],x.z=a[b+2],x.normalize().multiplyScalar(y),a[b+0]=x.x,a[b+1]=x.y,a[b+2]=x.z}(r),function(){const y=new O;for(let b=0;b<a.length;b+=3){y.x=a[b+0],y.y=a[b+1],y.z=a[b+2];const S=g(y)/2/Math.PI+.5,M=(x=y,Math.atan2(-x.y,Math.sqrt(x.x*x.x+x.z*x.z))/Math.PI+.5);c.push(S,1-M)}var x;(function(){const b=new O,S=new O,M=new O,A=new O,I=new Ee,k=new Ee,N=new Ee;for(let G=0,U=0;G<a.length;G+=9,U+=6){b.set(a[G+0],a[G+1],a[G+2]),S.set(a[G+3],a[G+4],a[G+5]),M.set(a[G+6],a[G+7],a[G+8]),I.set(c[U+0],c[U+1]),k.set(c[U+2],c[U+3]),N.set(c[U+4],c[U+5]),A.copy(b).add(S).add(M).divideScalar(3);const B=g(A);m(I,U+0,b,B),m(k,U+2,S,B),m(N,U+4,M,B)}})(),function(){for(let b=0;b<c.length;b+=6){const S=c[b+0],M=c[b+2],A=c[b+4],I=Math.max(S,M,A),k=Math.min(S,M,A);I>.9&&k<.1&&(S<.2&&(c[b+0]+=1),M<.2&&(c[b+2]+=1),A<.2&&(c[b+4]+=1))}}()}(),this.setAttribute("position",new qe(a,3)),this.setAttribute("normal",new qe(a.slice(),3)),this.setAttribute("uv",new qe(c,2)),i===0?this.computeVertexNormals():this.normalizeNormals()}}class fl extends Mi{constructor(e=1,t=0){const r=(1+Math.sqrt(5))/2,i=1/r;super([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-i,-r,0,-i,r,0,i,-r,0,i,r,-i,-r,0,-i,r,0,i,-r,0,i,r,0,-r,0,-i,r,0,-i,-r,0,i,r,0,i],[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9],e,t),this.type="DodecahedronGeometry",this.parameters={radius:e,detail:t}}}const ml=new O,gl=new O,wu=new O,vl=new Jt;class Mu extends Qe{constructor(e,t){if(super(),this.type="EdgesGeometry",this.parameters={thresholdAngle:t},t=t!==void 0?t:1,e.isGeometry===!0)return void console.error("THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");const r=Math.pow(10,4),i=Math.cos(Ue*t),a=e.getIndex(),c=e.getAttribute("position"),u=a?a.count:c.count,h=[0,0,0],p=["a","b","c"],m=new Array(3),g={},y=[];for(let x=0;x<u;x+=3){a?(h[0]=a.getX(x),h[1]=a.getX(x+1),h[2]=a.getX(x+2)):(h[0]=x,h[1]=x+1,h[2]=x+2);const{a:b,b:S,c:M}=vl;if(b.fromBufferAttribute(c,h[0]),S.fromBufferAttribute(c,h[1]),M.fromBufferAttribute(c,h[2]),vl.getNormal(wu),m[0]=`${Math.round(b.x*r)},${Math.round(b.y*r)},${Math.round(b.z*r)}`,m[1]=`${Math.round(S.x*r)},${Math.round(S.y*r)},${Math.round(S.z*r)}`,m[2]=`${Math.round(M.x*r)},${Math.round(M.y*r)},${Math.round(M.z*r)}`,m[0]!==m[1]&&m[1]!==m[2]&&m[2]!==m[0])for(let A=0;A<3;A++){const I=(A+1)%3,k=m[A],N=m[I],G=vl[p[A]],U=vl[p[I]],B=`${k}_${N}`,V=`${N}_${k}`;V in g&&g[V]?(wu.dot(g[V].normal)<=i&&(y.push(G.x,G.y,G.z),y.push(U.x,U.y,U.z)),g[V]=null):B in g||(g[B]={index0:h[A],index1:h[I],normal:wu.clone()})}}for(const x in g)if(g[x]){const{index0:b,index1:S}=g[x];ml.fromBufferAttribute(c,b),gl.fromBufferAttribute(c,S),y.push(ml.x,ml.y,ml.z),y.push(gl.x,gl.y,gl.z)}this.setAttribute("position",new qe(y,3))}}const Ex=function(o,e,t){t=t||2;const r=e&&e.length,i=r?e[0]*t:o.length;let a=of(o,0,i,t,!0);const c=[];if(!a||a.next===a.prev)return c;let u,h,p,m,g,y,x;if(r&&(a=function(b,S,M,A){const I=[];let k,N,G,U,B;for(k=0,N=S.length;k<N;k++)G=S[k]*A,U=k<N-1?S[k+1]*A:b.length,B=of(b,G,U,A,!1),B===B.next&&(B.steiner=!0),I.push(Ox(B));for(I.sort(Cx),k=0;k<I.length;k++)Px(I[k],M),M=Si(M,M.next);return M}(o,e,a,t)),o.length>80*t){u=p=o[0],h=m=o[1];for(let b=t;b<i;b+=t)g=o[b],y=o[b+1],g<u&&(u=g),y<h&&(h=y),g>p&&(p=g),y>m&&(m=y);x=Math.max(p-u,m-h),x=x!==0?1/x:0}return To(a,c,t,u,h,x),c};function of(o,e,t,r,i){let a,c;if(i===function(u,h,p,m){let g=0;for(let y=h,x=p-m;y<p;y+=m)g+=(u[x]-u[y])*(u[y+1]+u[x+1]),x=y;return g}(o,e,t,r)>0)for(a=e;a<t;a+=r)c=cf(a,o[a],o[a+1],c);else for(a=t-r;a>=e;a-=r)c=cf(a,o[a],o[a+1],c);return c&&yl(c,c.next)&&(Ro(c),c=c.next),c}function Si(o,e){if(!o)return o;e||(e=o);let t,r=o;do if(t=!1,r.steiner||!yl(r,r.next)&&qt(r.prev,r,r.next)!==0)r=r.next;else{if(Ro(r),r=e=r.prev,r===r.next)break;t=!0}while(t||r!==e);return e}function To(o,e,t,r,i,a,c){if(!o)return;!c&&a&&function(m,g,y,x){let b=m;do b.z===null&&(b.z=Su(b.x,b.y,g,y,x)),b.prevZ=b.prev,b.nextZ=b.next,b=b.next;while(b!==m);b.prevZ.nextZ=null,b.prevZ=null,function(S){let M,A,I,k,N,G,U,B,V=1;do{for(A=S,S=null,N=null,G=0;A;){for(G++,I=A,U=0,M=0;M<V&&(U++,I=I.nextZ,I);M++);for(B=V;U>0||B>0&&I;)U!==0&&(B===0||!I||A.z<=I.z)?(k=A,A=A.nextZ,U--):(k=I,I=I.nextZ,B--),N?N.nextZ=k:S=k,k.prevZ=N,N=k;A=I}N.nextZ=null,V*=2}while(G>1)}(b)}(o,r,i,a);let u,h,p=o;for(;o.prev!==o.next;)if(u=o.prev,h=o.next,a?Ax(o,r,i,a):Tx(o))e.push(u.i/t),e.push(o.i/t),e.push(h.i/t),Ro(o),o=h.next,p=h.next;else if((o=h)===p){c?c===1?To(o=Rx(Si(o),e,t),e,t,r,i,a,2):c===2&&Lx(o,e,t,r,i,a):To(Si(o),e,t,r,i,a,1);break}}function Tx(o){const e=o.prev,t=o,r=o.next;if(qt(e,t,r)>=0)return!1;let i=o.next.next;for(;i!==o.prev;){if(Us(e.x,e.y,t.x,t.y,r.x,r.y,i.x,i.y)&&qt(i.prev,i,i.next)>=0)return!1;i=i.next}return!0}function Ax(o,e,t,r){const i=o.prev,a=o,c=o.next;if(qt(i,a,c)>=0)return!1;const u=i.x<a.x?i.x<c.x?i.x:c.x:a.x<c.x?a.x:c.x,h=i.y<a.y?i.y<c.y?i.y:c.y:a.y<c.y?a.y:c.y,p=i.x>a.x?i.x>c.x?i.x:c.x:a.x>c.x?a.x:c.x,m=i.y>a.y?i.y>c.y?i.y:c.y:a.y>c.y?a.y:c.y,g=Su(u,h,e,t,r),y=Su(p,m,e,t,r);let x=o.prevZ,b=o.nextZ;for(;x&&x.z>=g&&b&&b.z<=y;){if(x!==o.prev&&x!==o.next&&Us(i.x,i.y,a.x,a.y,c.x,c.y,x.x,x.y)&&qt(x.prev,x,x.next)>=0||(x=x.prevZ,b!==o.prev&&b!==o.next&&Us(i.x,i.y,a.x,a.y,c.x,c.y,b.x,b.y)&&qt(b.prev,b,b.next)>=0))return!1;b=b.nextZ}for(;x&&x.z>=g;){if(x!==o.prev&&x!==o.next&&Us(i.x,i.y,a.x,a.y,c.x,c.y,x.x,x.y)&&qt(x.prev,x,x.next)>=0)return!1;x=x.prevZ}for(;b&&b.z<=y;){if(b!==o.prev&&b!==o.next&&Us(i.x,i.y,a.x,a.y,c.x,c.y,b.x,b.y)&&qt(b.prev,b,b.next)>=0)return!1;b=b.nextZ}return!0}function Rx(o,e,t){let r=o;do{const i=r.prev,a=r.next.next;!yl(i,a)&&af(i,r,r.next,a)&&Ao(i,a)&&Ao(a,i)&&(e.push(i.i/t),e.push(r.i/t),e.push(a.i/t),Ro(r),Ro(r.next),r=o=a),r=r.next}while(r!==o);return Si(r)}function Lx(o,e,t,r,i,a){let c=o;do{let u=c.next.next;for(;u!==c.prev;){if(c.i!==u.i&&Dx(c,u)){let h=lf(c,u);return c=Si(c,c.next),h=Si(h,h.next),To(c,e,t,r,i,a),void To(h,e,t,r,i,a)}u=u.next}c=c.next}while(c!==o)}function Cx(o,e){return o.x-e.x}function Px(o,e){if(e=function(t,r){let i=r;const a=t.x,c=t.y;let u,h=-1/0;do{if(c<=i.y&&c>=i.next.y&&i.next.y!==i.y){const b=i.x+(c-i.y)*(i.next.x-i.x)/(i.next.y-i.y);if(b<=a&&b>h){if(h=b,b===a){if(c===i.y)return i;if(c===i.next.y)return i.next}u=i.x<i.next.x?i:i.next}}i=i.next}while(i!==r);if(!u)return null;if(a===h)return u;const p=u,m=u.x,g=u.y;let y,x=1/0;i=u;do a>=i.x&&i.x>=m&&a!==i.x&&Us(c<g?a:h,c,m,g,c<g?h:a,c,i.x,i.y)&&(y=Math.abs(c-i.y)/(a-i.x),Ao(i,t)&&(y<x||y===x&&(i.x>u.x||i.x===u.x&&Ix(u,i)))&&(u=i,x=y)),i=i.next;while(i!==p);return u}(o,e)){const t=lf(e,o);Si(e,e.next),Si(t,t.next)}}function Ix(o,e){return qt(o.prev,o,e.prev)<0&&qt(e.next,o,o.next)<0}function Su(o,e,t,r,i){return(o=1431655765&((o=858993459&((o=252645135&((o=16711935&((o=32767*(o-t)*i)|o<<8))|o<<4))|o<<2))|o<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-r)*i)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function Ox(o){let e=o,t=o;do(e.x<t.x||e.x===t.x&&e.y<t.y)&&(t=e),e=e.next;while(e!==o);return t}function Us(o,e,t,r,i,a,c,u){return(i-c)*(e-u)-(o-c)*(a-u)>=0&&(o-c)*(r-u)-(t-c)*(e-u)>=0&&(t-c)*(a-u)-(i-c)*(r-u)>=0}function Dx(o,e){return o.next.i!==e.i&&o.prev.i!==e.i&&!function(t,r){let i=t;do{if(i.i!==t.i&&i.next.i!==t.i&&i.i!==r.i&&i.next.i!==r.i&&af(i,i.next,t,r))return!0;i=i.next}while(i!==t);return!1}(o,e)&&(Ao(o,e)&&Ao(e,o)&&function(t,r){let i=t,a=!1;const c=(t.x+r.x)/2,u=(t.y+r.y)/2;do i.y>u!=i.next.y>u&&i.next.y!==i.y&&c<(i.next.x-i.x)*(u-i.y)/(i.next.y-i.y)+i.x&&(a=!a),i=i.next;while(i!==t);return a}(o,e)&&(qt(o.prev,o,e.prev)||qt(o,e.prev,e))||yl(o,e)&&qt(o.prev,o,o.next)>0&&qt(e.prev,e,e.next)>0)}function qt(o,e,t){return(e.y-o.y)*(t.x-e.x)-(e.x-o.x)*(t.y-e.y)}function yl(o,e){return o.x===e.x&&o.y===e.y}function af(o,e,t,r){const i=_l(qt(o,e,t)),a=_l(qt(o,e,r)),c=_l(qt(t,r,o)),u=_l(qt(t,r,e));return i!==a&&c!==u||!(i!==0||!xl(o,t,e))||!(a!==0||!xl(o,r,e))||!(c!==0||!xl(t,o,r))||!(u!==0||!xl(t,e,r))}function xl(o,e,t){return e.x<=Math.max(o.x,t.x)&&e.x>=Math.min(o.x,t.x)&&e.y<=Math.max(o.y,t.y)&&e.y>=Math.min(o.y,t.y)}function _l(o){return o>0?1:o<0?-1:0}function Ao(o,e){return qt(o.prev,o,o.next)<0?qt(o,e,o.next)>=0&&qt(o,o.prev,e)>=0:qt(o,e,o.prev)<0||qt(o,o.next,e)<0}function lf(o,e){const t=new Eu(o.i,o.x,o.y),r=new Eu(e.i,e.x,e.y),i=o.next,a=e.prev;return o.next=e,e.prev=o,t.next=i,i.prev=t,r.next=t,t.prev=r,a.next=r,r.prev=a,r}function cf(o,e,t,r){const i=new Eu(o,e,t);return r?(i.next=r.next,i.prev=r,r.next.prev=i,r.next=i):(i.prev=i,i.next=i),i}function Ro(o){o.next.prev=o.prev,o.prev.next=o.next,o.prevZ&&(o.prevZ.nextZ=o.nextZ),o.nextZ&&(o.nextZ.prevZ=o.prevZ)}function Eu(o,e,t){this.i=o,this.x=e,this.y=t,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}class Ar{static area(e){const t=e.length;let r=0;for(let i=t-1,a=0;a<t;i=a++)r+=e[i].x*e[a].y-e[a].x*e[i].y;return .5*r}static isClockWise(e){return Ar.area(e)<0}static triangulateShape(e,t){const r=[],i=[],a=[];uf(e),hf(r,e);let c=e.length;t.forEach(uf);for(let h=0;h<t.length;h++)i.push(c),c+=t[h].length,hf(r,t[h]);const u=Ex(r,i);for(let h=0;h<u.length;h+=3)a.push(u.slice(h,h+3));return a}}function uf(o){const e=o.length;e>2&&o[e-1].equals(o[0])&&o.pop()}function hf(o,e){for(let t=0;t<e.length;t++)o.push(e[t].x),o.push(e[t].y)}class Qr extends Qe{constructor(e,t){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];const r=this,i=[],a=[];for(let u=0,h=e.length;u<h;u++)c(e[u]);function c(u){const h=[],p=t.curveSegments!==void 0?t.curveSegments:12,m=t.steps!==void 0?t.steps:1;let g=t.depth!==void 0?t.depth:100,y=t.bevelEnabled===void 0||t.bevelEnabled,x=t.bevelThickness!==void 0?t.bevelThickness:6,b=t.bevelSize!==void 0?t.bevelSize:x-2,S=t.bevelOffset!==void 0?t.bevelOffset:0,M=t.bevelSegments!==void 0?t.bevelSegments:3;const A=t.extrudePath,I=t.UVGenerator!==void 0?t.UVGenerator:Nx;t.amount!==void 0&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),g=t.amount);let k,N,G,U,B,V=!1;A&&(k=A.getSpacedPoints(m),V=!0,y=!1,N=A.computeFrenetFrames(m,!1),G=new O,U=new O,B=new O),y||(M=0,x=0,b=0,S=0);const he=u.extractPoints(p);let Z=he.shape;const J=he.holes;if(!Ar.isClockWise(Z)){Z=Z.reverse();for(let K=0,Q=J.length;K<Q;K++){const ge=J[K];Ar.isClockWise(ge)&&(J[K]=ge.reverse())}}const re=Ar.triangulateShape(Z,J),ee=Z;for(let K=0,Q=J.length;K<Q;K++){const ge=J[K];Z=Z.concat(ge)}function le(K,Q,ge){return Q||console.error("THREE.ExtrudeGeometry: vec does not exist"),Q.clone().multiplyScalar(ge).add(K)}const Ce=Z.length,Pe=re.length;function We(K,Q,ge){let ve,Me,Ie;const Xe=K.x-Q.x,ht=K.y-Q.y,je=ge.x-K.x,rt=ge.y-K.y,wt=Xe*Xe+ht*ht,Pr=Xe*rt-ht*je;if(Math.abs(Pr)>Number.EPSILON){const Ir=Math.sqrt(wt),Wo=Math.sqrt(je*je+rt*rt),jo=Q.x-ht/Ir,qn=Q.y+Xe/Ir,Mn=((ge.x-rt/Wo-jo)*rt-(ge.y+je/Wo-qn)*je)/(Xe*rt-ht*je);ve=jo+Xe*Mn-K.x,Me=qn+ht*Mn-K.y;const Ae=ve*ve+Me*Me;if(Ae<=2)return new Ee(ve,Me);Ie=Math.sqrt(Ae/2)}else{let Ir=!1;Xe>Number.EPSILON?je>Number.EPSILON&&(Ir=!0):Xe<-Number.EPSILON?je<-Number.EPSILON&&(Ir=!0):Math.sign(ht)===Math.sign(rt)&&(Ir=!0),Ir?(ve=-ht,Me=Xe,Ie=Math.sqrt(wt)):(ve=Xe,Me=ht,Ie=Math.sqrt(wt/2))}return new Ee(ve/Ie,Me/Ie)}const Oe=[];for(let K=0,Q=ee.length,ge=Q-1,ve=K+1;K<Q;K++,ge++,ve++)ge===Q&&(ge=0),ve===Q&&(ve=0),Oe[K]=We(ee[K],ee[ge],ee[ve]);const De=[];let ze,st=Oe.concat();for(let K=0,Q=J.length;K<Q;K++){const ge=J[K];ze=[];for(let ve=0,Me=ge.length,Ie=Me-1,Xe=ve+1;ve<Me;ve++,Ie++,Xe++)Ie===Me&&(Ie=0),Xe===Me&&(Xe=0),ze[ve]=We(ge[ve],ge[Ie],ge[Xe]);De.push(ze),st=st.concat(ze)}for(let K=0;K<M;K++){const Q=K/M,ge=x*Math.cos(Q*Math.PI/2),ve=b*Math.sin(Q*Math.PI/2)+S;for(let Me=0,Ie=ee.length;Me<Ie;Me++){const Xe=le(ee[Me],Oe[Me],ve);fe(Xe.x,Xe.y,-ge)}for(let Me=0,Ie=J.length;Me<Ie;Me++){const Xe=J[Me];ze=De[Me];for(let ht=0,je=Xe.length;ht<je;ht++){const rt=le(Xe[ht],ze[ht],ve);fe(rt.x,rt.y,-ge)}}}const q=b+S;for(let K=0;K<Ce;K++){const Q=y?le(Z[K],st[K],q):Z[K];V?(U.copy(N.normals[0]).multiplyScalar(Q.x),G.copy(N.binormals[0]).multiplyScalar(Q.y),B.copy(k[0]).add(U).add(G),fe(B.x,B.y,B.z)):fe(Q.x,Q.y,0)}for(let K=1;K<=m;K++)for(let Q=0;Q<Ce;Q++){const ge=y?le(Z[Q],st[Q],q):Z[Q];V?(U.copy(N.normals[K]).multiplyScalar(ge.x),G.copy(N.binormals[K]).multiplyScalar(ge.y),B.copy(k[K]).add(U).add(G),fe(B.x,B.y,B.z)):fe(ge.x,ge.y,g/m*K)}for(let K=M-1;K>=0;K--){const Q=K/M,ge=x*Math.cos(Q*Math.PI/2),ve=b*Math.sin(Q*Math.PI/2)+S;for(let Me=0,Ie=ee.length;Me<Ie;Me++){const Xe=le(ee[Me],Oe[Me],ve);fe(Xe.x,Xe.y,g+ge)}for(let Me=0,Ie=J.length;Me<Ie;Me++){const Xe=J[Me];ze=De[Me];for(let ht=0,je=Xe.length;ht<je;ht++){const rt=le(Xe[ht],ze[ht],ve);V?fe(rt.x,rt.y+k[m-1].y,k[m-1].x+ge):fe(rt.x,rt.y,g+ge)}}}function Y(K,Q){let ge=K.length;for(;--ge>=0;){const ve=ge;let Me=ge-1;Me<0&&(Me=K.length-1);for(let Ie=0,Xe=m+2*M;Ie<Xe;Ie++){const ht=Ce*Ie,je=Ce*(Ie+1);oe(Q+ve+ht,Q+Me+ht,Q+Me+je,Q+ve+je)}}}function fe(K,Q,ge){h.push(K),h.push(Q),h.push(ge)}function de(K,Q,ge){Ve(K),Ve(Q),Ve(ge);const ve=i.length/3,Me=I.generateTopUV(r,i,ve-3,ve-2,ve-1);W(Me[0]),W(Me[1]),W(Me[2])}function oe(K,Q,ge,ve){Ve(K),Ve(Q),Ve(ve),Ve(Q),Ve(ge),Ve(ve);const Me=i.length/3,Ie=I.generateSideWallUV(r,i,Me-6,Me-3,Me-2,Me-1);W(Ie[0]),W(Ie[1]),W(Ie[3]),W(Ie[1]),W(Ie[2]),W(Ie[3])}function Ve(K){i.push(h[3*K+0]),i.push(h[3*K+1]),i.push(h[3*K+2])}function W(K){a.push(K.x),a.push(K.y)}(function(){const K=i.length/3;if(y){let Q=0,ge=Ce*Q;for(let ve=0;ve<Pe;ve++){const Me=re[ve];de(Me[2]+ge,Me[1]+ge,Me[0]+ge)}Q=m+2*M,ge=Ce*Q;for(let ve=0;ve<Pe;ve++){const Me=re[ve];de(Me[0]+ge,Me[1]+ge,Me[2]+ge)}}else{for(let Q=0;Q<Pe;Q++){const ge=re[Q];de(ge[2],ge[1],ge[0])}for(let Q=0;Q<Pe;Q++){const ge=re[Q];de(ge[0]+Ce*m,ge[1]+Ce*m,ge[2]+Ce*m)}}r.addGroup(K,i.length/3-K,0)})(),function(){const K=i.length/3;let Q=0;Y(ee,Q),Q+=ee.length;for(let ge=0,ve=J.length;ge<ve;ge++){const Me=J[ge];Y(Me,Q),Q+=Me.length}r.addGroup(K,i.length/3-K,1)}()}this.setAttribute("position",new qe(i,3)),this.setAttribute("uv",new qe(a,2)),this.computeVertexNormals()}toJSON(){const e=Qe.prototype.toJSON.call(this);return function(t,r,i){if(i.shapes=[],Array.isArray(t))for(let a=0,c=t.length;a<c;a++){const u=t[a];i.shapes.push(u.uuid)}else i.shapes.push(t.uuid);return r.extrudePath!==void 0&&(i.options.extrudePath=r.extrudePath.toJSON()),i}(this.parameters.shapes,this.parameters.options,e)}}const Nx={generateTopUV:function(o,e,t,r,i){const a=e[3*t],c=e[3*t+1],u=e[3*r],h=e[3*r+1],p=e[3*i],m=e[3*i+1];return[new Ee(a,c),new Ee(u,h),new Ee(p,m)]},generateSideWallUV:function(o,e,t,r,i,a){const c=e[3*t],u=e[3*t+1],h=e[3*t+2],p=e[3*r],m=e[3*r+1],g=e[3*r+2],y=e[3*i],x=e[3*i+1],b=e[3*i+2],S=e[3*a],M=e[3*a+1],A=e[3*a+2];return Math.abs(u-m)<.01?[new Ee(c,1-h),new Ee(p,1-g),new Ee(y,1-b),new Ee(S,1-A)]:[new Ee(u,1-h),new Ee(m,1-g),new Ee(x,1-b),new Ee(M,1-A)]}};class bl extends Mi{constructor(e=1,t=0){const r=(1+Math.sqrt(5))/2;super([-1,r,0,1,r,0,-1,-r,0,1,-r,0,0,-1,r,0,1,r,0,-1,-r,0,1,-r,r,0,-1,r,0,1,-r,0,-1,-r,0,1],[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],e,t),this.type="IcosahedronGeometry",this.parameters={radius:e,detail:t}}}class wl extends Qe{constructor(e,t=12,r=0,i=2*Math.PI){super(),this.type="LatheGeometry",this.parameters={points:e,segments:t,phiStart:r,phiLength:i},t=Math.floor(t),i=ct(i,0,2*Math.PI);const a=[],c=[],u=[],h=1/t,p=new O,m=new Ee;for(let g=0;g<=t;g++){const y=r+g*h*i,x=Math.sin(y),b=Math.cos(y);for(let S=0;S<=e.length-1;S++)p.x=e[S].x*x,p.y=e[S].y,p.z=e[S].x*b,c.push(p.x,p.y,p.z),m.x=g/t,m.y=S/(e.length-1),u.push(m.x,m.y)}for(let g=0;g<t;g++)for(let y=0;y<e.length-1;y++){const x=y+g*e.length,b=x,S=x+e.length,M=x+e.length+1,A=x+1;a.push(b,S,A),a.push(S,M,A)}if(this.setIndex(a),this.setAttribute("position",new qe(c,3)),this.setAttribute("uv",new qe(u,2)),this.computeVertexNormals(),i===2*Math.PI){const g=this.attributes.normal.array,y=new O,x=new O,b=new O,S=t*e.length*3;for(let M=0,A=0;M<e.length;M++,A+=3)y.x=g[A+0],y.y=g[A+1],y.z=g[A+2],x.x=g[S+A+0],x.y=g[S+A+1],x.z=g[S+A+2],b.addVectors(y,x).normalize(),g[A+0]=g[S+A+0]=b.x,g[A+1]=g[S+A+1]=b.y,g[A+2]=g[S+A+2]=b.z}}}class Lo extends Mi{constructor(e=1,t=0){super([1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],e,t),this.type="OctahedronGeometry",this.parameters={radius:e,detail:t}}}class Ml extends Qe{constructor(e,t,r){super(),this.type="ParametricGeometry",this.parameters={func:e,slices:t,stacks:r};const i=[],a=[],c=[],u=[],h=1e-5,p=new O,m=new O,g=new O,y=new O,x=new O;e.length<3&&console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");const b=t+1;for(let S=0;S<=r;S++){const M=S/r;for(let A=0;A<=t;A++){const I=A/t;e(I,M,m),a.push(m.x,m.y,m.z),I-h>=0?(e(I-h,M,g),y.subVectors(m,g)):(e(I+h,M,g),y.subVectors(g,m)),M-h>=0?(e(I,M-h,g),x.subVectors(m,g)):(e(I,M+h,g),x.subVectors(g,m)),p.crossVectors(y,x).normalize(),c.push(p.x,p.y,p.z),u.push(I,M)}}for(let S=0;S<r;S++)for(let M=0;M<t;M++){const A=S*b+M,I=S*b+M+1,k=(S+1)*b+M+1,N=(S+1)*b+M;i.push(A,I,N),i.push(I,k,N)}this.setIndex(i),this.setAttribute("position",new qe(a,3)),this.setAttribute("normal",new qe(c,3)),this.setAttribute("uv",new qe(u,2))}}class Sl extends Qe{constructor(e=.5,t=1,r=8,i=1,a=0,c=2*Math.PI){super(),this.type="RingGeometry",this.parameters={innerRadius:e,outerRadius:t,thetaSegments:r,phiSegments:i,thetaStart:a,thetaLength:c},r=Math.max(3,r);const u=[],h=[],p=[],m=[];let g=e;const y=(t-e)/(i=Math.max(1,i)),x=new O,b=new Ee;for(let S=0;S<=i;S++){for(let M=0;M<=r;M++){const A=a+M/r*c;x.x=g*Math.cos(A),x.y=g*Math.sin(A),h.push(x.x,x.y,x.z),p.push(0,0,1),b.x=(x.x/t+1)/2,b.y=(x.y/t+1)/2,m.push(b.x,b.y)}g+=y}for(let S=0;S<i;S++){const M=S*(r+1);for(let A=0;A<r;A++){const I=A+M,k=I,N=I+r+1,G=I+r+2,U=I+1;u.push(k,N,U),u.push(N,G,U)}}this.setIndex(u),this.setAttribute("position",new qe(h,3)),this.setAttribute("normal",new qe(p,3)),this.setAttribute("uv",new qe(m,2))}}class Co extends Qe{constructor(e,t=12){super(),this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:t};const r=[],i=[],a=[],c=[];let u=0,h=0;if(Array.isArray(e)===!1)p(e);else for(let m=0;m<e.length;m++)p(e[m]),this.addGroup(u,h,m),u+=h,h=0;function p(m){const g=i.length/3,y=m.extractPoints(t);let x=y.shape;const b=y.holes;Ar.isClockWise(x)===!1&&(x=x.reverse());for(let M=0,A=b.length;M<A;M++){const I=b[M];Ar.isClockWise(I)===!0&&(b[M]=I.reverse())}const S=Ar.triangulateShape(x,b);for(let M=0,A=b.length;M<A;M++){const I=b[M];x=x.concat(I)}for(let M=0,A=x.length;M<A;M++){const I=x[M];i.push(I.x,I.y,0),a.push(0,0,1),c.push(I.x,I.y)}for(let M=0,A=S.length;M<A;M++){const I=S[M],k=I[0]+g,N=I[1]+g,G=I[2]+g;r.push(k,N,G),h+=3}}this.setIndex(r),this.setAttribute("position",new qe(i,3)),this.setAttribute("normal",new qe(a,3)),this.setAttribute("uv",new qe(c,2))}toJSON(){const e=Qe.prototype.toJSON.call(this);return function(t,r){if(r.shapes=[],Array.isArray(t))for(let i=0,a=t.length;i<a;i++){const c=t[i];r.shapes.push(c.uuid)}else r.shapes.push(t.uuid);return r}(this.parameters.shapes,e)}}class Po extends Qe{constructor(e=1,t=8,r=6,i=0,a=2*Math.PI,c=0,u=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:r,phiStart:i,phiLength:a,thetaStart:c,thetaLength:u},t=Math.max(3,Math.floor(t)),r=Math.max(2,Math.floor(r));const h=Math.min(c+u,Math.PI);let p=0;const m=[],g=new O,y=new O,x=[],b=[],S=[],M=[];for(let A=0;A<=r;A++){const I=[],k=A/r;let N=0;A==0&&c==0?N=.5/t:A==r&&h==Math.PI&&(N=-.5/t);for(let G=0;G<=t;G++){const U=G/t;g.x=-e*Math.cos(i+U*a)*Math.sin(c+k*u),g.y=e*Math.cos(c+k*u),g.z=e*Math.sin(i+U*a)*Math.sin(c+k*u),b.push(g.x,g.y,g.z),y.copy(g).normalize(),S.push(y.x,y.y,y.z),M.push(U+N,1-k),I.push(p++)}m.push(I)}for(let A=0;A<r;A++)for(let I=0;I<t;I++){const k=m[A][I+1],N=m[A][I],G=m[A+1][I],U=m[A+1][I+1];(A!==0||c>0)&&x.push(k,N,U),(A!==r-1||h<Math.PI)&&x.push(N,G,U)}this.setIndex(x),this.setAttribute("position",new qe(b,3)),this.setAttribute("normal",new qe(S,3)),this.setAttribute("uv",new qe(M,2))}}class El extends Mi{constructor(e=1,t=0){super([1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],[2,1,0,0,3,2,1,3,0,2,3,1],e,t),this.type="TetrahedronGeometry",this.parameters={radius:e,detail:t}}}class Tl extends Qr{constructor(e,t={}){const r=t.font;if(!r||!r.isFont)return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),new Qe;const i=r.generateShapes(e,t.size);t.depth=t.height!==void 0?t.height:50,t.bevelThickness===void 0&&(t.bevelThickness=10),t.bevelSize===void 0&&(t.bevelSize=8),t.bevelEnabled===void 0&&(t.bevelEnabled=!1),super(i,t),this.type="TextGeometry"}}class Al extends Qe{constructor(e=1,t=.4,r=8,i=6,a=2*Math.PI){super(),this.type="TorusGeometry",this.parameters={radius:e,tube:t,radialSegments:r,tubularSegments:i,arc:a},r=Math.floor(r),i=Math.floor(i);const c=[],u=[],h=[],p=[],m=new O,g=new O,y=new O;for(let x=0;x<=r;x++)for(let b=0;b<=i;b++){const S=b/i*a,M=x/r*Math.PI*2;g.x=(e+t*Math.cos(M))*Math.cos(S),g.y=(e+t*Math.cos(M))*Math.sin(S),g.z=t*Math.sin(M),u.push(g.x,g.y,g.z),m.x=e*Math.cos(S),m.y=e*Math.sin(S),y.subVectors(g,m).normalize(),h.push(y.x,y.y,y.z),p.push(b/i),p.push(x/r)}for(let x=1;x<=r;x++)for(let b=1;b<=i;b++){const S=(i+1)*x+b-1,M=(i+1)*(x-1)+b-1,A=(i+1)*(x-1)+b,I=(i+1)*x+b;c.push(S,M,I),c.push(M,A,I)}this.setIndex(c),this.setAttribute("position",new qe(u,3)),this.setAttribute("normal",new qe(h,3)),this.setAttribute("uv",new qe(p,2))}}class Rl extends Qe{constructor(e=1,t=.4,r=64,i=8,a=2,c=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:e,tube:t,tubularSegments:r,radialSegments:i,p:a,q:c},r=Math.floor(r),i=Math.floor(i);const u=[],h=[],p=[],m=[],g=new O,y=new O,x=new O,b=new O,S=new O,M=new O,A=new O;for(let k=0;k<=r;++k){const N=k/r*a*Math.PI*2;I(N,a,c,e,x),I(N+.01,a,c,e,b),M.subVectors(b,x),A.addVectors(b,x),S.crossVectors(M,A),A.crossVectors(S,M),S.normalize(),A.normalize();for(let G=0;G<=i;++G){const U=G/i*Math.PI*2,B=-t*Math.cos(U),V=t*Math.sin(U);g.x=x.x+(B*A.x+V*S.x),g.y=x.y+(B*A.y+V*S.y),g.z=x.z+(B*A.z+V*S.z),h.push(g.x,g.y,g.z),y.subVectors(g,x).normalize(),p.push(y.x,y.y,y.z),m.push(k/r),m.push(G/i)}}for(let k=1;k<=r;k++)for(let N=1;N<=i;N++){const G=(i+1)*(k-1)+(N-1),U=(i+1)*k+(N-1),B=(i+1)*k+N,V=(i+1)*(k-1)+N;u.push(G,U,V),u.push(U,B,V)}function I(k,N,G,U,B){const V=Math.cos(k),he=Math.sin(k),Z=G/N*k,J=Math.cos(Z);B.x=U*(2+J)*.5*V,B.y=U*(2+J)*he*.5,B.z=U*Math.sin(Z)*.5}this.setIndex(u),this.setAttribute("position",new qe(h,3)),this.setAttribute("normal",new qe(p,3)),this.setAttribute("uv",new qe(m,2))}}class Ll extends Qe{constructor(e,t=64,r=1,i=8,a=!1){super(),this.type="TubeGeometry",this.parameters={path:e,tubularSegments:t,radius:r,radialSegments:i,closed:a};const c=e.computeFrenetFrames(t,a);this.tangents=c.tangents,this.normals=c.normals,this.binormals=c.binormals;const u=new O,h=new O,p=new Ee;let m=new O;const g=[],y=[],x=[],b=[];function S(M){m=e.getPointAt(M/t,m);const A=c.normals[M],I=c.binormals[M];for(let k=0;k<=i;k++){const N=k/i*Math.PI*2,G=Math.sin(N),U=-Math.cos(N);h.x=U*A.x+G*I.x,h.y=U*A.y+G*I.y,h.z=U*A.z+G*I.z,h.normalize(),y.push(h.x,h.y,h.z),u.x=m.x+r*h.x,u.y=m.y+r*h.y,u.z=m.z+r*h.z,g.push(u.x,u.y,u.z)}}(function(){for(let M=0;M<t;M++)S(M);S(a===!1?t:0),function(){for(let M=0;M<=t;M++)for(let A=0;A<=i;A++)p.x=M/t,p.y=A/i,x.push(p.x,p.y)}(),function(){for(let M=1;M<=t;M++)for(let A=1;A<=i;A++){const I=(i+1)*(M-1)+(A-1),k=(i+1)*M+(A-1),N=(i+1)*M+A,G=(i+1)*(M-1)+A;b.push(I,k,G),b.push(k,N,G)}}()})(),this.setIndex(b),this.setAttribute("position",new qe(g,3)),this.setAttribute("normal",new qe(y,3)),this.setAttribute("uv",new qe(x,2))}toJSON(){const e=Qe.prototype.toJSON.call(this);return e.path=this.parameters.path.toJSON(),e}}class Tu extends Qe{constructor(e){if(super(),this.type="WireframeGeometry",e.isGeometry===!0)return void console.error("THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");const t=[],r=[0,0],i={},a=new O;if(e.index!==null){const c=e.attributes.position,u=e.index;let h=e.groups;h.length===0&&(h=[{start:0,count:u.count,materialIndex:0}]);for(let p=0,m=h.length;p<m;++p){const g=h[p],y=g.start;for(let x=y,b=y+g.count;x<b;x+=3)for(let S=0;S<3;S++){const M=u.getX(x+S),A=u.getX(x+(S+1)%3);r[0]=Math.min(M,A),r[1]=Math.max(M,A);const I=r[0]+","+r[1];i[I]===void 0&&(i[I]={index1:r[0],index2:r[1]})}}for(const p in i){const m=i[p];a.fromBufferAttribute(c,m.index1),t.push(a.x,a.y,a.z),a.fromBufferAttribute(c,m.index2),t.push(a.x,a.y,a.z)}}else{const c=e.attributes.position;for(let u=0,h=c.count/3;u<h;u++)for(let p=0;p<3;p++){const m=3*u+p;a.fromBufferAttribute(c,m),t.push(a.x,a.y,a.z);const g=3*u+(p+1)%3;a.fromBufferAttribute(c,g),t.push(a.x,a.y,a.z)}}this.setAttribute("position",new qe(t,3))}}var Nn=Object.freeze({__proto__:null,BoxGeometry:zi,BoxBufferGeometry:zi,CircleGeometry:dl,CircleBufferGeometry:dl,ConeGeometry:pl,ConeBufferGeometry:pl,CylinderGeometry:zs,CylinderBufferGeometry:zs,DodecahedronGeometry:fl,DodecahedronBufferGeometry:fl,EdgesGeometry:Mu,ExtrudeGeometry:Qr,ExtrudeBufferGeometry:Qr,IcosahedronGeometry:bl,IcosahedronBufferGeometry:bl,LatheGeometry:wl,LatheBufferGeometry:wl,OctahedronGeometry:Lo,OctahedronBufferGeometry:Lo,ParametricGeometry:Ml,ParametricBufferGeometry:Ml,PlaneGeometry:go,PlaneBufferGeometry:go,PolyhedronGeometry:Mi,PolyhedronBufferGeometry:Mi,RingGeometry:Sl,RingBufferGeometry:Sl,ShapeGeometry:Co,ShapeBufferGeometry:Co,SphereGeometry:Po,SphereBufferGeometry:Po,TetrahedronGeometry:El,TetrahedronBufferGeometry:El,TextGeometry:Tl,TextBufferGeometry:Tl,TorusGeometry:Al,TorusBufferGeometry:Al,TorusKnotGeometry:Rl,TorusKnotBufferGeometry:Rl,TubeGeometry:Ll,TubeBufferGeometry:Ll,WireframeGeometry:Tu});class Au extends rn{constructor(e){super(),this.type="ShadowMaterial",this.color=new Ge(0),this.transparent=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this}}Au.prototype.isShadowMaterial=!0;class Gs extends Kr{constructor(e){super(e),this.type="RawShaderMaterial"}}Gs.prototype.isRawShaderMaterial=!0;class Cl extends rn{constructor(e){super(),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Ge(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ge(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Ee(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.flatShading=!1,this.vertexTangents=!1,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapIntensity=e.envMapIntensity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this.flatShading=e.flatShading,this.vertexTangents=e.vertexTangents,this}}Cl.prototype.isMeshStandardMaterial=!0;class Ru extends Cl{constructor(e){super(),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoat=0,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Ee(1,1),this.clearcoatNormalMap=null,this.reflectivity=.5,Object.defineProperty(this,"ior",{get:function(){return(1+.4*this.reflectivity)/(1-.4*this.reflectivity)},set:function(t){this.reflectivity=ct(2.5*(t-1)/(t+1),0,1)}}),this.sheen=null,this.transmission=0,this.transmissionMap=null,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.reflectivity=e.reflectivity,e.sheen?this.sheen=(this.sheen||new Ge).copy(e.sheen):this.sheen=null,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this}}Ru.prototype.isMeshPhysicalMaterial=!0;class Lu extends rn{constructor(e){super(),this.type="MeshPhongMaterial",this.color=new Ge(16777215),this.specular=new Ge(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ge(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Ee(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this.flatShading=e.flatShading,this}}Lu.prototype.isMeshPhongMaterial=!0;class Cu extends rn{constructor(e){super(),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Ge(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ge(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Ee(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this}}Cu.prototype.isMeshToonMaterial=!0;class Pu extends rn{constructor(e){super(),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Ee(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this.flatShading=e.flatShading,this}}Pu.prototype.isMeshNormalMaterial=!0;class Iu extends rn{constructor(e){super(),this.type="MeshLambertMaterial",this.color=new Ge(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ge(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this}}Iu.prototype.isMeshLambertMaterial=!0;class Ou extends rn{constructor(e){super(),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Ge(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Ee(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this.flatShading=e.flatShading,this}}Ou.prototype.isMeshMatcapMaterial=!0;class Du extends vn{constructor(e){super(),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}copy(e){return super.copy(e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this}}Du.prototype.isLineDashedMaterial=!0;var kx=Object.freeze({__proto__:null,ShadowMaterial:Au,SpriteMaterial:Qa,RawShaderMaterial:Gs,ShaderMaterial:Kr,PointsMaterial:Gi,MeshPhysicalMaterial:Ru,MeshStandardMaterial:Cl,MeshPhongMaterial:Lu,MeshToonMaterial:Cu,MeshNormalMaterial:Pu,MeshLambertMaterial:Iu,MeshDepthMaterial:Ka,MeshDistanceMaterial:$a,MeshBasicMaterial:Zr,MeshMatcapMaterial:Ou,LineDashedMaterial:Du,LineBasicMaterial:vn,Material:rn});const Wt={arraySlice:function(o,e,t){return Wt.isTypedArray(o)?new o.constructor(o.subarray(e,t!==void 0?t:o.length)):o.slice(e,t)},convertArray:function(o,e,t){return!o||!t&&o.constructor===e?o:typeof e.BYTES_PER_ELEMENT=="number"?new e(o):Array.prototype.slice.call(o)},isTypedArray:function(o){return ArrayBuffer.isView(o)&&!(o instanceof DataView)},getKeyframeOrder:function(o){const e=o.length,t=new Array(e);for(let r=0;r!==e;++r)t[r]=r;return t.sort(function(r,i){return o[r]-o[i]}),t},sortedArray:function(o,e,t){const r=o.length,i=new o.constructor(r);for(let a=0,c=0;c!==r;++a){const u=t[a]*e;for(let h=0;h!==e;++h)i[c++]=o[u+h]}return i},flattenJSON:function(o,e,t,r){let i=1,a=o[0];for(;a!==void 0&&a[r]===void 0;)a=o[i++];if(a===void 0)return;let c=a[r];if(c!==void 0)if(Array.isArray(c))do c=a[r],c!==void 0&&(e.push(a.time),t.push.apply(t,c)),a=o[i++];while(a!==void 0);else if(c.toArray!==void 0)do c=a[r],c!==void 0&&(e.push(a.time),c.toArray(t,t.length)),a=o[i++];while(a!==void 0);else do c=a[r],c!==void 0&&(e.push(a.time),t.push(c)),a=o[i++];while(a!==void 0)},subclip:function(o,e,t,r,i=30){const a=o.clone();a.name=e;const c=[];for(let h=0;h<a.tracks.length;++h){const p=a.tracks[h],m=p.getValueSize(),g=[],y=[];for(let x=0;x<p.times.length;++x){const b=p.times[x]*i;if(!(b<t||b>=r)){g.push(p.times[x]);for(let S=0;S<m;++S)y.push(p.values[x*m+S])}}g.length!==0&&(p.times=Wt.convertArray(g,p.times.constructor),p.values=Wt.convertArray(y,p.values.constructor),c.push(p))}a.tracks=c;let u=1/0;for(let h=0;h<a.tracks.length;++h)u>a.tracks[h].times[0]&&(u=a.tracks[h].times[0]);for(let h=0;h<a.tracks.length;++h)a.tracks[h].shift(-1*u);return a.resetDuration(),a},makeClipAdditive:function(o,e=0,t=o,r=30){r<=0&&(r=30);const i=t.tracks.length,a=e/r;for(let c=0;c<i;++c){const u=t.tracks[c],h=u.ValueTypeName;if(h==="bool"||h==="string")continue;const p=o.tracks.find(function(A){return A.name===u.name&&A.ValueTypeName===h});if(p===void 0)continue;let m=0;const g=u.getValueSize();u.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(m=g/3);let y=0;const x=p.getValueSize();p.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(y=x/3);const b=u.times.length-1;let S;if(a<=u.times[0]){const A=m,I=g-m;S=Wt.arraySlice(u.values,A,I)}else if(a>=u.times[b]){const A=b*g+m,I=A+g-m;S=Wt.arraySlice(u.values,A,I)}else{const A=u.createInterpolant(),I=m,k=g-m;A.evaluate(a),S=Wt.arraySlice(A.resultBuffer,I,k)}h==="quaternion"&&new fn().fromArray(S).normalize().conjugate().toArray(S);const M=p.times.length;for(let A=0;A<M;++A){const I=A*x+y;if(h==="quaternion")fn.multiplyQuaternionsFlat(p.values,I,S,0,p.values,I);else{const k=x-2*y;for(let N=0;N<k;++N)p.values[I+N]-=S[N]}}}return o.blendMode=2501,o}};class ei{constructor(e,t,r,i){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=i!==void 0?i:new t.constructor(r),this.sampleValues=t,this.valueSize=r,this.settings=null,this.DefaultSettings_={}}evaluate(e){const t=this.parameterPositions;let r=this._cachedIndex,i=t[r],a=t[r-1];e:{t:{let c;n:{r:if(!(e<i)){for(let u=r+2;;){if(i===void 0){if(e<a)break r;return r=t.length,this._cachedIndex=r,this.afterEnd_(r-1,e,a)}if(r===u)break;if(a=i,i=t[++r],e<i)break t}c=t.length;break n}if(e>=a)break e;{const u=t[1];e<u&&(r=2,a=u);for(let h=r-2;;){if(a===void 0)return this._cachedIndex=0,this.beforeStart_(0,e,i);if(r===h)break;if(i=a,a=t[--r-1],e>=a)break t}c=r,r=0}}for(;r<c;){const u=r+c>>>1;e<t[u]?c=u:r=u+1}if(i=t[r],a=t[r-1],a===void 0)return this._cachedIndex=0,this.beforeStart_(0,e,i);if(i===void 0)return r=t.length,this._cachedIndex=r,this.afterEnd_(r-1,a,e)}this._cachedIndex=r,this.intervalChanged_(r,a,i)}return this.interpolate_(r,a,e,i)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const t=this.resultBuffer,r=this.sampleValues,i=this.valueSize,a=e*i;for(let c=0;c!==i;++c)t[c]=r[a+c];return t}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}ei.prototype.beforeStart_=ei.prototype.copySampleValue_,ei.prototype.afterEnd_=ei.prototype.copySampleValue_;class df extends ei{constructor(e,t,r,i){super(e,t,r,i),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:2400,endingEnd:2400}}intervalChanged_(e,t,r){const i=this.parameterPositions;let a=e-2,c=e+1,u=i[a],h=i[c];if(u===void 0)switch(this.getSettings_().endingStart){case 2401:a=e,u=2*t-r;break;case 2402:a=i.length-2,u=t+i[a]-i[a+1];break;default:a=e,u=r}if(h===void 0)switch(this.getSettings_().endingEnd){case 2401:c=e,h=2*r-t;break;case 2402:c=1,h=r+i[1]-i[0];break;default:c=e-1,h=t}const p=.5*(r-t),m=this.valueSize;this._weightPrev=p/(t-u),this._weightNext=p/(h-r),this._offsetPrev=a*m,this._offsetNext=c*m}interpolate_(e,t,r,i){const a=this.resultBuffer,c=this.sampleValues,u=this.valueSize,h=e*u,p=h-u,m=this._offsetPrev,g=this._offsetNext,y=this._weightPrev,x=this._weightNext,b=(r-t)/(i-t),S=b*b,M=S*b,A=-y*M+2*y*S-y*b,I=(1+y)*M+(-1.5-2*y)*S+(-.5+y)*b+1,k=(-1-x)*M+(1.5+x)*S+.5*b,N=x*M-x*S;for(let G=0;G!==u;++G)a[G]=A*c[m+G]+I*c[p+G]+k*c[h+G]+N*c[g+G];return a}}class Nu extends ei{constructor(e,t,r,i){super(e,t,r,i)}interpolate_(e,t,r,i){const a=this.resultBuffer,c=this.sampleValues,u=this.valueSize,h=e*u,p=h-u,m=(r-t)/(i-t),g=1-m;for(let y=0;y!==u;++y)a[y]=c[p+y]*g+c[h+y]*m;return a}}class pf extends ei{constructor(e,t,r,i){super(e,t,r,i)}interpolate_(e){return this.copySampleValue_(e-1)}}class fr{constructor(e,t,r,i){if(e===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(t===void 0||t.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=Wt.convertArray(t,this.TimeBufferType),this.values=Wt.convertArray(r,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}static toJSON(e){const t=e.constructor;let r;if(t.toJSON!==this.toJSON)r=t.toJSON(e);else{r={name:e.name,times:Wt.convertArray(e.times,Array),values:Wt.convertArray(e.values,Array)};const i=e.getInterpolation();i!==e.DefaultInterpolation&&(r.interpolation=i)}return r.type=e.ValueTypeName,r}InterpolantFactoryMethodDiscrete(e){return new pf(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new Nu(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new df(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let t;switch(e){case 2300:t=this.InterpolantFactoryMethodDiscrete;break;case 2301:t=this.InterpolantFactoryMethodLinear;break;case 2302:t=this.InterpolantFactoryMethodSmooth}if(t===void 0){const r="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0){if(e===this.DefaultInterpolation)throw new Error(r);this.setInterpolation(this.DefaultInterpolation)}return console.warn("THREE.KeyframeTrack:",r),this}return this.createInterpolant=t,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return 2300;case this.InterpolantFactoryMethodLinear:return 2301;case this.InterpolantFactoryMethodSmooth:return 2302}}getValueSize(){return this.values.length/this.times.length}shift(e){if(e!==0){const t=this.times;for(let r=0,i=t.length;r!==i;++r)t[r]+=e}return this}scale(e){if(e!==1){const t=this.times;for(let r=0,i=t.length;r!==i;++r)t[r]*=e}return this}trim(e,t){const r=this.times,i=r.length;let a=0,c=i-1;for(;a!==i&&r[a]<e;)++a;for(;c!==-1&&r[c]>t;)--c;if(++c,a!==0||c!==i){a>=c&&(c=Math.max(c,1),a=c-1);const u=this.getValueSize();this.times=Wt.arraySlice(r,a,c),this.values=Wt.arraySlice(this.values,a*u,c*u)}return this}validate(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const r=this.times,i=this.values,a=r.length;a===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let c=null;for(let u=0;u!==a;u++){const h=r[u];if(typeof h=="number"&&isNaN(h)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,u,h),e=!1;break}if(c!==null&&c>h){console.error("THREE.KeyframeTrack: Out of order keys.",this,u,h,c),e=!1;break}c=h}if(i!==void 0&&Wt.isTypedArray(i))for(let u=0,h=i.length;u!==h;++u){const p=i[u];if(isNaN(p)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,u,p),e=!1;break}}return e}optimize(){const e=Wt.arraySlice(this.times),t=Wt.arraySlice(this.values),r=this.getValueSize(),i=this.getInterpolation()===2302,a=e.length-1;let c=1;for(let u=1;u<a;++u){let h=!1;const p=e[u];if(p!==e[u+1]&&(u!==1||p!==e[0]))if(i)h=!0;else{const m=u*r,g=m-r,y=m+r;for(let x=0;x!==r;++x){const b=t[m+x];if(b!==t[g+x]||b!==t[y+x]){h=!0;break}}}if(h){if(u!==c){e[c]=e[u];const m=u*r,g=c*r;for(let y=0;y!==r;++y)t[g+y]=t[m+y]}++c}}if(a>0){e[c]=e[a];for(let u=a*r,h=c*r,p=0;p!==r;++p)t[h+p]=t[u+p];++c}return c!==e.length?(this.times=Wt.arraySlice(e,0,c),this.values=Wt.arraySlice(t,0,c*r)):(this.times=e,this.values=t),this}clone(){const e=Wt.arraySlice(this.times,0),t=Wt.arraySlice(this.values,0),r=new this.constructor(this.name,e,t);return r.createInterpolant=this.createInterpolant,r}}fr.prototype.TimeBufferType=Float32Array,fr.prototype.ValueBufferType=Float32Array,fr.prototype.DefaultInterpolation=2301;class Vi extends fr{}Vi.prototype.ValueTypeName="bool",Vi.prototype.ValueBufferType=Array,Vi.prototype.DefaultInterpolation=2300,Vi.prototype.InterpolantFactoryMethodLinear=void 0,Vi.prototype.InterpolantFactoryMethodSmooth=void 0;class ku extends fr{}ku.prototype.ValueTypeName="color";class Io extends fr{}Io.prototype.ValueTypeName="number";class ff extends ei{constructor(e,t,r,i){super(e,t,r,i)}interpolate_(e,t,r,i){const a=this.resultBuffer,c=this.sampleValues,u=this.valueSize,h=(r-t)/(i-t);let p=e*u;for(let m=p+u;p!==m;p+=4)fn.slerpFlat(a,0,c,p-u,c,p,h);return a}}class Vs extends fr{InterpolantFactoryMethodLinear(e){return new ff(this.times,this.values,this.getValueSize(),e)}}Vs.prototype.ValueTypeName="quaternion",Vs.prototype.DefaultInterpolation=2301,Vs.prototype.InterpolantFactoryMethodSmooth=void 0;class Wi extends fr{}Wi.prototype.ValueTypeName="string",Wi.prototype.ValueBufferType=Array,Wi.prototype.DefaultInterpolation=2300,Wi.prototype.InterpolantFactoryMethodLinear=void 0,Wi.prototype.InterpolantFactoryMethodSmooth=void 0;class Oo extends fr{}Oo.prototype.ValueTypeName="vector";class Do{constructor(e,t=-1,r,i=2500){this.name=e,this.tracks=r,this.duration=t,this.blendMode=i,this.uuid=it(),this.duration<0&&this.resetDuration()}static parse(e){const t=[],r=e.tracks,i=1/(e.fps||1);for(let c=0,u=r.length;c!==u;++c)t.push(Hx(r[c]).scale(i));const a=new this(e.name,e.duration,t,e.blendMode);return a.uuid=e.uuid,a}static toJSON(e){const t=[],r=e.tracks,i={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode};for(let a=0,c=r.length;a!==c;++a)t.push(fr.toJSON(r[a]));return i}static CreateFromMorphTargetSequence(e,t,r,i){const a=t.length,c=[];for(let u=0;u<a;u++){let h=[],p=[];h.push((u+a-1)%a,u,(u+1)%a),p.push(0,1,0);const m=Wt.getKeyframeOrder(h);h=Wt.sortedArray(h,1,m),p=Wt.sortedArray(p,1,m),i||h[0]!==0||(h.push(a),p.push(p[0])),c.push(new Io(".morphTargetInfluences["+t[u].name+"]",h,p).scale(1/r))}return new this(e,-1,c)}static findByName(e,t){let r=e;if(!Array.isArray(e)){const i=e;r=i.geometry&&i.geometry.animations||i.animations}for(let i=0;i<r.length;i++)if(r[i].name===t)return r[i];return null}static CreateClipsFromMorphTargetSequences(e,t,r){const i={},a=/^([\w-]*?)([\d]+)$/;for(let u=0,h=e.length;u<h;u++){const p=e[u],m=p.name.match(a);if(m&&m.length>1){const g=m[1];let y=i[g];y||(i[g]=y=[]),y.push(p)}}const c=[];for(const u in i)c.push(this.CreateFromMorphTargetSequence(u,i[u],t,r));return c}static parseAnimation(e,t){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const r=function(m,g,y,x,b){if(y.length!==0){const S=[],M=[];Wt.flattenJSON(y,S,M,x),S.length!==0&&b.push(new m(g,S,M))}},i=[],a=e.name||"default",c=e.fps||30,u=e.blendMode;let h=e.length||-1;const p=e.hierarchy||[];for(let m=0;m<p.length;m++){const g=p[m].keys;if(g&&g.length!==0)if(g[0].morphTargets){const y={};let x;for(x=0;x<g.length;x++)if(g[x].morphTargets)for(let b=0;b<g[x].morphTargets.length;b++)y[g[x].morphTargets[b]]=-1;for(const b in y){const S=[],M=[];for(let A=0;A!==g[x].morphTargets.length;++A){const I=g[x];S.push(I.time),M.push(I.morphTarget===b?1:0)}i.push(new Io(".morphTargetInfluence["+b+"]",S,M))}h=y.length*c}else{const y=".bones["+t[m].name+"]";r(Oo,y+".position",g,"pos",i),r(Vs,y+".quaternion",g,"rot",i),r(Oo,y+".scale",g,"scl",i)}}return i.length===0?null:new this(a,h,i,u)}resetDuration(){let e=0;for(let t=0,r=this.tracks.length;t!==r;++t){const i=this.tracks[t];e=Math.max(e,i.times[i.times.length-1])}return this.duration=e,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new this.constructor(this.name,this.duration,e,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function Hx(o){if(o.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=function(t){switch(t.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return Io;case"vector":case"vector2":case"vector3":case"vector4":return Oo;case"color":return ku;case"quaternion":return Vs;case"bool":case"boolean":return Vi;case"string":return Wi}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+t)}(o.type);if(o.times===void 0){const t=[],r=[];Wt.flattenJSON(o.keys,t,r,"value"),o.times=t,o.values=r}return e.parse!==void 0?e.parse(o):new e(o.name,o.times,o.values,o.interpolation)}const ji={enabled:!1,files:{},add:function(o,e){this.enabled!==!1&&(this.files[o]=e)},get:function(o){if(this.enabled!==!1)return this.files[o]},remove:function(o){delete this.files[o]},clear:function(){this.files={}}};class Hu{constructor(e,t,r){const i=this;let a,c=!1,u=0,h=0;const p=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=r,this.itemStart=function(m){h++,c===!1&&i.onStart!==void 0&&i.onStart(m,u,h),c=!0},this.itemEnd=function(m){u++,i.onProgress!==void 0&&i.onProgress(m,u,h),u===h&&(c=!1,i.onLoad!==void 0&&i.onLoad())},this.itemError=function(m){i.onError!==void 0&&i.onError(m)},this.resolveURL=function(m){return a?a(m):m},this.setURLModifier=function(m){return a=m,this},this.addHandler=function(m,g){return p.push(m,g),this},this.removeHandler=function(m){const g=p.indexOf(m);return g!==-1&&p.splice(g,2),this},this.getHandler=function(m){for(let g=0,y=p.length;g<y;g+=2){const x=p[g],b=p[g+1];if(x.global&&(x.lastIndex=0),x.test(m))return b}return null}}}const mf=new Hu;class Rn{constructor(e){this.manager=e!==void 0?e:mf,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,t){const r=this;return new Promise(function(i,a){r.load(e,i,t,a)})}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}}const mr={};class Rr extends Rn{constructor(e){super(e)}load(e,t,r,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const a=this,c=ji.get(e);if(c!==void 0)return a.manager.itemStart(e),setTimeout(function(){t&&t(c),a.manager.itemEnd(e)},0),c;if(mr[e]!==void 0)return void mr[e].push({onLoad:t,onProgress:r,onError:i});const u=e.match(/^data:(.*?)(;base64)?,(.*)$/);let h;if(u){const p=u[1],m=!!u[2];let g=u[3];g=decodeURIComponent(g),m&&(g=atob(g));try{let y;const x=(this.responseType||"").toLowerCase();switch(x){case"arraybuffer":case"blob":const b=new Uint8Array(g.length);for(let M=0;M<g.length;M++)b[M]=g.charCodeAt(M);y=x==="blob"?new Blob([b.buffer],{type:p}):b.buffer;break;case"document":y=new DOMParser().parseFromString(g,p);break;case"json":y=JSON.parse(g);break;default:y=g}setTimeout(function(){t&&t(y),a.manager.itemEnd(e)},0)}catch(y){setTimeout(function(){i&&i(y),a.manager.itemError(e),a.manager.itemEnd(e)},0)}}else{mr[e]=[],mr[e].push({onLoad:t,onProgress:r,onError:i}),h=new XMLHttpRequest,h.open("GET",e,!0),h.addEventListener("load",function(p){const m=this.response,g=mr[e];if(delete mr[e],this.status===200||this.status===0){this.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),ji.add(e,m);for(let y=0,x=g.length;y<x;y++){const b=g[y];b.onLoad&&b.onLoad(m)}a.manager.itemEnd(e)}else{for(let y=0,x=g.length;y<x;y++){const b=g[y];b.onError&&b.onError(p)}a.manager.itemError(e),a.manager.itemEnd(e)}},!1),h.addEventListener("progress",function(p){const m=mr[e];for(let g=0,y=m.length;g<y;g++){const x=m[g];x.onProgress&&x.onProgress(p)}},!1),h.addEventListener("error",function(p){const m=mr[e];delete mr[e];for(let g=0,y=m.length;g<y;g++){const x=m[g];x.onError&&x.onError(p)}a.manager.itemError(e),a.manager.itemEnd(e)},!1),h.addEventListener("abort",function(p){const m=mr[e];delete mr[e];for(let g=0,y=m.length;g<y;g++){const x=m[g];x.onError&&x.onError(p)}a.manager.itemError(e),a.manager.itemEnd(e)},!1),this.responseType!==void 0&&(h.responseType=this.responseType),this.withCredentials!==void 0&&(h.withCredentials=this.withCredentials),h.overrideMimeType&&h.overrideMimeType(this.mimeType!==void 0?this.mimeType:"text/plain");for(const p in this.requestHeader)h.setRequestHeader(p,this.requestHeader[p]);h.send(null)}return a.manager.itemStart(e),h}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}}class Pl extends Rn{constructor(e){super(e)}load(e,t,r,i){this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const a=this,c=ji.get(e);if(c!==void 0)return a.manager.itemStart(e),setTimeout(function(){t&&t(c),a.manager.itemEnd(e)},0),c;const u=document.createElementNS("http://www.w3.org/1999/xhtml","img");function h(){u.removeEventListener("load",h,!1),u.removeEventListener("error",p,!1),ji.add(e,this),t&&t(this),a.manager.itemEnd(e)}function p(m){u.removeEventListener("load",h,!1),u.removeEventListener("error",p,!1),i&&i(m),a.manager.itemError(e),a.manager.itemEnd(e)}return u.addEventListener("load",h,!1),u.addEventListener("error",p,!1),e.substr(0,5)!=="data:"&&this.crossOrigin!==void 0&&(u.crossOrigin=this.crossOrigin),a.manager.itemStart(e),u.src=e,u}}class gf extends Rn{constructor(e){super(e)}load(e,t,r,i){const a=new Is,c=new Pl(this.manager);c.setCrossOrigin(this.crossOrigin),c.setPath(this.path);let u=0;function h(p){c.load(e[p],function(m){a.images[p]=m,u++,u===6&&(a.needsUpdate=!0,t&&t(a))},void 0,i)}for(let p=0;p<e.length;++p)h(p);return a}}class vf extends Rn{constructor(e){super(e)}load(e,t,r,i){const a=this,c=new Os,u=new Rr(this.manager);return u.setResponseType("arraybuffer"),u.setRequestHeader(this.requestHeader),u.setPath(this.path),u.setWithCredentials(a.withCredentials),u.load(e,function(h){const p=a.parse(h);p&&(p.image!==void 0?c.image=p.image:p.data!==void 0&&(c.image.width=p.width,c.image.height=p.height,c.image.data=p.data),c.wrapS=p.wrapS!==void 0?p.wrapS:1001,c.wrapT=p.wrapT!==void 0?p.wrapT:1001,c.magFilter=p.magFilter!==void 0?p.magFilter:1006,c.minFilter=p.minFilter!==void 0?p.minFilter:1006,c.anisotropy=p.anisotropy!==void 0?p.anisotropy:1,p.encoding!==void 0&&(c.encoding=p.encoding),p.flipY!==void 0&&(c.flipY=p.flipY),p.format!==void 0&&(c.format=p.format),p.type!==void 0&&(c.type=p.type),p.mipmaps!==void 0&&(c.mipmaps=p.mipmaps,c.minFilter=1008),p.mipmapCount===1&&(c.minFilter=1006),p.generateMipmaps!==void 0&&(c.generateMipmaps=p.generateMipmaps),c.needsUpdate=!0,t&&t(c,p))},r,i),c}}class yf extends Rn{constructor(e){super(e)}load(e,t,r,i){const a=new un,c=new Pl(this.manager);return c.setCrossOrigin(this.crossOrigin),c.setPath(this.path),c.load(e,function(u){a.image=u;const h=e.search(/\.jpe?g($|\?)/i)>0||e.search(/^data\:image\/jpeg/)===0;a.format=h?1022:1023,a.needsUpdate=!0,t!==void 0&&t(a)},r,i),a}}class Qn{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(e,t){const r=this.getUtoTmapping(e);return this.getPoint(r,t)}getPoints(e=5){const t=[];for(let r=0;r<=e;r++)t.push(this.getPoint(r/e));return t}getSpacedPoints(e=5){const t=[];for(let r=0;r<=e;r++)t.push(this.getPointAt(r/e));return t}getLength(){const e=this.getLengths();return e[e.length-1]}getLengths(e=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const t=[];let r,i=this.getPoint(0),a=0;t.push(0);for(let c=1;c<=e;c++)r=this.getPoint(c/e),a+=r.distanceTo(i),t.push(a),i=r;return this.cacheArcLengths=t,t}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(e,t){const r=this.getLengths();let i=0;const a=r.length;let c;c=t||e*r[a-1];let u,h=0,p=a-1;for(;h<=p;)if(i=Math.floor(h+(p-h)/2),u=r[i]-c,u<0)h=i+1;else{if(!(u>0)){p=i;break}p=i-1}if(i=p,r[i]===c)return i/(a-1);const m=r[i];return(i+(c-m)/(r[i+1]-m))/(a-1)}getTangent(e,t){let i=e-1e-4,a=e+1e-4;i<0&&(i=0),a>1&&(a=1);const c=this.getPoint(i),u=this.getPoint(a),h=t||(c.isVector2?new Ee:new O);return h.copy(u).sub(c).normalize(),h}getTangentAt(e,t){const r=this.getUtoTmapping(e);return this.getTangent(r,t)}computeFrenetFrames(e,t){const r=new O,i=[],a=[],c=[],u=new O,h=new Ze;for(let x=0;x<=e;x++){const b=x/e;i[x]=this.getTangentAt(b,new O),i[x].normalize()}a[0]=new O,c[0]=new O;let p=Number.MAX_VALUE;const m=Math.abs(i[0].x),g=Math.abs(i[0].y),y=Math.abs(i[0].z);m<=p&&(p=m,r.set(1,0,0)),g<=p&&(p=g,r.set(0,1,0)),y<=p&&r.set(0,0,1),u.crossVectors(i[0],r).normalize(),a[0].crossVectors(i[0],u),c[0].crossVectors(i[0],a[0]);for(let x=1;x<=e;x++){if(a[x]=a[x-1].clone(),c[x]=c[x-1].clone(),u.crossVectors(i[x-1],i[x]),u.length()>Number.EPSILON){u.normalize();const b=Math.acos(ct(i[x-1].dot(i[x]),-1,1));a[x].applyMatrix4(h.makeRotationAxis(u,b))}c[x].crossVectors(i[x],a[x])}if(t===!0){let x=Math.acos(ct(a[0].dot(a[e]),-1,1));x/=e,i[0].dot(u.crossVectors(a[0],a[e]))>0&&(x=-x);for(let b=1;b<=e;b++)a[b].applyMatrix4(h.makeRotationAxis(i[b],x*b)),c[b].crossVectors(i[b],a[b])}return{tangents:i,normals:a,binormals:c}}clone(){return new this.constructor().copy(this)}copy(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}toJSON(){const e={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e}fromJSON(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}class No extends Qn{constructor(e=0,t=0,r=1,i=1,a=0,c=2*Math.PI,u=!1,h=0){super(),this.type="EllipseCurve",this.aX=e,this.aY=t,this.xRadius=r,this.yRadius=i,this.aStartAngle=a,this.aEndAngle=c,this.aClockwise=u,this.aRotation=h}getPoint(e,t){const r=t||new Ee,i=2*Math.PI;let a=this.aEndAngle-this.aStartAngle;const c=Math.abs(a)<Number.EPSILON;for(;a<0;)a+=i;for(;a>i;)a-=i;a<Number.EPSILON&&(a=c?0:i),this.aClockwise!==!0||c||(a===i?a=-i:a-=i);const u=this.aStartAngle+e*a;let h=this.aX+this.xRadius*Math.cos(u),p=this.aY+this.yRadius*Math.sin(u);if(this.aRotation!==0){const m=Math.cos(this.aRotation),g=Math.sin(this.aRotation),y=h-this.aX,x=p-this.aY;h=y*m-x*g+this.aX,p=y*g+x*m+this.aY}return r.set(h,p)}copy(e){return super.copy(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}toJSON(){const e=super.toJSON();return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e}fromJSON(e){return super.fromJSON(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}}No.prototype.isEllipseCurve=!0;class Fu extends No{constructor(e,t,r,i,a,c){super(e,t,r,r,i,a,c),this.type="ArcCurve"}}function Bu(){let o=0,e=0,t=0,r=0;function i(a,c,u,h){o=a,e=u,t=-3*a+3*c-2*u-h,r=2*a-2*c+u+h}return{initCatmullRom:function(a,c,u,h,p){i(c,u,p*(u-a),p*(h-c))},initNonuniformCatmullRom:function(a,c,u,h,p,m,g){let y=(c-a)/p-(u-a)/(p+m)+(u-c)/m,x=(u-c)/m-(h-c)/(m+g)+(h-u)/g;y*=m,x*=m,i(c,u,y,x)},calc:function(a){const c=a*a;return o+e*a+t*c+r*(c*a)}}}Fu.prototype.isArcCurve=!0;const Il=new O,zu=new Bu,Uu=new Bu,Gu=new Bu;class Vu extends Qn{constructor(e=[],t=!1,r="centripetal",i=.5){super(),this.type="CatmullRomCurve3",this.points=e,this.closed=t,this.curveType=r,this.tension=i}getPoint(e,t=new O){const r=t,i=this.points,a=i.length,c=(a-(this.closed?0:1))*e;let u,h,p=Math.floor(c),m=c-p;this.closed?p+=p>0?0:(Math.floor(Math.abs(p)/a)+1)*a:m===0&&p===a-1&&(p=a-2,m=1),this.closed||p>0?u=i[(p-1)%a]:(Il.subVectors(i[0],i[1]).add(i[0]),u=Il);const g=i[p%a],y=i[(p+1)%a];if(this.closed||p+2<a?h=i[(p+2)%a]:(Il.subVectors(i[a-1],i[a-2]).add(i[a-1]),h=Il),this.curveType==="centripetal"||this.curveType==="chordal"){const x=this.curveType==="chordal"?.5:.25;let b=Math.pow(u.distanceToSquared(g),x),S=Math.pow(g.distanceToSquared(y),x),M=Math.pow(y.distanceToSquared(h),x);S<1e-4&&(S=1),b<1e-4&&(b=S),M<1e-4&&(M=S),zu.initNonuniformCatmullRom(u.x,g.x,y.x,h.x,b,S,M),Uu.initNonuniformCatmullRom(u.y,g.y,y.y,h.y,b,S,M),Gu.initNonuniformCatmullRom(u.z,g.z,y.z,h.z,b,S,M)}else this.curveType==="catmullrom"&&(zu.initCatmullRom(u.x,g.x,y.x,h.x,this.tension),Uu.initCatmullRom(u.y,g.y,y.y,h.y,this.tension),Gu.initCatmullRom(u.z,g.z,y.z,h.z,this.tension));return r.set(zu.calc(m),Uu.calc(m),Gu.calc(m)),r}copy(e){super.copy(e),this.points=[];for(let t=0,r=e.points.length;t<r;t++){const i=e.points[t];this.points.push(i.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,r=this.points.length;t<r;t++){const i=this.points[t];e.points.push(i.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,r=e.points.length;t<r;t++){const i=e.points[t];this.points.push(new O().fromArray(i))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}}function xf(o,e,t,r,i){const a=.5*(r-e),c=.5*(i-t),u=o*o;return(2*t-2*r+a+c)*(o*u)+(-3*t+3*r-2*a-c)*u+a*o+t}function ko(o,e,t,r){return function(i,a){const c=1-i;return c*c*a}(o,e)+function(i,a){return 2*(1-i)*i*a}(o,t)+function(i,a){return i*i*a}(o,r)}function Ho(o,e,t,r,i){return function(a,c){const u=1-a;return u*u*u*c}(o,e)+function(a,c){const u=1-a;return 3*u*u*a*c}(o,t)+function(a,c){return 3*(1-a)*a*a*c}(o,r)+function(a,c){return a*a*a*c}(o,i)}Vu.prototype.isCatmullRomCurve3=!0;class Ol extends Qn{constructor(e=new Ee,t=new Ee,r=new Ee,i=new Ee){super(),this.type="CubicBezierCurve",this.v0=e,this.v1=t,this.v2=r,this.v3=i}getPoint(e,t=new Ee){const r=t,i=this.v0,a=this.v1,c=this.v2,u=this.v3;return r.set(Ho(e,i.x,a.x,c.x,u.x),Ho(e,i.y,a.y,c.y,u.y)),r}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}Ol.prototype.isCubicBezierCurve=!0;class Wu extends Qn{constructor(e=new O,t=new O,r=new O,i=new O){super(),this.type="CubicBezierCurve3",this.v0=e,this.v1=t,this.v2=r,this.v3=i}getPoint(e,t=new O){const r=t,i=this.v0,a=this.v1,c=this.v2,u=this.v3;return r.set(Ho(e,i.x,a.x,c.x,u.x),Ho(e,i.y,a.y,c.y,u.y),Ho(e,i.z,a.z,c.z,u.z)),r}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}Wu.prototype.isCubicBezierCurve3=!0;class Fo extends Qn{constructor(e=new Ee,t=new Ee){super(),this.type="LineCurve",this.v1=e,this.v2=t}getPoint(e,t=new Ee){const r=t;return e===1?r.copy(this.v2):(r.copy(this.v2).sub(this.v1),r.multiplyScalar(e).add(this.v1)),r}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t){const r=t||new Ee;return r.copy(this.v2).sub(this.v1).normalize(),r}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}Fo.prototype.isLineCurve=!0;class _f extends Qn{constructor(e=new O,t=new O){super(),this.type="LineCurve3",this.isLineCurve3=!0,this.v1=e,this.v2=t}getPoint(e,t=new O){const r=t;return e===1?r.copy(this.v2):(r.copy(this.v2).sub(this.v1),r.multiplyScalar(e).add(this.v1)),r}getPointAt(e,t){return this.getPoint(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class Dl extends Qn{constructor(e=new Ee,t=new Ee,r=new Ee){super(),this.type="QuadraticBezierCurve",this.v0=e,this.v1=t,this.v2=r}getPoint(e,t=new Ee){const r=t,i=this.v0,a=this.v1,c=this.v2;return r.set(ko(e,i.x,a.x,c.x),ko(e,i.y,a.y,c.y)),r}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}Dl.prototype.isQuadraticBezierCurve=!0;class ju extends Qn{constructor(e=new O,t=new O,r=new O){super(),this.type="QuadraticBezierCurve3",this.v0=e,this.v1=t,this.v2=r}getPoint(e,t=new O){const r=t,i=this.v0,a=this.v1,c=this.v2;return r.set(ko(e,i.x,a.x,c.x),ko(e,i.y,a.y,c.y),ko(e,i.z,a.z,c.z)),r}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}ju.prototype.isQuadraticBezierCurve3=!0;class Nl extends Qn{constructor(e=[]){super(),this.type="SplineCurve",this.points=e}getPoint(e,t=new Ee){const r=t,i=this.points,a=(i.length-1)*e,c=Math.floor(a),u=a-c,h=i[c===0?c:c-1],p=i[c],m=i[c>i.length-2?i.length-1:c+1],g=i[c>i.length-3?i.length-1:c+2];return r.set(xf(u,h.x,p.x,m.x,g.x),xf(u,h.y,p.y,m.y,g.y)),r}copy(e){super.copy(e),this.points=[];for(let t=0,r=e.points.length;t<r;t++){const i=e.points[t];this.points.push(i.clone())}return this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,r=this.points.length;t<r;t++){const i=this.points[t];e.points.push(i.toArray())}return e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,r=e.points.length;t<r;t++){const i=e.points[t];this.points.push(new Ee().fromArray(i))}return this}}Nl.prototype.isSplineCurve=!0;var qu=Object.freeze({__proto__:null,ArcCurve:Fu,CatmullRomCurve3:Vu,CubicBezierCurve:Ol,CubicBezierCurve3:Wu,EllipseCurve:No,LineCurve:Fo,LineCurve3:_f,QuadraticBezierCurve:Dl,QuadraticBezierCurve3:ju,SplineCurve:Nl});class bf extends Qn{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(e){this.curves.push(e)}closePath(){const e=this.curves[0].getPoint(0),t=this.curves[this.curves.length-1].getPoint(1);e.equals(t)||this.curves.push(new Fo(t,e))}getPoint(e){const t=e*this.getLength(),r=this.getCurveLengths();let i=0;for(;i<r.length;){if(r[i]>=t){const a=r[i]-t,c=this.curves[i],u=c.getLength(),h=u===0?0:1-a/u;return c.getPointAt(h)}i++}return null}getLength(){const e=this.getCurveLengths();return e[e.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let t=0;for(let r=0,i=this.curves.length;r<i;r++)t+=this.curves[r].getLength(),e.push(t);return this.cacheLengths=e,e}getSpacedPoints(e=40){const t=[];for(let r=0;r<=e;r++)t.push(this.getPoint(r/e));return this.autoClose&&t.push(t[0]),t}getPoints(e=12){const t=[];let r;for(let i=0,a=this.curves;i<a.length;i++){const c=a[i],u=c&&c.isEllipseCurve?2*e:c&&(c.isLineCurve||c.isLineCurve3)?1:c&&c.isSplineCurve?e*c.points.length:e,h=c.getPoints(u);for(let p=0;p<h.length;p++){const m=h[p];r&&r.equals(m)||(t.push(m),r=m)}}return this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]),t}copy(e){super.copy(e),this.curves=[];for(let t=0,r=e.curves.length;t<r;t++){const i=e.curves[t];this.curves.push(i.clone())}return this.autoClose=e.autoClose,this}toJSON(){const e=super.toJSON();e.autoClose=this.autoClose,e.curves=[];for(let t=0,r=this.curves.length;t<r;t++){const i=this.curves[t];e.curves.push(i.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.autoClose=e.autoClose,this.curves=[];for(let t=0,r=e.curves.length;t<r;t++){const i=e.curves[t];this.curves.push(new qu[i.type]().fromJSON(i))}return this}}class Bo extends bf{constructor(e){super(),this.type="Path",this.currentPoint=new Ee,e&&this.setFromPoints(e)}setFromPoints(e){this.moveTo(e[0].x,e[0].y);for(let t=1,r=e.length;t<r;t++)this.lineTo(e[t].x,e[t].y);return this}moveTo(e,t){return this.currentPoint.set(e,t),this}lineTo(e,t){const r=new Fo(this.currentPoint.clone(),new Ee(e,t));return this.curves.push(r),this.currentPoint.set(e,t),this}quadraticCurveTo(e,t,r,i){const a=new Dl(this.currentPoint.clone(),new Ee(e,t),new Ee(r,i));return this.curves.push(a),this.currentPoint.set(r,i),this}bezierCurveTo(e,t,r,i,a,c){const u=new Ol(this.currentPoint.clone(),new Ee(e,t),new Ee(r,i),new Ee(a,c));return this.curves.push(u),this.currentPoint.set(a,c),this}splineThru(e){const t=[this.currentPoint.clone()].concat(e),r=new Nl(t);return this.curves.push(r),this.currentPoint.copy(e[e.length-1]),this}arc(e,t,r,i,a,c){const u=this.currentPoint.x,h=this.currentPoint.y;return this.absarc(e+u,t+h,r,i,a,c),this}absarc(e,t,r,i,a,c){return this.absellipse(e,t,r,r,i,a,c),this}ellipse(e,t,r,i,a,c,u,h){const p=this.currentPoint.x,m=this.currentPoint.y;return this.absellipse(e+p,t+m,r,i,a,c,u,h),this}absellipse(e,t,r,i,a,c,u,h){const p=new No(e,t,r,i,a,c,u,h);if(this.curves.length>0){const g=p.getPoint(0);g.equals(this.currentPoint)||this.lineTo(g.x,g.y)}this.curves.push(p);const m=p.getPoint(1);return this.currentPoint.copy(m),this}copy(e){return super.copy(e),this.currentPoint.copy(e.currentPoint),this}toJSON(){const e=super.toJSON();return e.currentPoint=this.currentPoint.toArray(),e}fromJSON(e){return super.fromJSON(e),this.currentPoint.fromArray(e.currentPoint),this}}class Ei extends Bo{constructor(e){super(e),this.uuid=it(),this.type="Shape",this.holes=[]}getPointsHoles(e){const t=[];for(let r=0,i=this.holes.length;r<i;r++)t[r]=this.holes[r].getPoints(e);return t}extractPoints(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}}copy(e){super.copy(e),this.holes=[];for(let t=0,r=e.holes.length;t<r;t++){const i=e.holes[t];this.holes.push(i.clone())}return this}toJSON(){const e=super.toJSON();e.uuid=this.uuid,e.holes=[];for(let t=0,r=this.holes.length;t<r;t++){const i=this.holes[t];e.holes.push(i.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.uuid=e.uuid,this.holes=[];for(let t=0,r=e.holes.length;t<r;t++){const i=e.holes[t];this.holes.push(new Bo().fromJSON(i))}return this}}class gr extends yt{constructor(e,t=1){super(),this.type="Light",this.color=new Ge(e),this.intensity=t}dispose(){}copy(e){return super.copy(e),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,this.groundColor!==void 0&&(t.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(t.object.distance=this.distance),this.angle!==void 0&&(t.object.angle=this.angle),this.decay!==void 0&&(t.object.decay=this.decay),this.penumbra!==void 0&&(t.object.penumbra=this.penumbra),this.shadow!==void 0&&(t.object.shadow=this.shadow.toJSON()),t}}gr.prototype.isLight=!0;class Xu extends gr{constructor(e,t,r){super(e,r),this.type="HemisphereLight",this.position.copy(yt.DefaultUp),this.updateMatrix(),this.groundColor=new Ge(t)}copy(e){return gr.prototype.copy.call(this,e),this.groundColor.copy(e.groundColor),this}}Xu.prototype.isHemisphereLight=!0;const wf=new Ze,Mf=new O,Sf=new O;class Yu{constructor(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.mapSize=new Ee(512,512),this.map=null,this.mapPass=null,this.matrix=new Ze,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new mo,this._frameExtents=new Ee(1,1),this._viewportCount=1,this._viewports=[new Dt(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const t=this.camera,r=this.matrix;Mf.setFromMatrixPosition(e.matrixWorld),t.position.copy(Mf),Sf.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(Sf),t.updateMatrixWorld(),wf.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(wf),r.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),r.multiply(t.projectionMatrix),r.multiply(t.matrixWorldInverse)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const e={};return this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),this.mapSize.x===512&&this.mapSize.y===512||(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class Ef extends Yu{constructor(){super(new gn(50,1,.5,500)),this.focus=1}updateMatrices(e){const t=this.camera,r=2*tt*e.angle*this.focus,i=this.mapSize.width/this.mapSize.height,a=e.distance||t.far;r===t.fov&&i===t.aspect&&a===t.far||(t.fov=r,t.aspect=i,t.far=a,t.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}Ef.prototype.isSpotLightShadow=!0;class Zu extends gr{constructor(e,t,r=0,i=Math.PI/3,a=0,c=1){super(e,t),this.type="SpotLight",this.position.copy(yt.DefaultUp),this.updateMatrix(),this.target=new yt,this.distance=r,this.angle=i,this.penumbra=a,this.decay=c,this.shadow=new Ef}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}Zu.prototype.isSpotLight=!0;const Tf=new Ze,zo=new O,Ku=new O;class Af extends Yu{constructor(){super(new gn(90,1,.5,500)),this._frameExtents=new Ee(4,2),this._viewportCount=6,this._viewports=[new Dt(2,1,1,1),new Dt(0,1,1,1),new Dt(3,1,1,1),new Dt(1,1,1,1),new Dt(3,0,1,1),new Dt(1,0,1,1)],this._cubeDirections=[new O(1,0,0),new O(-1,0,0),new O(0,0,1),new O(0,0,-1),new O(0,1,0),new O(0,-1,0)],this._cubeUps=[new O(0,1,0),new O(0,1,0),new O(0,1,0),new O(0,1,0),new O(0,0,1),new O(0,0,-1)]}updateMatrices(e,t=0){const r=this.camera,i=this.matrix,a=e.distance||r.far;a!==r.far&&(r.far=a,r.updateProjectionMatrix()),zo.setFromMatrixPosition(e.matrixWorld),r.position.copy(zo),Ku.copy(r.position),Ku.add(this._cubeDirections[t]),r.up.copy(this._cubeUps[t]),r.lookAt(Ku),r.updateMatrixWorld(),i.makeTranslation(-zo.x,-zo.y,-zo.z),Tf.multiplyMatrices(r.projectionMatrix,r.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Tf)}}Af.prototype.isPointLightShadow=!0;class $u extends gr{constructor(e,t,r=0,i=1){super(e,t),this.type="PointLight",this.distance=r,this.decay=i,this.shadow=new Af}get power(){return 4*this.intensity*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}$u.prototype.isPointLight=!0;class Uo extends fo{constructor(e=-1,t=1,r=1,i=-1,a=.1,c=2e3){super(),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=r,this.bottom=i,this.near=a,this.far=c,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,t,r,i,a,c){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=r,this.view.offsetY=i,this.view.width=a,this.view.height=c,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),r=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let a=r-e,c=r+e,u=i+t,h=i-t;if(this.view!==null&&this.view.enabled){const p=(this.right-this.left)/this.view.fullWidth/this.zoom,m=(this.top-this.bottom)/this.view.fullHeight/this.zoom;a+=p*this.view.offsetX,c=a+p*this.view.width,u-=m*this.view.offsetY,h=u-m*this.view.height}this.projectionMatrix.makeOrthographic(a,c,u,h,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}}Uo.prototype.isOrthographicCamera=!0;class Rf extends Yu{constructor(){super(new Uo(-5,5,5,-5,.5,500))}}Rf.prototype.isDirectionalLightShadow=!0;class Ju extends gr{constructor(e,t){super(e,t),this.type="DirectionalLight",this.position.copy(yt.DefaultUp),this.updateMatrix(),this.target=new yt,this.shadow=new Rf}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}Ju.prototype.isDirectionalLight=!0;class Qu extends gr{constructor(e,t){super(e,t),this.type="AmbientLight"}}Qu.prototype.isAmbientLight=!0;class eh extends gr{constructor(e,t,r=10,i=10){super(e,t),this.type="RectAreaLight",this.width=r,this.height=i}copy(e){return super.copy(e),this.width=e.width,this.height=e.height,this}toJSON(e){const t=super.toJSON(e);return t.object.width=this.width,t.object.height=this.height,t}}eh.prototype.isRectAreaLight=!0;class th{constructor(){this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new O)}set(e){for(let t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,t){const r=e.x,i=e.y,a=e.z,c=this.coefficients;return t.copy(c[0]).multiplyScalar(.282095),t.addScaledVector(c[1],.488603*i),t.addScaledVector(c[2],.488603*a),t.addScaledVector(c[3],.488603*r),t.addScaledVector(c[4],r*i*1.092548),t.addScaledVector(c[5],i*a*1.092548),t.addScaledVector(c[6],.315392*(3*a*a-1)),t.addScaledVector(c[7],r*a*1.092548),t.addScaledVector(c[8],.546274*(r*r-i*i)),t}getIrradianceAt(e,t){const r=e.x,i=e.y,a=e.z,c=this.coefficients;return t.copy(c[0]).multiplyScalar(.886227),t.addScaledVector(c[1],1.023328*i),t.addScaledVector(c[2],1.023328*a),t.addScaledVector(c[3],1.023328*r),t.addScaledVector(c[4],.858086*r*i),t.addScaledVector(c[5],.858086*i*a),t.addScaledVector(c[6],.743125*a*a-.247708),t.addScaledVector(c[7],.858086*r*a),t.addScaledVector(c[8],.429043*(r*r-i*i)),t}add(e){for(let t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this}addScaledSH(e,t){for(let r=0;r<9;r++)this.coefficients[r].addScaledVector(e.coefficients[r],t);return this}scale(e){for(let t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this}lerp(e,t){for(let r=0;r<9;r++)this.coefficients[r].lerp(e.coefficients[r],t);return this}equals(e){for(let t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(e,t=0){const r=this.coefficients;for(let i=0;i<9;i++)r[i].fromArray(e,t+3*i);return this}toArray(e=[],t=0){const r=this.coefficients;for(let i=0;i<9;i++)r[i].toArray(e,t+3*i);return e}static getBasisAt(e,t){const r=e.x,i=e.y,a=e.z;t[0]=.282095,t[1]=.488603*i,t[2]=.488603*a,t[3]=.488603*r,t[4]=1.092548*r*i,t[5]=1.092548*i*a,t[6]=.315392*(3*a*a-1),t[7]=1.092548*r*a,t[8]=.546274*(r*r-i*i)}}th.prototype.isSphericalHarmonics3=!0;class Go extends gr{constructor(e=new th,t=1){super(void 0,t),this.sh=e}copy(e){return super.copy(e),this.sh.copy(e.sh),this}fromJSON(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this}toJSON(e){const t=super.toJSON(e);return t.object.sh=this.sh.toArray(),t}}Go.prototype.isLightProbe=!0;class Lf extends Rn{constructor(e){super(e),this.textures={}}load(e,t,r,i){const a=this,c=new Rr(a.manager);c.setPath(a.path),c.setRequestHeader(a.requestHeader),c.setWithCredentials(a.withCredentials),c.load(e,function(u){try{t(a.parse(JSON.parse(u)))}catch(h){i?i(h):console.error(h),a.manager.itemError(e)}},r,i)}parse(e){const t=this.textures;function r(a){return t[a]===void 0&&console.warn("THREE.MaterialLoader: Undefined texture",a),t[a]}const i=new kx[e.type];if(e.uuid!==void 0&&(i.uuid=e.uuid),e.name!==void 0&&(i.name=e.name),e.color!==void 0&&i.color!==void 0&&i.color.setHex(e.color),e.roughness!==void 0&&(i.roughness=e.roughness),e.metalness!==void 0&&(i.metalness=e.metalness),e.sheen!==void 0&&(i.sheen=new Ge().setHex(e.sheen)),e.emissive!==void 0&&i.emissive!==void 0&&i.emissive.setHex(e.emissive),e.specular!==void 0&&i.specular!==void 0&&i.specular.setHex(e.specular),e.shininess!==void 0&&(i.shininess=e.shininess),e.clearcoat!==void 0&&(i.clearcoat=e.clearcoat),e.clearcoatRoughness!==void 0&&(i.clearcoatRoughness=e.clearcoatRoughness),e.fog!==void 0&&(i.fog=e.fog),e.flatShading!==void 0&&(i.flatShading=e.flatShading),e.blending!==void 0&&(i.blending=e.blending),e.combine!==void 0&&(i.combine=e.combine),e.side!==void 0&&(i.side=e.side),e.shadowSide!==void 0&&(i.shadowSide=e.shadowSide),e.opacity!==void 0&&(i.opacity=e.opacity),e.transparent!==void 0&&(i.transparent=e.transparent),e.alphaTest!==void 0&&(i.alphaTest=e.alphaTest),e.depthTest!==void 0&&(i.depthTest=e.depthTest),e.depthWrite!==void 0&&(i.depthWrite=e.depthWrite),e.colorWrite!==void 0&&(i.colorWrite=e.colorWrite),e.stencilWrite!==void 0&&(i.stencilWrite=e.stencilWrite),e.stencilWriteMask!==void 0&&(i.stencilWriteMask=e.stencilWriteMask),e.stencilFunc!==void 0&&(i.stencilFunc=e.stencilFunc),e.stencilRef!==void 0&&(i.stencilRef=e.stencilRef),e.stencilFuncMask!==void 0&&(i.stencilFuncMask=e.stencilFuncMask),e.stencilFail!==void 0&&(i.stencilFail=e.stencilFail),e.stencilZFail!==void 0&&(i.stencilZFail=e.stencilZFail),e.stencilZPass!==void 0&&(i.stencilZPass=e.stencilZPass),e.wireframe!==void 0&&(i.wireframe=e.wireframe),e.wireframeLinewidth!==void 0&&(i.wireframeLinewidth=e.wireframeLinewidth),e.wireframeLinecap!==void 0&&(i.wireframeLinecap=e.wireframeLinecap),e.wireframeLinejoin!==void 0&&(i.wireframeLinejoin=e.wireframeLinejoin),e.rotation!==void 0&&(i.rotation=e.rotation),e.linewidth!==1&&(i.linewidth=e.linewidth),e.dashSize!==void 0&&(i.dashSize=e.dashSize),e.gapSize!==void 0&&(i.gapSize=e.gapSize),e.scale!==void 0&&(i.scale=e.scale),e.polygonOffset!==void 0&&(i.polygonOffset=e.polygonOffset),e.polygonOffsetFactor!==void 0&&(i.polygonOffsetFactor=e.polygonOffsetFactor),e.polygonOffsetUnits!==void 0&&(i.polygonOffsetUnits=e.polygonOffsetUnits),e.skinning!==void 0&&(i.skinning=e.skinning),e.morphTargets!==void 0&&(i.morphTargets=e.morphTargets),e.morphNormals!==void 0&&(i.morphNormals=e.morphNormals),e.dithering!==void 0&&(i.dithering=e.dithering),e.alphaToCoverage!==void 0&&(i.alphaToCoverage=e.alphaToCoverage),e.premultipliedAlpha!==void 0&&(i.premultipliedAlpha=e.premultipliedAlpha),e.vertexTangents!==void 0&&(i.vertexTangents=e.vertexTangents),e.visible!==void 0&&(i.visible=e.visible),e.toneMapped!==void 0&&(i.toneMapped=e.toneMapped),e.userData!==void 0&&(i.userData=e.userData),e.vertexColors!==void 0&&(typeof e.vertexColors=="number"?i.vertexColors=e.vertexColors>0:i.vertexColors=e.vertexColors),e.uniforms!==void 0)for(const a in e.uniforms){const c=e.uniforms[a];switch(i.uniforms[a]={},c.type){case"t":i.uniforms[a].value=r(c.value);break;case"c":i.uniforms[a].value=new Ge().setHex(c.value);break;case"v2":i.uniforms[a].value=new Ee().fromArray(c.value);break;case"v3":i.uniforms[a].value=new O().fromArray(c.value);break;case"v4":i.uniforms[a].value=new Dt().fromArray(c.value);break;case"m3":i.uniforms[a].value=new St().fromArray(c.value);break;case"m4":i.uniforms[a].value=new Ze().fromArray(c.value);break;default:i.uniforms[a].value=c.value}}if(e.defines!==void 0&&(i.defines=e.defines),e.vertexShader!==void 0&&(i.vertexShader=e.vertexShader),e.fragmentShader!==void 0&&(i.fragmentShader=e.fragmentShader),e.extensions!==void 0)for(const a in e.extensions)i.extensions[a]=e.extensions[a];if(e.shading!==void 0&&(i.flatShading=e.shading===1),e.size!==void 0&&(i.size=e.size),e.sizeAttenuation!==void 0&&(i.sizeAttenuation=e.sizeAttenuation),e.map!==void 0&&(i.map=r(e.map)),e.matcap!==void 0&&(i.matcap=r(e.matcap)),e.alphaMap!==void 0&&(i.alphaMap=r(e.alphaMap)),e.bumpMap!==void 0&&(i.bumpMap=r(e.bumpMap)),e.bumpScale!==void 0&&(i.bumpScale=e.bumpScale),e.normalMap!==void 0&&(i.normalMap=r(e.normalMap)),e.normalMapType!==void 0&&(i.normalMapType=e.normalMapType),e.normalScale!==void 0){let a=e.normalScale;Array.isArray(a)===!1&&(a=[a,a]),i.normalScale=new Ee().fromArray(a)}return e.displacementMap!==void 0&&(i.displacementMap=r(e.displacementMap)),e.displacementScale!==void 0&&(i.displacementScale=e.displacementScale),e.displacementBias!==void 0&&(i.displacementBias=e.displacementBias),e.roughnessMap!==void 0&&(i.roughnessMap=r(e.roughnessMap)),e.metalnessMap!==void 0&&(i.metalnessMap=r(e.metalnessMap)),e.emissiveMap!==void 0&&(i.emissiveMap=r(e.emissiveMap)),e.emissiveIntensity!==void 0&&(i.emissiveIntensity=e.emissiveIntensity),e.specularMap!==void 0&&(i.specularMap=r(e.specularMap)),e.envMap!==void 0&&(i.envMap=r(e.envMap)),e.envMapIntensity!==void 0&&(i.envMapIntensity=e.envMapIntensity),e.reflectivity!==void 0&&(i.reflectivity=e.reflectivity),e.refractionRatio!==void 0&&(i.refractionRatio=e.refractionRatio),e.lightMap!==void 0&&(i.lightMap=r(e.lightMap)),e.lightMapIntensity!==void 0&&(i.lightMapIntensity=e.lightMapIntensity),e.aoMap!==void 0&&(i.aoMap=r(e.aoMap)),e.aoMapIntensity!==void 0&&(i.aoMapIntensity=e.aoMapIntensity),e.gradientMap!==void 0&&(i.gradientMap=r(e.gradientMap)),e.clearcoatMap!==void 0&&(i.clearcoatMap=r(e.clearcoatMap)),e.clearcoatRoughnessMap!==void 0&&(i.clearcoatRoughnessMap=r(e.clearcoatRoughnessMap)),e.clearcoatNormalMap!==void 0&&(i.clearcoatNormalMap=r(e.clearcoatNormalMap)),e.clearcoatNormalScale!==void 0&&(i.clearcoatNormalScale=new Ee().fromArray(e.clearcoatNormalScale)),e.transmission!==void 0&&(i.transmission=e.transmission),e.transmissionMap!==void 0&&(i.transmissionMap=r(e.transmissionMap)),i}setTextures(e){return this.textures=e,this}}class nh{static decodeText(e){if(typeof TextDecoder<"u")return new TextDecoder().decode(e);let t="";for(let r=0,i=e.length;r<i;r++)t+=String.fromCharCode(e[r]);try{return decodeURIComponent(escape(t))}catch{return t}}static extractUrlBase(e){const t=e.lastIndexOf("/");return t===-1?"./":e.substr(0,t+1)}}class rh extends Qe{constructor(){super(),this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(e){return super.copy(e),this.instanceCount=e.instanceCount,this}clone(){return new this.constructor().copy(this)}toJSON(){const e=super.toJSON(this);return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}rh.prototype.isInstancedBufferGeometry=!0;class ih extends xt{constructor(e,t,r,i){typeof r=="number"&&(i=r,r=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),super(e,t,r),this.meshPerAttribute=i||1}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){const e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}ih.prototype.isInstancedBufferAttribute=!0;class Cf extends Rn{constructor(e){super(e)}load(e,t,r,i){const a=this,c=new Rr(a.manager);c.setPath(a.path),c.setRequestHeader(a.requestHeader),c.setWithCredentials(a.withCredentials),c.load(e,function(u){try{t(a.parse(JSON.parse(u)))}catch(h){i?i(h):console.error(h),a.manager.itemError(e)}},r,i)}parse(e){const t={},r={};function i(g,y){if(t[y]!==void 0)return t[y];const x=g.interleavedBuffers[y],b=function(A,I){if(r[I]!==void 0)return r[I];const k=A.arrayBuffers[I],N=new Uint32Array(k).buffer;return r[I]=N,N}(g,x.buffer),S=ho(x.type,b),M=new $r(S,x.stride);return M.uuid=x.uuid,t[y]=M,M}const a=e.isInstancedBufferGeometry?new rh:new Qe,c=e.data.index;if(c!==void 0){const g=ho(c.type,c.array);a.setIndex(new xt(g,1))}const u=e.data.attributes;for(const g in u){const y=u[g];let x;if(y.isInterleavedBufferAttribute){const b=i(e.data,y.data);x=new wi(b,y.itemSize,y.offset,y.normalized)}else{const b=ho(y.type,y.array);x=new(y.isInstancedBufferAttribute?ih:xt)(b,y.itemSize,y.normalized)}y.name!==void 0&&(x.name=y.name),y.usage!==void 0&&x.setUsage(y.usage),y.updateRange!==void 0&&(x.updateRange.offset=y.updateRange.offset,x.updateRange.count=y.updateRange.count),a.setAttribute(g,x)}const h=e.data.morphAttributes;if(h)for(const g in h){const y=h[g],x=[];for(let b=0,S=y.length;b<S;b++){const M=y[b];let A;if(M.isInterleavedBufferAttribute){const I=i(e.data,M.data);A=new wi(I,M.itemSize,M.offset,M.normalized)}else{const I=ho(M.type,M.array);A=new xt(I,M.itemSize,M.normalized)}M.name!==void 0&&(A.name=M.name),x.push(A)}a.morphAttributes[g]=x}e.data.morphTargetsRelative&&(a.morphTargetsRelative=!0);const p=e.data.groups||e.data.drawcalls||e.data.offsets;if(p!==void 0)for(let g=0,y=p.length;g!==y;++g){const x=p[g];a.addGroup(x.start,x.count,x.materialIndex)}const m=e.data.boundingSphere;if(m!==void 0){const g=new O;m.center!==void 0&&g.fromArray(m.center),a.boundingSphere=new fi(g,m.radius)}return e.name&&(a.name=e.name),e.userData&&(a.userData=e.userData),a}}const Fx={UVMapping:300,CubeReflectionMapping:301,CubeRefractionMapping:302,EquirectangularReflectionMapping:303,EquirectangularRefractionMapping:304,CubeUVReflectionMapping:306,CubeUVRefractionMapping:307},Pf={RepeatWrapping:1e3,ClampToEdgeWrapping:1001,MirroredRepeatWrapping:1002},If={NearestFilter:1003,NearestMipmapNearestFilter:1004,NearestMipmapLinearFilter:1005,LinearFilter:1006,LinearMipmapNearestFilter:1007,LinearMipmapLinearFilter:1008};class Of extends Rn{constructor(e){super(e),typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(e){return this.options=e,this}load(e,t,r,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const a=this,c=ji.get(e);if(c!==void 0)return a.manager.itemStart(e),setTimeout(function(){t&&t(c),a.manager.itemEnd(e)},0),c;const u={};u.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",u.headers=this.requestHeader,fetch(e,u).then(function(h){return h.blob()}).then(function(h){return createImageBitmap(h,Object.assign(a.options,{colorSpaceConversion:"none"}))}).then(function(h){ji.add(e,h),t&&t(h),a.manager.itemEnd(e)}).catch(function(h){i&&i(h),a.manager.itemError(e),a.manager.itemEnd(e)}),a.manager.itemStart(e)}}Of.prototype.isImageBitmapLoader=!0;class Df{constructor(){this.type="ShapePath",this.color=new Ge,this.subPaths=[],this.currentPath=null}moveTo(e,t){return this.currentPath=new Bo,this.subPaths.push(this.currentPath),this.currentPath.moveTo(e,t),this}lineTo(e,t){return this.currentPath.lineTo(e,t),this}quadraticCurveTo(e,t,r,i){return this.currentPath.quadraticCurveTo(e,t,r,i),this}bezierCurveTo(e,t,r,i,a,c){return this.currentPath.bezierCurveTo(e,t,r,i,a,c),this}splineThru(e){return this.currentPath.splineThru(e),this}toShapes(e,t){function r(I){const k=[];for(let N=0,G=I.length;N<G;N++){const U=I[N],B=new Ei;B.curves=U.curves,k.push(B)}return k}function i(I,k){const N=k.length;let G=!1;for(let U=N-1,B=0;B<N;U=B++){let V=k[U],he=k[B],Z=he.x-V.x,J=he.y-V.y;if(Math.abs(J)>Number.EPSILON){if(J<0&&(V=k[B],Z=-Z,he=k[U],J=-J),I.y<V.y||I.y>he.y)continue;if(I.y===V.y){if(I.x===V.x)return!0}else{const re=J*(I.x-V.x)-Z*(I.y-V.y);if(re===0)return!0;if(re<0)continue;G=!G}}else{if(I.y!==V.y)continue;if(he.x<=I.x&&I.x<=V.x||V.x<=I.x&&I.x<=he.x)return!0}}return G}const a=Ar.isClockWise,c=this.subPaths;if(c.length===0)return[];if(t===!0)return r(c);let u,h,p;const m=[];if(c.length===1)return h=c[0],p=new Ei,p.curves=h.curves,m.push(p),m;let g=!a(c[0].getPoints());g=e?!g:g;const y=[],x=[];let b,S,M=[],A=0;x[A]=void 0,M[A]=[];for(let I=0,k=c.length;I<k;I++)h=c[I],b=h.getPoints(),u=a(b),u=e?!u:u,u?(!g&&x[A]&&A++,x[A]={s:new Ei,p:b},x[A].s.curves=h.curves,g&&A++,M[A]=[]):M[A].push({h,p:b[0]});if(!x[0])return r(c);if(x.length>1){let I=!1;const k=[];for(let N=0,G=x.length;N<G;N++)y[N]=[];for(let N=0,G=x.length;N<G;N++){const U=M[N];for(let B=0;B<U.length;B++){const V=U[B];let he=!0;for(let Z=0;Z<x.length;Z++)i(V.p,x[Z].p)&&(N!==Z&&k.push({froms:N,tos:Z,hole:B}),he?(he=!1,y[Z].push(V)):I=!0);he&&y[N].push(V)}}k.length>0&&(I||(M=y))}for(let I=0,k=x.length;I<k;I++){p=x[I].s,m.push(p),S=M[I];for(let N=0,G=S.length;N<G;N++)p.holes.push(S[N].h)}return m}}class sh{constructor(e){this.type="Font",this.data=e}generateShapes(e,t=100){const r=[],i=function(a,c,u){const h=Array.from(a),p=c/u.resolution,m=(u.boundingBox.yMax-u.boundingBox.yMin+u.underlineThickness)*p,g=[];let y=0,x=0;for(let b=0;b<h.length;b++){const S=h[b];if(S===`
`)y=0,x-=m;else{const M=Bx(S,p,y,x,u);y+=M.offsetX,g.push(M.path)}}return g}(e,t,this.data);for(let a=0,c=i.length;a<c;a++)Array.prototype.push.apply(r,i[a].toShapes());return r}}function Bx(o,e,t,r,i){const a=i.glyphs[o]||i.glyphs["?"];if(!a)return void console.error('THREE.Font: character "'+o+'" does not exists in font family '+i.familyName+".");const c=new Df;let u,h,p,m,g,y,x,b;if(a.o){const S=a._cachedOutline||(a._cachedOutline=a.o.split(" "));for(let M=0,A=S.length;M<A;)switch(S[M++]){case"m":u=S[M++]*e+t,h=S[M++]*e+r,c.moveTo(u,h);break;case"l":u=S[M++]*e+t,h=S[M++]*e+r,c.lineTo(u,h);break;case"q":p=S[M++]*e+t,m=S[M++]*e+r,g=S[M++]*e+t,y=S[M++]*e+r,c.quadraticCurveTo(g,y,p,m);break;case"b":p=S[M++]*e+t,m=S[M++]*e+r,g=S[M++]*e+t,y=S[M++]*e+r,x=S[M++]*e+t,b=S[M++]*e+r,c.bezierCurveTo(g,y,x,b,p,m)}}return{offsetX:a.ha*e,path:c}}sh.prototype.isFont=!0;let kl;const oh={getContext:function(){return kl===void 0&&(kl=new(window.AudioContext||window.webkitAudioContext)),kl},setContext:function(o){kl=o}};class Nf extends Rn{constructor(e){super(e)}load(e,t,r,i){const a=this,c=new Rr(this.manager);c.setResponseType("arraybuffer"),c.setPath(this.path),c.setRequestHeader(this.requestHeader),c.setWithCredentials(this.withCredentials),c.load(e,function(u){try{const h=u.slice(0);oh.getContext().decodeAudioData(h,function(p){t(p)})}catch(h){i?i(h):console.error(h),a.manager.itemError(e)}},r,i)}}class kf extends Go{constructor(e,t,r=1){super(void 0,r);const i=new Ge().set(e),a=new Ge().set(t),c=new O(i.r,i.g,i.b),u=new O(a.r,a.g,a.b),h=Math.sqrt(Math.PI),p=h*Math.sqrt(.75);this.sh.coefficients[0].copy(c).add(u).multiplyScalar(h),this.sh.coefficients[1].copy(c).sub(u).multiplyScalar(p)}}kf.prototype.isHemisphereLightProbe=!0;class Hf extends Go{constructor(e,t=1){super(void 0,t);const r=new Ge().set(e);this.sh.coefficients[0].set(r.r,r.g,r.b).multiplyScalar(2*Math.sqrt(Math.PI))}}Hf.prototype.isAmbientLightProbe=!0;const Ff=new Ze,Bf=new Ze;class zf{constructor(e=!0){this.autoStart=e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=Uf(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const t=Uf();e=(t-this.oldTime)/1e3,this.oldTime=t,this.elapsedTime+=e}return e}}function Uf(){return(typeof performance>"u"?Date:performance).now()}const qi=new O,Gf=new fn,zx=new O,Xi=new O;class ah extends yt{constructor(e){super(),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(this.isPlaying===!0)return void console.warn("THREE.Audio: Audio is already playing.");if(this.hasPlaybackControl===!1)return void console.warn("THREE.Audio: this Audio has no playback control.");this._startedAt=this.context.currentTime+e;const t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.loopStart=this.loopStart,t.loopEnd=this.loopEnd,t.onended=this.onEnded.bind(this),t.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=t,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl!==!1)return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this;console.warn("THREE.Audio: this Audio has no playback control.")}stop(){if(this.hasPlaybackControl!==!1)return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this;console.warn("THREE.Audio: this Audio has no playback control.")}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(e){return e||(e=[]),this._connected===!0?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){if(this.detune=e,this.source.detune!==void 0)return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(this.hasPlaybackControl!==!1)return this.playbackRate=e,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this;console.warn("THREE.Audio: this Audio has no playback control.")}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(this.hasPlaybackControl!==!1)return this.loop=e,this.isPlaying===!0&&(this.source.loop=this.loop),this;console.warn("THREE.Audio: this Audio has no playback control.")}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}}const Yi=new O,Vf=new fn,Ux=new O,Zi=new O;class Wf{constructor(e,t=2048){this.analyser=e.context.createAnalyser(),this.analyser.fftSize=t,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let e=0;const t=this.getFrequencyData();for(let r=0;r<t.length;r++)e+=t[r];return e/t.length}}class jf{constructor(e,t,r){let i,a,c;switch(this.binding=e,this.valueSize=r,t){case"quaternion":i=this._slerp,a=this._slerpAdditive,c=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*r),this._workIndex=5;break;case"string":case"bool":i=this._select,a=this._select,c=this._setAdditiveIdentityOther,this.buffer=new Array(5*r);break;default:i=this._lerp,a=this._lerpAdditive,c=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*r)}this._mixBufferRegion=i,this._mixBufferRegionAdditive=a,this._setIdentity=c,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(e,t){const r=this.buffer,i=this.valueSize,a=e*i+i;let c=this.cumulativeWeight;if(c===0){for(let u=0;u!==i;++u)r[a+u]=r[u];c=t}else{c+=t;const u=t/c;this._mixBufferRegion(r,a,0,u,i)}this.cumulativeWeight=c}accumulateAdditive(e){const t=this.buffer,r=this.valueSize,i=r*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(t,i,0,e,r),this.cumulativeWeightAdditive+=e}apply(e){const t=this.valueSize,r=this.buffer,i=e*t+t,a=this.cumulativeWeight,c=this.cumulativeWeightAdditive,u=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,a<1){const h=t*this._origIndex;this._mixBufferRegion(r,i,h,1-a,t)}c>0&&this._mixBufferRegionAdditive(r,i,this._addIndex*t,1,t);for(let h=t,p=t+t;h!==p;++h)if(r[h]!==r[h+t]){u.setValue(r,i);break}}saveOriginalState(){const e=this.binding,t=this.buffer,r=this.valueSize,i=r*this._origIndex;e.getValue(t,i);for(let a=r,c=i;a!==c;++a)t[a]=t[i+a%r];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const e=3*this.valueSize;this.binding.setValue(this.buffer,e)}_setAdditiveIdentityNumeric(){const e=this._addIndex*this.valueSize,t=e+this.valueSize;for(let r=e;r<t;r++)this.buffer[r]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const e=this._origIndex*this.valueSize,t=this._addIndex*this.valueSize;for(let r=0;r<this.valueSize;r++)this.buffer[t+r]=this.buffer[e+r]}_select(e,t,r,i,a){if(i>=.5)for(let c=0;c!==a;++c)e[t+c]=e[r+c]}_slerp(e,t,r,i){fn.slerpFlat(e,t,e,t,e,r,i)}_slerpAdditive(e,t,r,i,a){const c=this._workIndex*a;fn.multiplyQuaternionsFlat(e,c,e,t,e,r),fn.slerpFlat(e,t,e,t,e,c,i)}_lerp(e,t,r,i,a){const c=1-i;for(let u=0;u!==a;++u){const h=t+u;e[h]=e[h]*c+e[r+u]*i}}_lerpAdditive(e,t,r,i,a){for(let c=0;c!==a;++c){const u=t+c;e[u]=e[u]+e[r+c]*i}}}const Gx="\\[\\]\\.:\\/",Vx=new RegExp("[\\[\\]\\.:\\/]","g"),lh="[^\\[\\]\\.:\\/]",Wx="[^"+Gx.replace("\\.","")+"]",jx=/((?:WC+[\/:])*)/.source.replace("WC",lh),qx=/(WCOD+)?/.source.replace("WCOD",Wx),Xx=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",lh),Yx=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",lh),Zx=new RegExp("^"+jx+qx+Xx+Yx+"$"),Kx=["material","materials","bones"];class Lt{constructor(e,t,r){this.path=t,this.parsedPath=r||Lt.parseTrackName(t),this.node=Lt.findNode(e,this.parsedPath.nodeName)||e,this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,t,r){return e&&e.isAnimationObjectGroup?new Lt.Composite(e,t,r):new Lt(e,t,r)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(Vx,"")}static parseTrackName(e){const t=Zx.exec(e);if(!t)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const r={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},i=r.nodeName&&r.nodeName.lastIndexOf(".");if(i!==void 0&&i!==-1){const a=r.nodeName.substring(i+1);Kx.indexOf(a)!==-1&&(r.nodeName=r.nodeName.substring(0,i),r.objectName=a)}if(r.propertyName===null||r.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return r}static findNode(e,t){if(!t||t===""||t==="."||t===-1||t===e.name||t===e.uuid)return e;if(e.skeleton){const r=e.skeleton.getBoneByName(t);if(r!==void 0)return r}if(e.children){const r=function(a){for(let c=0;c<a.length;c++){const u=a[c];if(u.name===t||u.uuid===t)return u;const h=r(u.children);if(h)return h}return null},i=r(e.children);if(i)return i}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,t){e[t]=this.node[this.propertyName]}_getValue_array(e,t){const r=this.resolvedProperty;for(let i=0,a=r.length;i!==a;++i)e[t++]=r[i]}_getValue_arrayElement(e,t){e[t]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,t){this.resolvedProperty.toArray(e,t)}_setValue_direct(e,t){this.targetObject[this.propertyName]=e[t]}_setValue_direct_setNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,t){const r=this.resolvedProperty;for(let i=0,a=r.length;i!==a;++i)r[i]=e[t++]}_setValue_array_setNeedsUpdate(e,t){const r=this.resolvedProperty;for(let i=0,a=r.length;i!==a;++i)r[i]=e[t++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,t){const r=this.resolvedProperty;for(let i=0,a=r.length;i!==a;++i)r[i]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(e,t){this.resolvedProperty[this.propertyIndex]=e[t]}_setValue_arrayElement_setNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,t){this.resolvedProperty.fromArray(e,t)}_setValue_fromArray_setNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,t){this.bind(),this.getValue(e,t)}_setValue_unbound(e,t){this.bind(),this.setValue(e,t)}bind(){let e=this.node;const t=this.parsedPath,r=t.objectName,i=t.propertyName;let a=t.propertyIndex;if(e||(e=Lt.findNode(this.rootNode,t.nodeName)||this.rootNode,this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e)return void console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");if(r){let p=t.objectIndex;switch(r){case"materials":if(!e.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!e.material.materials)return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);e=e.material.materials;break;case"bones":if(!e.skeleton)return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);e=e.skeleton.bones;for(let m=0;m<e.length;m++)if(e[m].name===p){p=m;break}break;default:if(e[r]===void 0)return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);e=e[r]}if(p!==void 0){if(e[p]===void 0)return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);e=e[p]}}const c=e[i];if(c===void 0){const p=t.nodeName;return void console.error("THREE.PropertyBinding: Trying to update property for track: "+p+"."+i+" but it wasn't found.",e)}let u=this.Versioning.None;this.targetObject=e,e.needsUpdate!==void 0?u=this.Versioning.NeedsUpdate:e.matrixWorldNeedsUpdate!==void 0&&(u=this.Versioning.MatrixWorldNeedsUpdate);let h=this.BindingType.Direct;if(a!==void 0){if(i==="morphTargetInfluences"){if(!e.geometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!e.geometry.isBufferGeometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);if(!e.geometry.morphAttributes)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);e.morphTargetDictionary[a]!==void 0&&(a=e.morphTargetDictionary[a])}h=this.BindingType.ArrayElement,this.resolvedProperty=c,this.propertyIndex=a}else c.fromArray!==void 0&&c.toArray!==void 0?(h=this.BindingType.HasFromToArray,this.resolvedProperty=c):Array.isArray(c)?(h=this.BindingType.EntireArray,this.resolvedProperty=c):this.propertyName=i;this.getValue=this.GetterByBindingType[h],this.setValue=this.SetterByBindingTypeAndVersioning[h][u]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}Lt.Composite=class{constructor(o,e,t){const r=t||Lt.parseTrackName(e);this._targetGroup=o,this._bindings=o.subscribe_(e,r)}getValue(o,e){this.bind();const t=this._targetGroup.nCachedObjects_,r=this._bindings[t];r!==void 0&&r.getValue(o,e)}setValue(o,e){const t=this._bindings;for(let r=this._targetGroup.nCachedObjects_,i=t.length;r!==i;++r)t[r].setValue(o,e)}bind(){const o=this._bindings;for(let e=this._targetGroup.nCachedObjects_,t=o.length;e!==t;++e)o[e].bind()}unbind(){const o=this._bindings;for(let e=this._targetGroup.nCachedObjects_,t=o.length;e!==t;++e)o[e].unbind()}},Lt.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Lt.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},Lt.prototype.GetterByBindingType=[Lt.prototype._getValue_direct,Lt.prototype._getValue_array,Lt.prototype._getValue_arrayElement,Lt.prototype._getValue_toArray],Lt.prototype.SetterByBindingTypeAndVersioning=[[Lt.prototype._setValue_direct,Lt.prototype._setValue_direct_setNeedsUpdate,Lt.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[Lt.prototype._setValue_array,Lt.prototype._setValue_array_setNeedsUpdate,Lt.prototype._setValue_array_setMatrixWorldNeedsUpdate],[Lt.prototype._setValue_arrayElement,Lt.prototype._setValue_arrayElement_setNeedsUpdate,Lt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[Lt.prototype._setValue_fromArray,Lt.prototype._setValue_fromArray_setNeedsUpdate,Lt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class qf{constructor(){this.uuid=it(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const e={};this._indicesByUUID=e;for(let r=0,i=arguments.length;r!==i;++r)e[arguments[r].uuid]=r;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const t=this;this.stats={objects:{get total(){return t._objects.length},get inUse(){return this.total-t.nCachedObjects_}},get bindingsPerObject(){return t._bindings.length}}}add(){const e=this._objects,t=this._indicesByUUID,r=this._paths,i=this._parsedPaths,a=this._bindings,c=a.length;let u,h=e.length,p=this.nCachedObjects_;for(let m=0,g=arguments.length;m!==g;++m){const y=arguments[m],x=y.uuid;let b=t[x];if(b===void 0){b=h++,t[x]=b,e.push(y);for(let S=0,M=c;S!==M;++S)a[S].push(new Lt(y,r[S],i[S]))}else if(b<p){u=e[b];const S=--p,M=e[S];t[M.uuid]=b,e[b]=M,t[x]=S,e[S]=y;for(let A=0,I=c;A!==I;++A){const k=a[A],N=k[S];let G=k[b];k[b]=N,G===void 0&&(G=new Lt(y,r[A],i[A])),k[S]=G}}else e[b]!==u&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=p}remove(){const e=this._objects,t=this._indicesByUUID,r=this._bindings,i=r.length;let a=this.nCachedObjects_;for(let c=0,u=arguments.length;c!==u;++c){const h=arguments[c],p=h.uuid,m=t[p];if(m!==void 0&&m>=a){const g=a++,y=e[g];t[y.uuid]=m,e[m]=y,t[p]=g,e[g]=h;for(let x=0,b=i;x!==b;++x){const S=r[x],M=S[g],A=S[m];S[m]=M,S[g]=A}}}this.nCachedObjects_=a}uncache(){const e=this._objects,t=this._indicesByUUID,r=this._bindings,i=r.length;let a=this.nCachedObjects_,c=e.length;for(let u=0,h=arguments.length;u!==h;++u){const p=arguments[u].uuid,m=t[p];if(m!==void 0)if(delete t[p],m<a){const g=--a,y=e[g],x=--c,b=e[x];t[y.uuid]=m,e[m]=y,t[b.uuid]=g,e[g]=b,e.pop();for(let S=0,M=i;S!==M;++S){const A=r[S],I=A[g],k=A[x];A[m]=I,A[g]=k,A.pop()}}else{const g=--c,y=e[g];g>0&&(t[y.uuid]=m),e[m]=y,e.pop();for(let x=0,b=i;x!==b;++x){const S=r[x];S[m]=S[g],S.pop()}}}this.nCachedObjects_=a}subscribe_(e,t){const r=this._bindingsIndicesByPath;let i=r[e];const a=this._bindings;if(i!==void 0)return a[i];const c=this._paths,u=this._parsedPaths,h=this._objects,p=h.length,m=this.nCachedObjects_,g=new Array(p);i=a.length,r[e]=i,c.push(e),u.push(t),a.push(g);for(let y=m,x=h.length;y!==x;++y){const b=h[y];g[y]=new Lt(b,e,t)}return g}unsubscribe_(e){const t=this._bindingsIndicesByPath,r=t[e];if(r!==void 0){const i=this._paths,a=this._parsedPaths,c=this._bindings,u=c.length-1,h=c[u];t[e[u]]=r,c[r]=h,c.pop(),a[r]=a[u],a.pop(),i[r]=i[u],i.pop()}}}qf.prototype.isAnimationObjectGroup=!0;class $x{constructor(e,t,r=null,i=t.blendMode){this._mixer=e,this._clip=t,this._localRoot=r,this.blendMode=i;const a=t.tracks,c=a.length,u=new Array(c),h={endingStart:2400,endingEnd:2400};for(let p=0;p!==c;++p){const m=a[p].createInterpolant(null);u[p]=m,m.settings=h}this._interpolantSettings=h,this._interpolants=u,this._propertyBindings=new Array(c),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=2201,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,t){return this.loop=e,this.repetitions=t,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,t,r){if(e.fadeOut(t),this.fadeIn(t),r){const i=this._clip.duration,a=e._clip.duration,c=a/i,u=i/a;e.warp(1,c,t),this.warp(u,1,t)}return this}crossFadeTo(e,t,r){return e.crossFadeFrom(this,t,r)}stopFading(){const e=this._weightInterpolant;return e!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,t,r){const i=this._mixer,a=i.time,c=this.timeScale;let u=this._timeScaleInterpolant;u===null&&(u=i._lendControlInterpolant(),this._timeScaleInterpolant=u);const h=u.parameterPositions,p=u.sampleValues;return h[0]=a,h[1]=a+r,p[0]=e/c,p[1]=t/c,this}stopWarping(){const e=this._timeScaleInterpolant;return e!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,t,r,i){if(!this.enabled)return void this._updateWeight(e);const a=this._startTime;if(a!==null){const h=(e-a)*r;if(h<0||r===0)return;this._startTime=null,t=r*h}t*=this._updateTimeScale(e);const c=this._updateTime(t),u=this._updateWeight(e);if(u>0){const h=this._interpolants,p=this._propertyBindings;switch(this.blendMode){case 2501:for(let m=0,g=h.length;m!==g;++m)h[m].evaluate(c),p[m].accumulateAdditive(u);break;case 2500:default:for(let m=0,g=h.length;m!==g;++m)h[m].evaluate(c),p[m].accumulate(i,u)}}}_updateWeight(e){let t=0;if(this.enabled){t=this.weight;const r=this._weightInterpolant;if(r!==null){const i=r.evaluate(e)[0];t*=i,e>r.parameterPositions[1]&&(this.stopFading(),i===0&&(this.enabled=!1))}}return this._effectiveWeight=t,t}_updateTimeScale(e){let t=0;if(!this.paused){t=this.timeScale;const r=this._timeScaleInterpolant;r!==null&&(t*=r.evaluate(e)[0],e>r.parameterPositions[1]&&(this.stopWarping(),t===0?this.paused=!0:this.timeScale=t))}return this._effectiveTimeScale=t,t}_updateTime(e){const t=this._clip.duration,r=this.loop;let i=this.time+e,a=this._loopCount;const c=r===2202;if(e===0)return a===-1?i:c&&(1&a)==1?t-i:i;if(r===2200){a===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(i>=t)i=t;else{if(!(i<0)){this.time=i;break e}i=0}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(a===-1&&(e>=0?(a=0,this._setEndings(!0,this.repetitions===0,c)):this._setEndings(this.repetitions===0,!0,c)),i>=t||i<0){const u=Math.floor(i/t);i-=t*u,a+=Math.abs(u);const h=this.repetitions-a;if(h<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,i=e>0?t:0,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(h===1){const p=e<0;this._setEndings(p,!p,c)}else this._setEndings(!1,!1,c);this._loopCount=a,this.time=i,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:u})}}else this.time=i;if(c&&(1&a)==1)return t-i}return i}_setEndings(e,t,r){const i=this._interpolantSettings;r?(i.endingStart=2401,i.endingEnd=2401):(i.endingStart=e?this.zeroSlopeAtStart?2401:2400:2402,i.endingEnd=t?this.zeroSlopeAtEnd?2401:2400:2402)}_scheduleFading(e,t,r){const i=this._mixer,a=i.time;let c=this._weightInterpolant;c===null&&(c=i._lendControlInterpolant(),this._weightInterpolant=c);const u=c.parameterPositions,h=c.sampleValues;return u[0]=a,h[0]=t,u[1]=a+e,h[1]=r,this}}class Xf extends ce{constructor(e){super(),this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(e,t){const r=e._localRoot||this._root,i=e._clip.tracks,a=i.length,c=e._propertyBindings,u=e._interpolants,h=r.uuid,p=this._bindingsByRootAndName;let m=p[h];m===void 0&&(m={},p[h]=m);for(let g=0;g!==a;++g){const y=i[g],x=y.name;let b=m[x];if(b!==void 0)c[g]=b;else{if(b=c[g],b!==void 0){b._cacheIndex===null&&(++b.referenceCount,this._addInactiveBinding(b,h,x));continue}const S=t&&t._propertyBindings[g].binding.parsedPath;b=new jf(Lt.create(r,x,S),y.ValueTypeName,y.getValueSize()),++b.referenceCount,this._addInactiveBinding(b,h,x),c[g]=b}u[g].resultBuffer=b.buffer}}_activateAction(e){if(!this._isActiveAction(e)){if(e._cacheIndex===null){const r=(e._localRoot||this._root).uuid,i=e._clip.uuid,a=this._actionsByClip[i];this._bindAction(e,a&&a.knownActions[0]),this._addInactiveAction(e,i,r)}const t=e._propertyBindings;for(let r=0,i=t.length;r!==i;++r){const a=t[r];a.useCount++==0&&(this._lendBinding(a),a.saveOriginalState())}this._lendAction(e)}}_deactivateAction(e){if(this._isActiveAction(e)){const t=e._propertyBindings;for(let r=0,i=t.length;r!==i;++r){const a=t[r];--a.useCount==0&&(a.restoreOriginalState(),this._takeBackBinding(a))}this._takeBackAction(e)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}}_isActiveAction(e){const t=e._cacheIndex;return t!==null&&t<this._nActiveActions}_addInactiveAction(e,t,r){const i=this._actions,a=this._actionsByClip;let c=a[t];if(c===void 0)c={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,a[t]=c;else{const u=c.knownActions;e._byClipCacheIndex=u.length,u.push(e)}e._cacheIndex=i.length,i.push(e),c.actionByRoot[r]=e}_removeInactiveAction(e){const t=this._actions,r=t[t.length-1],i=e._cacheIndex;r._cacheIndex=i,t[i]=r,t.pop(),e._cacheIndex=null;const a=e._clip.uuid,c=this._actionsByClip,u=c[a],h=u.knownActions,p=h[h.length-1],m=e._byClipCacheIndex;p._byClipCacheIndex=m,h[m]=p,h.pop(),e._byClipCacheIndex=null,delete u.actionByRoot[(e._localRoot||this._root).uuid],h.length===0&&delete c[a],this._removeInactiveBindingsForAction(e)}_removeInactiveBindingsForAction(e){const t=e._propertyBindings;for(let r=0,i=t.length;r!==i;++r){const a=t[r];--a.referenceCount==0&&this._removeInactiveBinding(a)}}_lendAction(e){const t=this._actions,r=e._cacheIndex,i=this._nActiveActions++,a=t[i];e._cacheIndex=i,t[i]=e,a._cacheIndex=r,t[r]=a}_takeBackAction(e){const t=this._actions,r=e._cacheIndex,i=--this._nActiveActions,a=t[i];e._cacheIndex=i,t[i]=e,a._cacheIndex=r,t[r]=a}_addInactiveBinding(e,t,r){const i=this._bindingsByRootAndName,a=this._bindings;let c=i[t];c===void 0&&(c={},i[t]=c),c[r]=e,e._cacheIndex=a.length,a.push(e)}_removeInactiveBinding(e){const t=this._bindings,r=e.binding,i=r.rootNode.uuid,a=r.path,c=this._bindingsByRootAndName,u=c[i],h=t[t.length-1],p=e._cacheIndex;h._cacheIndex=p,t[p]=h,t.pop(),delete u[a],Object.keys(u).length===0&&delete c[i]}_lendBinding(e){const t=this._bindings,r=e._cacheIndex,i=this._nActiveBindings++,a=t[i];e._cacheIndex=i,t[i]=e,a._cacheIndex=r,t[r]=a}_takeBackBinding(e){const t=this._bindings,r=e._cacheIndex,i=--this._nActiveBindings,a=t[i];e._cacheIndex=i,t[i]=e,a._cacheIndex=r,t[r]=a}_lendControlInterpolant(){const e=this._controlInterpolants,t=this._nActiveControlInterpolants++;let r=e[t];return r===void 0&&(r=new Nu(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),r.__cacheIndex=t,e[t]=r),r}_takeBackControlInterpolant(e){const t=this._controlInterpolants,r=e.__cacheIndex,i=--this._nActiveControlInterpolants,a=t[i];e.__cacheIndex=i,t[i]=e,a.__cacheIndex=r,t[r]=a}clipAction(e,t,r){const i=t||this._root,a=i.uuid;let c=typeof e=="string"?Do.findByName(i,e):e;const u=c!==null?c.uuid:e,h=this._actionsByClip[u];let p=null;if(r===void 0&&(r=c!==null?c.blendMode:2500),h!==void 0){const g=h.actionByRoot[a];if(g!==void 0&&g.blendMode===r)return g;p=h.knownActions[0],c===null&&(c=p._clip)}if(c===null)return null;const m=new $x(this,c,t,r);return this._bindAction(m,p),this._addInactiveAction(m,u,a),m}existingAction(e,t){const r=t||this._root,i=r.uuid,a=typeof e=="string"?Do.findByName(r,e):e,c=a?a.uuid:e,u=this._actionsByClip[c];return u!==void 0&&u.actionByRoot[i]||null}stopAllAction(){const e=this._actions;for(let t=this._nActiveActions-1;t>=0;--t)e[t].stop();return this}update(e){e*=this.timeScale;const t=this._actions,r=this._nActiveActions,i=this.time+=e,a=Math.sign(e),c=this._accuIndex^=1;for(let p=0;p!==r;++p)t[p]._update(i,e,a,c);const u=this._bindings,h=this._nActiveBindings;for(let p=0;p!==h;++p)u[p].apply(c);return this}setTime(e){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(e)}getRoot(){return this._root}uncacheClip(e){const t=this._actions,r=e.uuid,i=this._actionsByClip,a=i[r];if(a!==void 0){const c=a.knownActions;for(let u=0,h=c.length;u!==h;++u){const p=c[u];this._deactivateAction(p);const m=p._cacheIndex,g=t[t.length-1];p._cacheIndex=null,p._byClipCacheIndex=null,g._cacheIndex=m,t[m]=g,t.pop(),this._removeInactiveBindingsForAction(p)}delete i[r]}}uncacheRoot(e){const t=e.uuid,r=this._actionsByClip;for(const a in r){const c=r[a].actionByRoot[t];c!==void 0&&(this._deactivateAction(c),this._removeInactiveAction(c))}const i=this._bindingsByRootAndName[t];if(i!==void 0)for(const a in i){const c=i[a];c.restoreOriginalState(),this._removeInactiveBinding(c)}}uncacheAction(e,t){const r=this.existingAction(e,t);r!==null&&(this._deactivateAction(r),this._removeInactiveAction(r))}}Xf.prototype._controlInterpolantsResultBuffer=new Float32Array(1);class Hl{constructor(e){typeof e=="string"&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),e=arguments[1]),this.value=e}clone(){return new Hl(this.value.clone===void 0?this.value:this.value.clone())}}class Yf extends $r{constructor(e,t,r=1){super(e,t),this.meshPerAttribute=r||1}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}clone(e){const t=super.clone(e);return t.meshPerAttribute=this.meshPerAttribute,t}toJSON(e){const t=super.toJSON(e);return t.isInstancedInterleavedBuffer=!0,t.meshPerAttribute=this.meshPerAttribute,t}}Yf.prototype.isInstancedInterleavedBuffer=!0;class Zf{constructor(e,t,r,i,a){this.buffer=e,this.type=t,this.itemSize=r,this.elementSize=i,this.count=a,this.version=0}set needsUpdate(e){e===!0&&this.version++}setBuffer(e){return this.buffer=e,this}setType(e,t){return this.type=e,this.elementSize=t,this}setItemSize(e){return this.itemSize=e,this}setCount(e){return this.count=e,this}}Zf.prototype.isGLBufferAttribute=!0;function Kf(o,e){return o.distance-e.distance}function ch(o,e,t,r){if(o.layers.test(e.layers)&&o.raycast(e,t),r===!0){const i=o.children;for(let a=0,c=i.length;a<c;a++)ch(i[a],e,t,!0)}}const $f=new Ee;class Ws{constructor(e=new Ee(1/0,1/0),t=new Ee(-1/0,-1/0)){this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromPoints(e){this.makeEmpty();for(let t=0,r=e.length;t<r;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const r=$f.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(r),this.max.copy(e).add(r),this}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(e){return e===void 0&&(console.warn("THREE.Box2: .getCenter() target is now required"),e=new Ee),this.isEmpty()?e.set(0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return e===void 0&&(console.warn("THREE.Box2: .getSize() target is now required"),e=new Ee),this.isEmpty()?e.set(0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y}getParameter(e,t){return t===void 0&&(console.warn("THREE.Box2: .getParameter() target is now required"),t=new Ee),t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y)}clampPoint(e,t){return t===void 0&&(console.warn("THREE.Box2: .clampPoint() target is now required"),t=new Ee),t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return $f.copy(e).clamp(this.min,this.max).sub(e).length()}intersect(e){return this.min.max(e.min),this.max.min(e.max),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}Ws.prototype.isBox2=!0;const Jf=new O,Fl=new O;class Qf{constructor(e=new O,t=new O){this.start=e,this.end=t}set(e,t){return this.start.copy(e),this.end.copy(t),this}copy(e){return this.start.copy(e.start),this.end.copy(e.end),this}getCenter(e){return e===void 0&&(console.warn("THREE.Line3: .getCenter() target is now required"),e=new O),e.addVectors(this.start,this.end).multiplyScalar(.5)}delta(e){return e===void 0&&(console.warn("THREE.Line3: .delta() target is now required"),e=new O),e.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(e,t){return t===void 0&&(console.warn("THREE.Line3: .at() target is now required"),t=new O),this.delta(t).multiplyScalar(e).add(this.start)}closestPointToPointParameter(e,t){Jf.subVectors(e,this.start),Fl.subVectors(this.end,this.start);const r=Fl.dot(Fl);let i=Fl.dot(Jf)/r;return t&&(i=ct(i,0,1)),i}closestPointToPoint(e,t,r){const i=this.closestPointToPointParameter(e,t);return r===void 0&&(console.warn("THREE.Line3: .closestPointToPoint() target is now required"),r=new O),this.delta(r).multiplyScalar(i).add(this.start)}applyMatrix4(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this}equals(e){return e.start.equals(this.start)&&e.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}class em extends yt{constructor(e){super(),this.material=e,this.render=function(){},this.hasPositions=!1,this.hasNormals=!1,this.hasColors=!1,this.hasUvs=!1,this.positionArray=null,this.normalArray=null,this.colorArray=null,this.uvArray=null,this.count=0}}em.prototype.isImmediateRenderObject=!0;const tm=new O,Ti=new O,Bl=new Ze,uh=new Ze;class nm extends jn{constructor(e){const t=rm(e),r=new Qe,i=[],a=[],c=new Ge(0,0,1),u=new Ge(0,1,0);for(let h=0;h<t.length;h++){const p=t[h];p.parent&&p.parent.isBone&&(i.push(0,0,0),i.push(0,0,0),a.push(c.r,c.g,c.b),a.push(u.r,u.g,u.b))}r.setAttribute("position",new qe(i,3)),r.setAttribute("color",new qe(a,3)),super(r,new vn({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0})),this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=e,this.bones=t,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(e){const t=this.bones,r=this.geometry,i=r.getAttribute("position");uh.copy(this.root.matrixWorld).invert();for(let a=0,c=0;a<t.length;a++){const u=t[a];u.parent&&u.parent.isBone&&(Bl.multiplyMatrices(uh,u.matrixWorld),Ti.setFromMatrixPosition(Bl),i.setXYZ(c,Ti.x,Ti.y,Ti.z),Bl.multiplyMatrices(uh,u.parent.matrixWorld),Ti.setFromMatrixPosition(Bl),i.setXYZ(c+1,Ti.x,Ti.y,Ti.z),c+=2)}r.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}}function rm(o){const e=[];o&&o.isBone&&e.push(o);for(let t=0;t<o.children.length;t++)e.push.apply(e,rm(o.children[t]));return e}const Jx=new O,im=new Ge,sm=new Ge;class om extends jn{constructor(e=10,t=10,r=4473924,i=8947848){r=new Ge(r),i=new Ge(i);const a=t/2,c=e/t,u=e/2,h=[],p=[];for(let g=0,y=0,x=-u;g<=t;g++,x+=c){h.push(-u,0,x,u,0,x),h.push(x,0,-u,x,0,u);const b=g===a?r:i;b.toArray(p,y),y+=3,b.toArray(p,y),y+=3,b.toArray(p,y),y+=3,b.toArray(p,y),y+=3}const m=new Qe;m.setAttribute("position",new qe(h,3)),m.setAttribute("color",new qe(p,3)),super(m,new vn({vertexColors:!0,toneMapped:!1})),this.type="GridHelper"}}const am=new O,zl=new O,lm=new O,Ul=new O,Zt=new fo;function en(o,e,t,r,i,a,c){Ul.set(i,a,c).unproject(r);const u=e[o];if(u!==void 0){const h=t.getAttribute("position");for(let p=0,m=u.length;p<m;p++)h.setXYZ(u[p],Ul.x,Ul.y,Ul.z)}}const Gl=new Wn;class cm extends jn{constructor(e,t=16776960){const r=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=new Float32Array(24),a=new Qe;a.setIndex(new xt(r,1)),a.setAttribute("position",new xt(i,3)),super(a,new vn({color:t,toneMapped:!1})),this.object=e,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(e){if(e!==void 0&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),this.object!==void 0&&Gl.setFromObject(this.object),Gl.isEmpty())return;const t=Gl.min,r=Gl.max,i=this.geometry.attributes.position,a=i.array;a[0]=r.x,a[1]=r.y,a[2]=r.z,a[3]=t.x,a[4]=r.y,a[5]=r.z,a[6]=t.x,a[7]=t.y,a[8]=r.z,a[9]=r.x,a[10]=t.y,a[11]=r.z,a[12]=r.x,a[13]=r.y,a[14]=t.z,a[15]=t.x,a[16]=r.y,a[17]=t.z,a[18]=t.x,a[19]=t.y,a[20]=t.z,a[21]=r.x,a[22]=t.y,a[23]=t.z,i.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(e){return this.object=e,this.update(),this}copy(e){return jn.prototype.copy.call(this,e),this.object=e.object,this}}const um=new O;let Vl,hh;class hm extends jn{constructor(e=1){const t=[0,0,0,e,0,0,0,0,0,0,e,0,0,0,0,0,0,e],r=new Qe;r.setAttribute("position",new qe(t,3)),r.setAttribute("color",new qe([1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],3)),super(r,new vn({vertexColors:!0,toneMapped:!1})),this.type="AxesHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}const dm=new Float32Array(1),Qx=new Int32Array(dm.buffer),Lr=Math.pow(2,8),pm=[.125,.215,.35,.446,.526,.582],fm=5+pm.length,Wl=20,Cr={3e3:0,3001:1,3002:2,3004:3,3005:4,3006:5,3007:6},Ki=new Zr({side:1,depthWrite:!1,depthTest:!1}),e_=new sn(new zi,Ki),dh=new Uo,{_lodPlanes:Vo,_sizeLods:mm,_sigmas:jl}=n_(),gm=new Ge;let ph=null;const $i=(1+Math.sqrt(5))/2,js=1/$i,vm=[new O(1,1,1),new O(-1,1,1),new O(1,1,-1),new O(-1,1,-1),new O(0,$i,js),new O(0,$i,-js),new O(js,0,$i),new O(-js,0,$i),new O($i,js,0),new O(-$i,js,0)];function ym(o){const e=Math.max(o.r,o.g,o.b),t=Math.min(Math.max(Math.ceil(Math.log2(e)),-128),127);return o.multiplyScalar(Math.pow(2,-t)),(t+128)/255}function t_(o){return o!==void 0&&o.type===1009&&(o.encoding===3e3||o.encoding===3001||o.encoding===3007)}function n_(){const o=[],e=[],t=[];let r=8;for(let i=0;i<fm;i++){const a=Math.pow(2,r);e.push(a);let c=1/a;i>4?c=pm[i-8+4-1]:i==0&&(c=0),t.push(c);const u=1/(a-1),h=-u/2,p=1+u/2,m=[h,h,p,h,p,p,h,h,p,p,h,p],g=6,y=6,x=3,b=2,S=1,M=new Float32Array(x*y*g),A=new Float32Array(b*y*g),I=new Float32Array(S*y*g);for(let N=0;N<g;N++){const G=N%3*2/3-1,U=N>2?0:-1,B=[G,U,0,G+2/3,U,0,G+2/3,U+1,0,G,U,0,G+2/3,U+1,0,G,U+1,0];M.set(B,x*y*N),A.set(m,b*y*N);const V=[N,N,N,N,N,N];I.set(V,S*y*N)}const k=new Qe;k.setAttribute("position",new xt(M,x)),k.setAttribute("uv",new xt(A,b)),k.setAttribute("faceIndex",new xt(I,S)),o.push(k),r>4&&r--}return{_lodPlanes:o,_sizeLods:e,_sigmas:t}}function xm(o){const e=new Vr(3*Lr,3*Lr,o);return e.texture.mapping=306,e.texture.name="PMREM.cubeUv",e.scissorTest=!0,e}function ql(o,e,t,r,i){o.viewport.set(e,t,r,i),o.scissor.set(e,t,r,i)}function _m(){const o=new Ee(1,1);return new Gs({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:o},inputEncoding:{value:Cr[3e3]},outputEncoding:{value:Cr[3e3]}},vertexShader:fh(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${mh()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:0,depthTest:!1,depthWrite:!1})}function bm(){return new Gs({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},inputEncoding:{value:Cr[3e3]},outputEncoding:{value:Cr[3e3]}},vertexShader:fh(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${mh()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:0,depthTest:!1,depthWrite:!1})}function fh(){return`

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function mh(){return`

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`}Qn.create=function(o,e){return console.log("THREE.Curve.create() has been deprecated"),o.prototype=Object.create(Qn.prototype),o.prototype.constructor=o,o.prototype.getPoint=e,o},Bo.prototype.fromPoints=function(o){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(o)},om.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")},nm.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")},Rn.prototype.extractUrlBase=function(o){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),nh.extractUrlBase(o)},Rn.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}},Ws.prototype.center=function(o){return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),this.getCenter(o)},Ws.prototype.empty=function(){return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),this.isEmpty()},Ws.prototype.isIntersectionBox=function(o){return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(o)},Ws.prototype.size=function(o){return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),this.getSize(o)},Wn.prototype.center=function(o){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(o)},Wn.prototype.empty=function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()},Wn.prototype.isIntersectionBox=function(o){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(o)},Wn.prototype.isIntersectionSphere=function(o){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(o)},Wn.prototype.size=function(o){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(o)},fi.prototype.empty=function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()},mo.prototype.setFromMatrix=function(o){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(o)},Qf.prototype.center=function(o){return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),this.getCenter(o)},St.prototype.flattenToArrayOffset=function(o,e){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(o,e)},St.prototype.multiplyVector3=function(o){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),o.applyMatrix3(this)},St.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")},St.prototype.applyToBufferAttribute=function(o){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),o.applyMatrix3(this)},St.prototype.applyToVector3Array=function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")},St.prototype.getInverse=function(o){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(o).invert()},Ze.prototype.extractPosition=function(o){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(o)},Ze.prototype.flattenToArrayOffset=function(o,e){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(o,e)},Ze.prototype.getPosition=function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),new O().setFromMatrixColumn(this,3)},Ze.prototype.setRotationFromQuaternion=function(o){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(o)},Ze.prototype.multiplyToArray=function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")},Ze.prototype.multiplyVector3=function(o){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),o.applyMatrix4(this)},Ze.prototype.multiplyVector4=function(o){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),o.applyMatrix4(this)},Ze.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")},Ze.prototype.rotateAxis=function(o){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),o.transformDirection(this)},Ze.prototype.crossVector=function(o){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),o.applyMatrix4(this)},Ze.prototype.translate=function(){console.error("THREE.Matrix4: .translate() has been removed.")},Ze.prototype.rotateX=function(){console.error("THREE.Matrix4: .rotateX() has been removed.")},Ze.prototype.rotateY=function(){console.error("THREE.Matrix4: .rotateY() has been removed.")},Ze.prototype.rotateZ=function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")},Ze.prototype.rotateByAxis=function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")},Ze.prototype.applyToBufferAttribute=function(o){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),o.applyMatrix4(this)},Ze.prototype.applyToVector3Array=function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")},Ze.prototype.makeFrustum=function(o,e,t,r,i,a){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(o,e,r,t,i,a)},Ze.prototype.getInverse=function(o){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(o).invert()},ur.prototype.isIntersectionLine=function(o){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(o)},fn.prototype.multiplyVector3=function(o){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),o.applyQuaternion(this)},fn.prototype.inverse=function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()},gi.prototype.isIntersectionBox=function(o){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(o)},gi.prototype.isIntersectionPlane=function(o){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(o)},gi.prototype.isIntersectionSphere=function(o){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(o)},Jt.prototype.area=function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()},Jt.prototype.barycoordFromPoint=function(o,e){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(o,e)},Jt.prototype.midpoint=function(o){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(o)},Jt.prototypenormal=function(o){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(o)},Jt.prototype.plane=function(o){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(o)},Jt.barycoordFromPoint=function(o,e,t,r,i){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),Jt.getBarycoord(o,e,t,r,i)},Jt.normal=function(o,e,t,r){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),Jt.getNormal(o,e,t,r)},Ei.prototype.extractAllPoints=function(o){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(o)},Ei.prototype.extrude=function(o){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new Qr(this,o)},Ei.prototype.makeGeometry=function(o){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new Co(this,o)},Ee.prototype.fromAttribute=function(o,e,t){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(o,e,t)},Ee.prototype.distanceToManhattan=function(o){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(o)},Ee.prototype.lengthManhattan=function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},O.prototype.setEulerFromRotationMatrix=function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")},O.prototype.setEulerFromQuaternion=function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")},O.prototype.getPositionFromMatrix=function(o){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(o)},O.prototype.getScaleFromMatrix=function(o){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(o)},O.prototype.getColumnFromMatrix=function(o,e){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(e,o)},O.prototype.applyProjection=function(o){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(o)},O.prototype.fromAttribute=function(o,e,t){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(o,e,t)},O.prototype.distanceToManhattan=function(o){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(o)},O.prototype.lengthManhattan=function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},Dt.prototype.fromAttribute=function(o,e,t){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(o,e,t)},Dt.prototype.lengthManhattan=function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},yt.prototype.getChildByName=function(o){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(o)},yt.prototype.renderDepth=function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")},yt.prototype.translate=function(o,e){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(e,o)},yt.prototype.getWorldRotation=function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")},yt.prototype.applyMatrix=function(o){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(o)},Object.defineProperties(yt.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(o){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=o}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}}),sn.prototype.setDrawMode=function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")},Object.defineProperties(sn.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),0},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}}),sl.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")},gn.prototype.setLens=function(o,e){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),e!==void 0&&(this.filmGauge=e),this.setFocalLength(o)},Object.defineProperties(gr.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(o){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=o}},shadowCameraLeft:{set:function(o){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=o}},shadowCameraRight:{set:function(o){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=o}},shadowCameraTop:{set:function(o){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=o}},shadowCameraBottom:{set:function(o){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=o}},shadowCameraNear:{set:function(o){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=o}},shadowCameraFar:{set:function(o){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=o}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(o){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=o}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(o){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=o}},shadowMapHeight:{set:function(o){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=o}}}),Object.defineProperties(xt.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===35048},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(35048)}}}),xt.prototype.setDynamic=function(o){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(o===!0?35048:35044),this},xt.prototype.copyIndicesArray=function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},xt.prototype.setArray=function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")},Qe.prototype.addIndex=function(o){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(o)},Qe.prototype.addAttribute=function(o,e){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),e&&e.isBufferAttribute||e&&e.isInterleavedBufferAttribute?o==="index"?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(e),this):this.setAttribute(o,e):(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(o,new xt(arguments[1],arguments[2])))},Qe.prototype.addDrawCall=function(o,e,t){t!==void 0&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(o,e)},Qe.prototype.clearDrawCalls=function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()},Qe.prototype.computeOffsets=function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")},Qe.prototype.removeAttribute=function(o){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(o)},Qe.prototype.applyMatrix=function(o){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(o)},Object.defineProperties(Qe.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}}),$r.prototype.setDynamic=function(o){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(o===!0?35048:35044),this},$r.prototype.setArray=function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")},Qr.prototype.getArrays=function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")},Qr.prototype.addShapeList=function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")},Qr.prototype.addShape=function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")},Ja.prototype.dispose=function(){console.error("THREE.Scene: .dispose() has been removed.")},Hl.prototype.onUpdate=function(){return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),this},Object.defineProperties(rn.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new Ge}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(o){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=o===1}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(o){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=o}}}),Object.defineProperties(Kr.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(o){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=o}}}),Ut.prototype.clearTarget=function(o,e,t,r){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(o),this.clear(e,t,r)},Ut.prototype.animate=function(o){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(o)},Ut.prototype.getCurrentRenderTarget=function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()},Ut.prototype.getMaxAnisotropy=function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()},Ut.prototype.getPrecision=function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision},Ut.prototype.resetGLState=function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()},Ut.prototype.supportsFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")},Ut.prototype.supportsHalfFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")},Ut.prototype.supportsStandardDerivatives=function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")},Ut.prototype.supportsCompressedTextureS3TC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")},Ut.prototype.supportsCompressedTexturePVRTC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")},Ut.prototype.supportsBlendMinMax=function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")},Ut.prototype.supportsVertexTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures},Ut.prototype.supportsInstancedArrays=function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")},Ut.prototype.enableScissorTest=function(o){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(o)},Ut.prototype.initMaterial=function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")},Ut.prototype.addPrePlugin=function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")},Ut.prototype.addPostPlugin=function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")},Ut.prototype.updateShadowMap=function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")},Ut.prototype.setFaceCulling=function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")},Ut.prototype.allocTextureUnit=function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")},Ut.prototype.setTexture=function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")},Ut.prototype.setTexture2D=function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")},Ut.prototype.setTextureCube=function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")},Ut.prototype.getActiveMipMapLevel=function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()},Object.defineProperties(Ut.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(o){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=o}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(o){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=o}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(o){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=o===!0?3001:3e3}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}}),Object.defineProperties(Dp.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}}),Object.defineProperties(Vr.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(o){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=o}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(o){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=o}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(o){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=o}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(o){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=o}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(o){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=o}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(o){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=o}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(o){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=o}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(o){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=o}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(o){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=o}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(o){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=o}}}),ah.prototype.load=function(o){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const e=this;return new Nf().load(o,function(t){e.setBuffer(t)}),this},Wf.prototype.getData=function(){return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),this.getFrequencyData()},Xa.prototype.updateCubeMap=function(o,e){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(o,e)},Xa.prototype.clear=function(o,e,t,r){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(o,e,t,r)},Er.crossOrigin=void 0,Er.loadTexture=function(o,e,t,r){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const i=new yf;i.setCrossOrigin(this.crossOrigin);const a=i.load(o,t,void 0,r);return e&&(a.mapping=e),a},Er.loadTextureCube=function(o,e,t,r){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const i=new gf;i.setCrossOrigin(this.crossOrigin);const a=i.load(o,t,void 0,r);return e&&(a.mapping=e),a},Er.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")},Er.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};const r_={createMultiMaterialObject:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},detach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},attach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")}};typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:s}})),typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=s),n.ACESFilmicToneMapping=4,n.AddEquation=100,n.AddOperation=2,n.AdditiveAnimationBlendMode=2501,n.AdditiveBlending=2,n.AlphaFormat=1021,n.AlwaysDepth=1,n.AlwaysStencilFunc=519,n.AmbientLight=Qu,n.AmbientLightProbe=Hf,n.AnimationClip=Do,n.AnimationLoader=class extends Rn{constructor(o){super(o)}load(o,e,t,r){const i=this,a=new Rr(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(o,function(c){try{e(i.parse(JSON.parse(c)))}catch(u){r?r(u):console.error(u),i.manager.itemError(o)}},t,r)}parse(o){const e=[];for(let t=0;t<o.length;t++){const r=Do.parse(o[t]);e.push(r)}return e}},n.AnimationMixer=Xf,n.AnimationObjectGroup=qf,n.AnimationUtils=Wt,n.ArcCurve=Fu,n.ArrayCamera=fu,n.ArrowHelper=class extends yt{constructor(o=new O(0,0,1),e=new O(0,0,0),t=1,r=16776960,i=.2*t,a=.2*i){super(),this.type="ArrowHelper",Vl===void 0&&(Vl=new Qe,Vl.setAttribute("position",new qe([0,0,0,0,1,0],3)),hh=new zs(0,.5,1,5,1),hh.translate(0,-.5,0)),this.position.copy(e),this.line=new Jr(Vl,new vn({color:r,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new sn(hh,new Zr({color:r,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(o),this.setLength(t,i,a)}setDirection(o){if(o.y>.99999)this.quaternion.set(0,0,0,1);else if(o.y<-.99999)this.quaternion.set(1,0,0,0);else{um.set(o.z,0,-o.x).normalize();const e=Math.acos(o.y);this.quaternion.setFromAxisAngle(um,e)}}setLength(o,e=.2*o,t=.2*e){this.line.scale.set(1,Math.max(1e-4,o-e),1),this.line.updateMatrix(),this.cone.scale.set(t,e,t),this.cone.position.y=o,this.cone.updateMatrix()}setColor(o){this.line.material.color.set(o),this.cone.material.color.set(o)}copy(o){return super.copy(o,!1),this.line.copy(o.line),this.cone.copy(o.cone),this}},n.Audio=ah,n.AudioAnalyser=Wf,n.AudioContext=oh,n.AudioListener=class extends yt{constructor(){super(),this.type="AudioListener",this.context=oh.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new zf}getInput(){return this.gain}removeFilter(){return this.filter!==null&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(o){return this.filter!==null?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=o,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(o){return this.gain.gain.setTargetAtTime(o,this.context.currentTime,.01),this}updateMatrixWorld(o){super.updateMatrixWorld(o);const e=this.context.listener,t=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(qi,Gf,zx),Xi.set(0,0,-1).applyQuaternion(Gf),e.positionX){const r=this.context.currentTime+this.timeDelta;e.positionX.linearRampToValueAtTime(qi.x,r),e.positionY.linearRampToValueAtTime(qi.y,r),e.positionZ.linearRampToValueAtTime(qi.z,r),e.forwardX.linearRampToValueAtTime(Xi.x,r),e.forwardY.linearRampToValueAtTime(Xi.y,r),e.forwardZ.linearRampToValueAtTime(Xi.z,r),e.upX.linearRampToValueAtTime(t.x,r),e.upY.linearRampToValueAtTime(t.y,r),e.upZ.linearRampToValueAtTime(t.z,r)}else e.setPosition(qi.x,qi.y,qi.z),e.setOrientation(Xi.x,Xi.y,Xi.z,t.x,t.y,t.z)}},n.AudioLoader=Nf,n.AxesHelper=hm,n.AxisHelper=function(o){return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."),new hm(o)},n.BackSide=1,n.BasicDepthPacking=3200,n.BasicShadowMap=0,n.BinaryTextureLoader=function(o){return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."),new vf(o)},n.Bone=ol,n.BooleanKeyframeTrack=Vi,n.BoundingBoxHelper=function(o,e){return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."),new cm(o,e)},n.Box2=Ws,n.Box3=Wn,n.Box3Helper=class extends jn{constructor(o,e=16776960){const t=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),r=new Qe;r.setIndex(new xt(t,1)),r.setAttribute("position",new qe([1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],3)),super(r,new vn({color:e,toneMapped:!1})),this.box=o,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(o){const e=this.box;e.isEmpty()||(e.getCenter(this.position),e.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(o))}},n.BoxBufferGeometry=zi,n.BoxGeometry=zi,n.BoxHelper=cm,n.BufferAttribute=xt,n.BufferGeometry=Qe,n.BufferGeometryLoader=Cf,n.ByteType=1010,n.Cache=ji,n.Camera=fo,n.CameraHelper=class extends jn{constructor(o){const e=new Qe,t=new vn({color:16777215,vertexColors:!0,toneMapped:!1}),r=[],i=[],a={},c=new Ge(16755200),u=new Ge(16711680),h=new Ge(43775),p=new Ge(16777215),m=new Ge(3355443);function g(x,b,S){y(x,S),y(b,S)}function y(x,b){r.push(0,0,0),i.push(b.r,b.g,b.b),a[x]===void 0&&(a[x]=[]),a[x].push(r.length/3-1)}g("n1","n2",c),g("n2","n4",c),g("n4","n3",c),g("n3","n1",c),g("f1","f2",c),g("f2","f4",c),g("f4","f3",c),g("f3","f1",c),g("n1","f1",c),g("n2","f2",c),g("n3","f3",c),g("n4","f4",c),g("p","n1",u),g("p","n2",u),g("p","n3",u),g("p","n4",u),g("u1","u2",h),g("u2","u3",h),g("u3","u1",h),g("c","t",p),g("p","c",m),g("cn1","cn2",m),g("cn3","cn4",m),g("cf1","cf2",m),g("cf3","cf4",m),e.setAttribute("position",new qe(r,3)),e.setAttribute("color",new qe(i,3)),super(e,t),this.type="CameraHelper",this.camera=o,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=o.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=a,this.update()}update(){const o=this.geometry,e=this.pointMap;Zt.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),en("c",e,o,Zt,0,0,-1),en("t",e,o,Zt,0,0,1),en("n1",e,o,Zt,-1,-1,-1),en("n2",e,o,Zt,1,-1,-1),en("n3",e,o,Zt,-1,1,-1),en("n4",e,o,Zt,1,1,-1),en("f1",e,o,Zt,-1,-1,1),en("f2",e,o,Zt,1,-1,1),en("f3",e,o,Zt,-1,1,1),en("f4",e,o,Zt,1,1,1),en("u1",e,o,Zt,.7,1.1,-1),en("u2",e,o,Zt,-.7,1.1,-1),en("u3",e,o,Zt,0,2,-1),en("cf1",e,o,Zt,-1,0,1),en("cf2",e,o,Zt,1,0,1),en("cf3",e,o,Zt,0,-1,1),en("cf4",e,o,Zt,0,1,1),en("cn1",e,o,Zt,-1,0,-1),en("cn2",e,o,Zt,1,0,-1),en("cn3",e,o,Zt,0,-1,-1),en("cn4",e,o,Zt,0,1,-1),o.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}},n.CanvasRenderer=function(){console.error("THREE.CanvasRenderer has been removed")},n.CanvasTexture=rf,n.CatmullRomCurve3=Vu,n.CineonToneMapping=3,n.CircleBufferGeometry=dl,n.CircleGeometry=dl,n.ClampToEdgeWrapping=1001,n.Clock=zf,n.Color=Ge,n.ColorKeyframeTrack=ku,n.CompressedTexture=bu,n.CompressedTextureLoader=class extends Rn{constructor(o){super(o)}load(o,e,t,r){const i=this,a=[],c=new bu,u=new Rr(this.manager);u.setPath(this.path),u.setResponseType("arraybuffer"),u.setRequestHeader(this.requestHeader),u.setWithCredentials(i.withCredentials);let h=0;function p(m){u.load(o[m],function(g){const y=i.parse(g,!0);a[m]={width:y.width,height:y.height,format:y.format,mipmaps:y.mipmaps},h+=1,h===6&&(y.mipmapCount===1&&(c.minFilter=1006),c.image=a,c.format=y.format,c.needsUpdate=!0,e&&e(c))},t,r)}if(Array.isArray(o))for(let m=0,g=o.length;m<g;++m)p(m);else u.load(o,function(m){const g=i.parse(m,!0);if(g.isCubemap){const y=g.mipmaps.length/g.mipmapCount;for(let x=0;x<y;x++){a[x]={mipmaps:[]};for(let b=0;b<g.mipmapCount;b++)a[x].mipmaps.push(g.mipmaps[x*g.mipmapCount+b]),a[x].format=g.format,a[x].width=g.width,a[x].height=g.height}c.image=a}else c.image.width=g.width,c.image.height=g.height,c.mipmaps=g.mipmaps;g.mipmapCount===1&&(c.minFilter=1006),c.format=g.format,c.needsUpdate=!0,e&&e(c)},t,r);return c}},n.ConeBufferGeometry=pl,n.ConeGeometry=pl,n.CubeCamera=Xa,n.CubeReflectionMapping=301,n.CubeRefractionMapping=302,n.CubeTexture=Is,n.CubeTextureLoader=gf,n.CubeUVReflectionMapping=306,n.CubeUVRefractionMapping=307,n.CubicBezierCurve=Ol,n.CubicBezierCurve3=Wu,n.CubicInterpolant=df,n.CullFaceBack=1,n.CullFaceFront=2,n.CullFaceFrontBack=3,n.CullFaceNone=0,n.Curve=Qn,n.CurvePath=bf,n.CustomBlending=5,n.CustomToneMapping=5,n.CylinderBufferGeometry=zs,n.CylinderGeometry=zs,n.Cylindrical=class{constructor(o=1,e=0,t=0){return this.radius=o,this.theta=e,this.y=t,this}set(o,e,t){return this.radius=o,this.theta=e,this.y=t,this}copy(o){return this.radius=o.radius,this.theta=o.theta,this.y=o.y,this}setFromVector3(o){return this.setFromCartesianCoords(o.x,o.y,o.z)}setFromCartesianCoords(o,e,t){return this.radius=Math.sqrt(o*o+t*t),this.theta=Math.atan2(o,t),this.y=e,this}clone(){return new this.constructor().copy(this)}},n.DataTexture=Os,n.DataTexture2DArray=uu,n.DataTexture3D=hu,n.DataTextureLoader=vf,n.DataUtils=class{static toHalfFloat(o){dm[0]=o;const e=Qx[0];let t=e>>16&32768,r=e>>12&2047;const i=e>>23&255;return i<103?t:i>142?(t|=31744,t|=(i==255?0:1)&&8388607&e,t):i<113?(r|=2048,t|=(r>>114-i)+(r>>113-i&1),t):(t|=i-112<<10|r>>1,t+=1&r,t)}},n.DecrementStencilOp=7683,n.DecrementWrapStencilOp=34056,n.DefaultLoadingManager=mf,n.DepthFormat=1026,n.DepthStencilFormat=1027,n.DepthTexture=sf,n.DirectionalLight=Ju,n.DirectionalLightHelper=class extends yt{constructor(o,e,t){super(),this.light=o,this.light.updateMatrixWorld(),this.matrix=o.matrixWorld,this.matrixAutoUpdate=!1,this.color=t,e===void 0&&(e=1);let r=new Qe;r.setAttribute("position",new qe([-e,e,0,e,e,0,e,-e,0,-e,-e,0,-e,e,0],3));const i=new vn({fog:!1,toneMapped:!1});this.lightPlane=new Jr(r,i),this.add(this.lightPlane),r=new Qe,r.setAttribute("position",new qe([0,0,0,0,0,1],3)),this.targetLine=new Jr(r,i),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){am.setFromMatrixPosition(this.light.matrixWorld),zl.setFromMatrixPosition(this.light.target.matrixWorld),lm.subVectors(zl,am),this.lightPlane.lookAt(zl),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(zl),this.targetLine.scale.z=lm.length()}},n.DiscreteInterpolant=pf,n.DodecahedronBufferGeometry=fl,n.DodecahedronGeometry=fl,n.DoubleSide=2,n.DstAlphaFactor=206,n.DstColorFactor=208,n.DynamicBufferAttribute=function(o,e){return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."),new xt(o,e).setUsage(35048)},n.DynamicCopyUsage=35050,n.DynamicDrawUsage=35048,n.DynamicReadUsage=35049,n.EdgesGeometry=Mu,n.EdgesHelper=function(o,e){return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."),new jn(new Mu(o.geometry),new vn({color:e!==void 0?e:16777215}))},n.EllipseCurve=No,n.EqualDepth=4,n.EqualStencilFunc=514,n.EquirectangularReflectionMapping=303,n.EquirectangularRefractionMapping=304,n.Euler=Bi,n.EventDispatcher=ce,n.ExtrudeBufferGeometry=Qr,n.ExtrudeGeometry=Qr,n.FaceColors=1,n.FileLoader=Rr,n.FlatShading=1,n.Float16BufferAttribute=ap,n.Float32Attribute=function(o,e){return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."),new qe(o,e)},n.Float32BufferAttribute=qe,n.Float64Attribute=function(o,e){return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."),new lp(o,e)},n.Float64BufferAttribute=lp,n.FloatType=1015,n.Fog=_o,n.FogExp2=xo,n.Font=sh,n.FontLoader=class extends Rn{constructor(o){super(o)}load(o,e,t,r){const i=this,a=new Rr(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(i.withCredentials),a.load(o,function(c){let u;try{u=JSON.parse(c)}catch{console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),u=JSON.parse(c.substring(65,c.length-2))}const h=i.parse(u);e&&e(h)},t,r)}parse(o){return new sh(o)}},n.FrontSide=0,n.Frustum=mo,n.GLBufferAttribute=Zf,n.GLSL1="100",n.GLSL3=we,n.GammaEncoding=3007,n.GreaterDepth=6,n.GreaterEqualDepth=5,n.GreaterEqualStencilFunc=518,n.GreaterStencilFunc=516,n.GridHelper=om,n.Group=Ui,n.HalfFloatType=1016,n.HemisphereLight=Xu,n.HemisphereLightHelper=class extends yt{constructor(o,e,t){super(),this.light=o,this.light.updateMatrixWorld(),this.matrix=o.matrixWorld,this.matrixAutoUpdate=!1,this.color=t;const r=new Lo(e);r.rotateY(.5*Math.PI),this.material=new Zr({wireframe:!0,fog:!1,toneMapped:!1}),this.color===void 0&&(this.material.vertexColors=!0);const i=r.getAttribute("position"),a=new Float32Array(3*i.count);r.setAttribute("color",new xt(a,3)),this.add(new sn(r,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const o=this.children[0];if(this.color!==void 0)this.material.color.set(this.color);else{const e=o.geometry.getAttribute("color");im.copy(this.light.color),sm.copy(this.light.groundColor);for(let t=0,r=e.count;t<r;t++){const i=t<r/2?im:sm;e.setXYZ(t,i.r,i.g,i.b)}e.needsUpdate=!0}o.lookAt(Jx.setFromMatrixPosition(this.light.matrixWorld).negate())}},n.HemisphereLightProbe=kf,n.IcosahedronBufferGeometry=bl,n.IcosahedronGeometry=bl,n.ImageBitmapLoader=Of,n.ImageLoader=Pl,n.ImageUtils=Er,n.ImmediateRenderObject=em,n.IncrementStencilOp=7682,n.IncrementWrapStencilOp=34055,n.InstancedBufferAttribute=ih,n.InstancedBufferGeometry=rh,n.InstancedInterleavedBuffer=Yf,n.InstancedMesh=vu,n.Int16Attribute=function(o,e){return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."),new sp(o,e)},n.Int16BufferAttribute=sp,n.Int32Attribute=function(o,e){return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."),new op(o,e)},n.Int32BufferAttribute=op,n.Int8Attribute=function(o,e){return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."),new np(o,e)},n.Int8BufferAttribute=np,n.IntType=1013,n.InterleavedBuffer=$r,n.InterleavedBufferAttribute=wi,n.Interpolant=ei,n.InterpolateDiscrete=2300,n.InterpolateLinear=2301,n.InterpolateSmooth=2302,n.InvertStencilOp=5386,n.JSONLoader=function(){console.error("THREE.JSONLoader has been removed.")},n.KeepStencilOp=7680,n.KeyframeTrack=fr,n.LOD=Up,n.LatheBufferGeometry=wl,n.LatheGeometry=wl,n.Layers=Zc,n.LensFlare=function(){console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js")},n.LessDepth=2,n.LessEqualDepth=3,n.LessEqualStencilFunc=515,n.LessStencilFunc=513,n.Light=gr,n.LightProbe=Go,n.Line=Jr,n.Line3=Qf,n.LineBasicMaterial=vn,n.LineCurve=Fo,n.LineCurve3=_f,n.LineDashedMaterial=Du,n.LineLoop=xu,n.LinePieces=1,n.LineSegments=jn,n.LineStrip=0,n.LinearEncoding=3e3,n.LinearFilter=1006,n.LinearInterpolant=Nu,n.LinearMipMapLinearFilter=1008,n.LinearMipMapNearestFilter=1007,n.LinearMipmapLinearFilter=1008,n.LinearMipmapNearestFilter=1007,n.LinearToneMapping=1,n.Loader=Rn,n.LoaderUtils=nh,n.LoadingManager=Hu,n.LogLuvEncoding=3003,n.LoopOnce=2200,n.LoopPingPong=2202,n.LoopRepeat=2201,n.LuminanceAlphaFormat=1025,n.LuminanceFormat=1024,n.MOUSE={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},n.Material=rn,n.MaterialLoader=Lf,n.Math=hi,n.MathUtils=hi,n.Matrix3=St,n.Matrix4=Ze,n.MaxEquation=104,n.Mesh=sn,n.MeshBasicMaterial=Zr,n.MeshDepthMaterial=Ka,n.MeshDistanceMaterial=$a,n.MeshFaceMaterial=function(o){return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."),o},n.MeshLambertMaterial=Iu,n.MeshMatcapMaterial=Ou,n.MeshNormalMaterial=Pu,n.MeshPhongMaterial=Lu,n.MeshPhysicalMaterial=Ru,n.MeshStandardMaterial=Cl,n.MeshToonMaterial=Cu,n.MinEquation=103,n.MirroredRepeatWrapping=1002,n.MixOperation=1,n.MultiMaterial=function(o=[]){return console.warn("THREE.MultiMaterial has been removed. Use an Array instead."),o.isMultiMaterial=!0,o.materials=o,o.clone=function(){return o.slice()},o},n.MultiplyBlending=4,n.MultiplyOperation=0,n.NearestFilter=1003,n.NearestMipMapLinearFilter=1005,n.NearestMipMapNearestFilter=1004,n.NearestMipmapLinearFilter=1005,n.NearestMipmapNearestFilter=1004,n.NeverDepth=0,n.NeverStencilFunc=512,n.NoBlending=0,n.NoColors=0,n.NoToneMapping=0,n.NormalAnimationBlendMode=2500,n.NormalBlending=1,n.NotEqualDepth=7,n.NotEqualStencilFunc=517,n.NumberKeyframeTrack=Io,n.Object3D=yt,n.ObjectLoader=class extends Rn{constructor(o){super(o)}load(o,e,t,r){const i=this,a=this.path===""?nh.extractUrlBase(o):this.path;this.resourcePath=this.resourcePath||a;const c=new Rr(this.manager);c.setPath(this.path),c.setRequestHeader(this.requestHeader),c.setWithCredentials(this.withCredentials),c.load(o,function(u){let h=null;try{h=JSON.parse(u)}catch(m){return r!==void 0&&r(m),void console.error("THREE:ObjectLoader: Can't parse "+o+".",m.message)}const p=h.metadata;p!==void 0&&p.type!==void 0&&p.type.toLowerCase()!=="geometry"?i.parse(h,e):console.error("THREE.ObjectLoader: Can't load "+o)},t,r)}parse(o,e){const t=this.parseAnimations(o.animations),r=this.parseShapes(o.shapes),i=this.parseGeometries(o.geometries,r),a=this.parseImages(o.images,function(){e!==void 0&&e(h)}),c=this.parseTextures(o.textures,a),u=this.parseMaterials(o.materials,c),h=this.parseObject(o.object,i,u,t),p=this.parseSkeletons(o.skeletons,h);if(this.bindSkeletons(h,p),e!==void 0){let m=!1;for(const g in a)if(a[g]instanceof HTMLImageElement){m=!0;break}m===!1&&e(h)}return h}parseShapes(o){const e={};if(o!==void 0)for(let t=0,r=o.length;t<r;t++){const i=new Ei().fromJSON(o[t]);e[i.uuid]=i}return e}parseSkeletons(o,e){const t={},r={};if(e.traverse(function(i){i.isBone&&(r[i.uuid]=i)}),o!==void 0)for(let i=0,a=o.length;i<a;i++){const c=new al().fromJSON(o[i],r);t[c.uuid]=c}return t}parseGeometries(o,e){const t={};let r;if(o!==void 0){const i=new Cf;for(let a=0,c=o.length;a<c;a++){let u;const h=o[a];switch(h.type){case"PlaneGeometry":case"PlaneBufferGeometry":u=new Nn[h.type](h.width,h.height,h.widthSegments,h.heightSegments);break;case"BoxGeometry":case"BoxBufferGeometry":u=new Nn[h.type](h.width,h.height,h.depth,h.widthSegments,h.heightSegments,h.depthSegments);break;case"CircleGeometry":case"CircleBufferGeometry":u=new Nn[h.type](h.radius,h.segments,h.thetaStart,h.thetaLength);break;case"CylinderGeometry":case"CylinderBufferGeometry":u=new Nn[h.type](h.radiusTop,h.radiusBottom,h.height,h.radialSegments,h.heightSegments,h.openEnded,h.thetaStart,h.thetaLength);break;case"ConeGeometry":case"ConeBufferGeometry":u=new Nn[h.type](h.radius,h.height,h.radialSegments,h.heightSegments,h.openEnded,h.thetaStart,h.thetaLength);break;case"SphereGeometry":case"SphereBufferGeometry":u=new Nn[h.type](h.radius,h.widthSegments,h.heightSegments,h.phiStart,h.phiLength,h.thetaStart,h.thetaLength);break;case"DodecahedronGeometry":case"DodecahedronBufferGeometry":case"IcosahedronGeometry":case"IcosahedronBufferGeometry":case"OctahedronGeometry":case"OctahedronBufferGeometry":case"TetrahedronGeometry":case"TetrahedronBufferGeometry":u=new Nn[h.type](h.radius,h.detail);break;case"RingGeometry":case"RingBufferGeometry":u=new Nn[h.type](h.innerRadius,h.outerRadius,h.thetaSegments,h.phiSegments,h.thetaStart,h.thetaLength);break;case"TorusGeometry":case"TorusBufferGeometry":u=new Nn[h.type](h.radius,h.tube,h.radialSegments,h.tubularSegments,h.arc);break;case"TorusKnotGeometry":case"TorusKnotBufferGeometry":u=new Nn[h.type](h.radius,h.tube,h.tubularSegments,h.radialSegments,h.p,h.q);break;case"TubeGeometry":case"TubeBufferGeometry":u=new Nn[h.type](new qu[h.path.type]().fromJSON(h.path),h.tubularSegments,h.radius,h.radialSegments,h.closed);break;case"LatheGeometry":case"LatheBufferGeometry":u=new Nn[h.type](h.points,h.segments,h.phiStart,h.phiLength);break;case"PolyhedronGeometry":case"PolyhedronBufferGeometry":u=new Nn[h.type](h.vertices,h.indices,h.radius,h.details);break;case"ShapeGeometry":case"ShapeBufferGeometry":r=[];for(let m=0,g=h.shapes.length;m<g;m++){const y=e[h.shapes[m]];r.push(y)}u=new Nn[h.type](r,h.curveSegments);break;case"ExtrudeGeometry":case"ExtrudeBufferGeometry":r=[];for(let m=0,g=h.shapes.length;m<g;m++){const y=e[h.shapes[m]];r.push(y)}const p=h.options.extrudePath;p!==void 0&&(h.options.extrudePath=new qu[p.type]().fromJSON(p)),u=new Nn[h.type](r,h.options);break;case"BufferGeometry":case"InstancedBufferGeometry":u=i.parse(h);break;case"Geometry":console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');break;default:console.warn('THREE.ObjectLoader: Unsupported geometry type "'+h.type+'"');continue}u.uuid=h.uuid,h.name!==void 0&&(u.name=h.name),u.isBufferGeometry===!0&&h.userData!==void 0&&(u.userData=h.userData),t[h.uuid]=u}}return t}parseMaterials(o,e){const t={},r={};if(o!==void 0){const i=new Lf;i.setTextures(e);for(let a=0,c=o.length;a<c;a++){const u=o[a];if(u.type==="MultiMaterial"){const h=[];for(let p=0;p<u.materials.length;p++){const m=u.materials[p];t[m.uuid]===void 0&&(t[m.uuid]=i.parse(m)),h.push(t[m.uuid])}r[u.uuid]=h}else t[u.uuid]===void 0&&(t[u.uuid]=i.parse(u)),r[u.uuid]=t[u.uuid]}}return r}parseAnimations(o){const e={};if(o!==void 0)for(let t=0;t<o.length;t++){const r=o[t],i=Do.parse(r);e[i.uuid]=i}return e}parseImages(o,e){const t=this,r={};let i;function a(c){if(typeof c=="string"){const u=c;return function(h){return t.manager.itemStart(h),i.load(h,function(){t.manager.itemEnd(h)},void 0,function(){t.manager.itemError(h),t.manager.itemEnd(h)})}(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(u)?u:t.resourcePath+u)}return c.data?{data:ho(c.type,c.data),width:c.width,height:c.height}:null}if(o!==void 0&&o.length>0){const c=new Hu(e);i=new Pl(c),i.setCrossOrigin(this.crossOrigin);for(let u=0,h=o.length;u<h;u++){const p=o[u],m=p.url;if(Array.isArray(m)){r[p.uuid]=[];for(let g=0,y=m.length;g<y;g++){const x=a(m[g]);x!==null&&(x instanceof HTMLImageElement?r[p.uuid].push(x):r[p.uuid].push(new Os(x.data,x.width,x.height)))}}else{const g=a(p.url);g!==null&&(r[p.uuid]=g)}}}return r}parseTextures(o,e){function t(i,a){return typeof i=="number"?i:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",i),a[i])}const r={};if(o!==void 0)for(let i=0,a=o.length;i<a;i++){const c=o[i];let u;c.image===void 0&&console.warn('THREE.ObjectLoader: No "image" specified for',c.uuid),e[c.image]===void 0&&console.warn("THREE.ObjectLoader: Undefined image",c.image);const h=e[c.image];Array.isArray(h)?(u=new Is(h),h.length===6&&(u.needsUpdate=!0)):(u=h&&h.data?new Os(h.data,h.width,h.height):new un(h),h&&(u.needsUpdate=!0)),u.uuid=c.uuid,c.name!==void 0&&(u.name=c.name),c.mapping!==void 0&&(u.mapping=t(c.mapping,Fx)),c.offset!==void 0&&u.offset.fromArray(c.offset),c.repeat!==void 0&&u.repeat.fromArray(c.repeat),c.center!==void 0&&u.center.fromArray(c.center),c.rotation!==void 0&&(u.rotation=c.rotation),c.wrap!==void 0&&(u.wrapS=t(c.wrap[0],Pf),u.wrapT=t(c.wrap[1],Pf)),c.format!==void 0&&(u.format=c.format),c.type!==void 0&&(u.type=c.type),c.encoding!==void 0&&(u.encoding=c.encoding),c.minFilter!==void 0&&(u.minFilter=t(c.minFilter,If)),c.magFilter!==void 0&&(u.magFilter=t(c.magFilter,If)),c.anisotropy!==void 0&&(u.anisotropy=c.anisotropy),c.flipY!==void 0&&(u.flipY=c.flipY),c.premultiplyAlpha!==void 0&&(u.premultiplyAlpha=c.premultiplyAlpha),c.unpackAlignment!==void 0&&(u.unpackAlignment=c.unpackAlignment),r[c.uuid]=u}return r}parseObject(o,e,t,r){let i,a,c;function u(p){return e[p]===void 0&&console.warn("THREE.ObjectLoader: Undefined geometry",p),e[p]}function h(p){if(p!==void 0){if(Array.isArray(p)){const m=[];for(let g=0,y=p.length;g<y;g++){const x=p[g];t[x]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",x),m.push(t[x])}return m}return t[p]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",p),t[p]}}switch(o.type){case"Scene":i=new Ja,o.background!==void 0&&Number.isInteger(o.background)&&(i.background=new Ge(o.background)),o.fog!==void 0&&(o.fog.type==="Fog"?i.fog=new _o(o.fog.color,o.fog.near,o.fog.far):o.fog.type==="FogExp2"&&(i.fog=new xo(o.fog.color,o.fog.density)));break;case"PerspectiveCamera":i=new gn(o.fov,o.aspect,o.near,o.far),o.focus!==void 0&&(i.focus=o.focus),o.zoom!==void 0&&(i.zoom=o.zoom),o.filmGauge!==void 0&&(i.filmGauge=o.filmGauge),o.filmOffset!==void 0&&(i.filmOffset=o.filmOffset),o.view!==void 0&&(i.view=Object.assign({},o.view));break;case"OrthographicCamera":i=new Uo(o.left,o.right,o.top,o.bottom,o.near,o.far),o.zoom!==void 0&&(i.zoom=o.zoom),o.view!==void 0&&(i.view=Object.assign({},o.view));break;case"AmbientLight":i=new Qu(o.color,o.intensity);break;case"DirectionalLight":i=new Ju(o.color,o.intensity);break;case"PointLight":i=new $u(o.color,o.intensity,o.distance,o.decay);break;case"RectAreaLight":i=new eh(o.color,o.intensity,o.width,o.height);break;case"SpotLight":i=new Zu(o.color,o.intensity,o.distance,o.angle,o.penumbra,o.decay);break;case"HemisphereLight":i=new Xu(o.color,o.groundColor,o.intensity);break;case"LightProbe":i=new Go().fromJSON(o);break;case"SkinnedMesh":a=u(o.geometry),c=h(o.material),i=new sl(a,c),o.bindMode!==void 0&&(i.bindMode=o.bindMode),o.bindMatrix!==void 0&&i.bindMatrix.fromArray(o.bindMatrix),o.skeleton!==void 0&&(i.skeleton=o.skeleton);break;case"Mesh":a=u(o.geometry),c=h(o.material),i=new sn(a,c);break;case"InstancedMesh":a=u(o.geometry),c=h(o.material);const p=o.count,m=o.instanceMatrix,g=o.instanceColor;i=new vu(a,c,p),i.instanceMatrix=new xt(new Float32Array(m.array),16),g!==void 0&&(i.instanceColor=new xt(new Float32Array(g.array),g.itemSize));break;case"LOD":i=new Up;break;case"Line":i=new Jr(u(o.geometry),h(o.material));break;case"LineLoop":i=new xu(u(o.geometry),h(o.material));break;case"LineSegments":i=new jn(u(o.geometry),h(o.material));break;case"PointCloud":case"Points":i=new Eo(u(o.geometry),h(o.material));break;case"Sprite":i=new nl(h(o.material));break;case"Group":i=new Ui;break;case"Bone":i=new ol;break;default:i=new yt}if(i.uuid=o.uuid,o.name!==void 0&&(i.name=o.name),o.matrix!==void 0?(i.matrix.fromArray(o.matrix),o.matrixAutoUpdate!==void 0&&(i.matrixAutoUpdate=o.matrixAutoUpdate),i.matrixAutoUpdate&&i.matrix.decompose(i.position,i.quaternion,i.scale)):(o.position!==void 0&&i.position.fromArray(o.position),o.rotation!==void 0&&i.rotation.fromArray(o.rotation),o.quaternion!==void 0&&i.quaternion.fromArray(o.quaternion),o.scale!==void 0&&i.scale.fromArray(o.scale)),o.castShadow!==void 0&&(i.castShadow=o.castShadow),o.receiveShadow!==void 0&&(i.receiveShadow=o.receiveShadow),o.shadow&&(o.shadow.bias!==void 0&&(i.shadow.bias=o.shadow.bias),o.shadow.normalBias!==void 0&&(i.shadow.normalBias=o.shadow.normalBias),o.shadow.radius!==void 0&&(i.shadow.radius=o.shadow.radius),o.shadow.mapSize!==void 0&&i.shadow.mapSize.fromArray(o.shadow.mapSize),o.shadow.camera!==void 0&&(i.shadow.camera=this.parseObject(o.shadow.camera))),o.visible!==void 0&&(i.visible=o.visible),o.frustumCulled!==void 0&&(i.frustumCulled=o.frustumCulled),o.renderOrder!==void 0&&(i.renderOrder=o.renderOrder),o.userData!==void 0&&(i.userData=o.userData),o.layers!==void 0&&(i.layers.mask=o.layers),o.children!==void 0){const p=o.children;for(let m=0;m<p.length;m++)i.add(this.parseObject(p[m],e,t,r))}if(o.animations!==void 0){const p=o.animations;for(let m=0;m<p.length;m++){const g=p[m];i.animations.push(r[g])}}if(o.type==="LOD"){o.autoUpdate!==void 0&&(i.autoUpdate=o.autoUpdate);const p=o.levels;for(let m=0;m<p.length;m++){const g=p[m],y=i.getObjectByProperty("uuid",g.object);y!==void 0&&i.addLevel(y,g.distance)}}return i}bindSkeletons(o,e){Object.keys(e).length!==0&&o.traverse(function(t){if(t.isSkinnedMesh===!0&&t.skeleton!==void 0){const r=e[t.skeleton];r===void 0?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",t.skeleton):t.bind(r,t.bindMatrix)}})}setTexturePath(o){return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."),this.setResourcePath(o)}},n.ObjectSpaceNormalMap=1,n.OctahedronBufferGeometry=Lo,n.OctahedronGeometry=Lo,n.OneFactor=201,n.OneMinusDstAlphaFactor=207,n.OneMinusDstColorFactor=209,n.OneMinusSrcAlphaFactor=205,n.OneMinusSrcColorFactor=203,n.OrthographicCamera=Uo,n.PCFShadowMap=1,n.PCFSoftShadowMap=2,n.PMREMGenerator=class{constructor(o){this._renderer=o,this._pingPongRenderTarget=null,this._blurMaterial=function(e){const t=new Float32Array(e),r=new O(0,1,0);return new Gs({name:"SphericalGaussianBlur",defines:{n:e},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:t},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:r},inputEncoding:{value:Cr[3e3]},outputEncoding:{value:Cr[3e3]}},vertexShader:fh(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${mh()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:0,depthTest:!1,depthWrite:!1})}(Wl),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}fromScene(o,e=0,t=.1,r=100){ph=this._renderer.getRenderTarget();const i=this._allocateTargets();return this._sceneToCubeUV(o,t,r,i),e>0&&this._blur(i,0,0,e),this._applyPMREM(i),this._cleanup(i),i}fromEquirectangular(o){return this._fromTexture(o)}fromCubemap(o){return this._fromTexture(o)}compileCubemapShader(){this._cubemapShader===null&&(this._cubemapShader=bm(),this._compileMaterial(this._cubemapShader))}compileEquirectangularShader(){this._equirectShader===null&&(this._equirectShader=_m(),this._compileMaterial(this._equirectShader))}dispose(){this._blurMaterial.dispose(),this._cubemapShader!==null&&this._cubemapShader.dispose(),this._equirectShader!==null&&this._equirectShader.dispose();for(let o=0;o<Vo.length;o++)Vo[o].dispose()}_cleanup(o){this._pingPongRenderTarget.dispose(),this._renderer.setRenderTarget(ph),o.scissorTest=!1,ql(o,0,0,o.width,o.height)}_fromTexture(o){ph=this._renderer.getRenderTarget();const e=this._allocateTargets(o);return this._textureToCubeUV(o,e),this._applyPMREM(e),this._cleanup(e),e}_allocateTargets(o){const e={magFilter:1003,minFilter:1003,generateMipmaps:!1,type:1009,format:1023,encoding:t_(o)?o.encoding:3002,depthBuffer:!1},t=xm(e);return t.depthBuffer=!o,this._pingPongRenderTarget=xm(e),t}_compileMaterial(o){const e=new sn(Vo[0],o);this._renderer.compile(e,dh)}_sceneToCubeUV(o,e,t,r){const i=new gn(90,1,e,t),a=[1,-1,1,1,1,1],c=[1,1,1,-1,-1,-1],u=this._renderer,h=u.autoClear,p=u.outputEncoding,m=u.toneMapping;u.getClearColor(gm),u.toneMapping=0,u.outputEncoding=3e3,u.autoClear=!1;let g=!1;const y=o.background;if(y){if(y.isColor){Ki.color.copy(y).convertSRGBToLinear(),o.background=null;const x=ym(Ki.color);Ki.opacity=x,g=!0}}else{Ki.color.copy(gm).convertSRGBToLinear();const x=ym(Ki.color);Ki.opacity=x,g=!0}for(let x=0;x<6;x++){const b=x%3;b==0?(i.up.set(0,a[x],0),i.lookAt(c[x],0,0)):b==1?(i.up.set(0,0,a[x]),i.lookAt(0,c[x],0)):(i.up.set(0,a[x],0),i.lookAt(0,0,c[x])),ql(r,b*Lr,x>2?Lr:0,Lr,Lr),u.setRenderTarget(r),g&&u.render(e_,i),u.render(o,i)}u.toneMapping=m,u.outputEncoding=p,u.autoClear=h}_textureToCubeUV(o,e){const t=this._renderer;o.isCubeTexture?this._cubemapShader==null&&(this._cubemapShader=bm()):this._equirectShader==null&&(this._equirectShader=_m());const r=o.isCubeTexture?this._cubemapShader:this._equirectShader,i=new sn(Vo[0],r),a=r.uniforms;a.envMap.value=o,o.isCubeTexture||a.texelSize.value.set(1/o.image.width,1/o.image.height),a.inputEncoding.value=Cr[o.encoding],a.outputEncoding.value=Cr[e.texture.encoding],ql(e,0,0,3*Lr,2*Lr),t.setRenderTarget(e),t.render(i,dh)}_applyPMREM(o){const e=this._renderer,t=e.autoClear;e.autoClear=!1;for(let r=1;r<fm;r++){const i=Math.sqrt(jl[r]*jl[r]-jl[r-1]*jl[r-1]),a=vm[(r-1)%vm.length];this._blur(o,r-1,r,i,a)}e.autoClear=t}_blur(o,e,t,r,i){const a=this._pingPongRenderTarget;this._halfBlur(o,a,e,t,r,"latitudinal",i),this._halfBlur(a,o,t,t,r,"longitudinal",i)}_halfBlur(o,e,t,r,i,a,c){const u=this._renderer,h=this._blurMaterial;a!=="latitudinal"&&a!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const p=new sn(Vo[r],h),m=h.uniforms,g=mm[t]-1,y=isFinite(i)?Math.PI/(2*g):2*Math.PI/39,x=i/y,b=isFinite(i)?1+Math.floor(3*x):Wl;b>Wl&&console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${b} samples when the maximum is set to 20`);const S=[];let M=0;for(let I=0;I<Wl;++I){const k=I/x,N=Math.exp(-k*k/2);S.push(N),I==0?M+=N:I<b&&(M+=2*N)}for(let I=0;I<S.length;I++)S[I]=S[I]/M;m.envMap.value=o.texture,m.samples.value=b,m.weights.value=S,m.latitudinal.value=a==="latitudinal",c&&(m.poleAxis.value=c),m.dTheta.value=y,m.mipInt.value=8-t,m.inputEncoding.value=Cr[o.texture.encoding],m.outputEncoding.value=Cr[o.texture.encoding];const A=mm[r];ql(e,3*Math.max(0,Lr-2*A),(r===0?0:2*Lr)+2*A*(r>4?r-8+4:0),3*A,2*A),u.setRenderTarget(e),u.render(p,dh)}},n.ParametricBufferGeometry=Ml,n.ParametricGeometry=Ml,n.Particle=function(o){return console.warn("THREE.Particle has been renamed to THREE.Sprite."),new nl(o)},n.ParticleBasicMaterial=function(o){return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."),new Gi(o)},n.ParticleSystem=function(o,e){return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."),new Eo(o,e)},n.ParticleSystemMaterial=function(o){return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."),new Gi(o)},n.Path=Bo,n.PerspectiveCamera=gn,n.Plane=ur,n.PlaneBufferGeometry=go,n.PlaneGeometry=go,n.PlaneHelper=class extends Jr{constructor(o,e=1,t=16776960){const r=t,i=new Qe;i.setAttribute("position",new qe([1,-1,1,-1,1,1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,0,0,1,0,0,0],3)),i.computeBoundingSphere(),super(i,new vn({color:r,toneMapped:!1})),this.type="PlaneHelper",this.plane=o,this.size=e;const a=new Qe;a.setAttribute("position",new qe([1,1,1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,1],3)),a.computeBoundingSphere(),this.add(new sn(a,new Zr({color:r,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(o){let e=-this.plane.constant;Math.abs(e)<1e-8&&(e=1e-8),this.scale.set(.5*this.size,.5*this.size,e),this.children[0].material.side=e<0?1:0,this.lookAt(this.plane.normal),super.updateMatrixWorld(o)}},n.PointCloud=function(o,e){return console.warn("THREE.PointCloud has been renamed to THREE.Points."),new Eo(o,e)},n.PointCloudMaterial=function(o){return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."),new Gi(o)},n.PointLight=$u,n.PointLightHelper=class extends sn{constructor(o,e,t){super(new Po(e,4,2),new Zr({wireframe:!0,fog:!1,toneMapped:!1})),this.light=o,this.light.updateMatrixWorld(),this.color=t,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}},n.Points=Eo,n.PointsMaterial=Gi,n.PolarGridHelper=class extends jn{constructor(o=10,e=16,t=8,r=64,i=4473924,a=8947848){i=new Ge(i),a=new Ge(a);const c=[],u=[];for(let p=0;p<=e;p++){const m=p/e*(2*Math.PI),g=Math.sin(m)*o,y=Math.cos(m)*o;c.push(0,0,0),c.push(g,0,y);const x=1&p?i:a;u.push(x.r,x.g,x.b),u.push(x.r,x.g,x.b)}for(let p=0;p<=t;p++){const m=1&p?i:a,g=o-o/t*p;for(let y=0;y<r;y++){let x=y/r*(2*Math.PI),b=Math.sin(x)*g,S=Math.cos(x)*g;c.push(b,0,S),u.push(m.r,m.g,m.b),x=(y+1)/r*(2*Math.PI),b=Math.sin(x)*g,S=Math.cos(x)*g,c.push(b,0,S),u.push(m.r,m.g,m.b)}}const h=new Qe;h.setAttribute("position",new qe(c,3)),h.setAttribute("color",new qe(u,3)),super(h,new vn({vertexColors:!0,toneMapped:!1})),this.type="PolarGridHelper"}},n.PolyhedronBufferGeometry=Mi,n.PolyhedronGeometry=Mi,n.PositionalAudio=class extends ah{constructor(o){super(o),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(o){return this.panner.refDistance=o,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(o){return this.panner.rolloffFactor=o,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(o){return this.panner.distanceModel=o,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(o){return this.panner.maxDistance=o,this}setDirectionalCone(o,e,t){return this.panner.coneInnerAngle=o,this.panner.coneOuterAngle=e,this.panner.coneOuterGain=t,this}updateMatrixWorld(o){if(super.updateMatrixWorld(o),this.hasPlaybackControl===!0&&this.isPlaying===!1)return;this.matrixWorld.decompose(Yi,Vf,Ux),Zi.set(0,0,1).applyQuaternion(Vf);const e=this.panner;if(e.positionX){const t=this.context.currentTime+this.listener.timeDelta;e.positionX.linearRampToValueAtTime(Yi.x,t),e.positionY.linearRampToValueAtTime(Yi.y,t),e.positionZ.linearRampToValueAtTime(Yi.z,t),e.orientationX.linearRampToValueAtTime(Zi.x,t),e.orientationY.linearRampToValueAtTime(Zi.y,t),e.orientationZ.linearRampToValueAtTime(Zi.z,t)}else e.setPosition(Yi.x,Yi.y,Yi.z),e.setOrientation(Zi.x,Zi.y,Zi.z)}},n.PropertyBinding=Lt,n.PropertyMixer=jf,n.QuadraticBezierCurve=Dl,n.QuadraticBezierCurve3=ju,n.Quaternion=fn,n.QuaternionKeyframeTrack=Vs,n.QuaternionLinearInterpolant=ff,n.REVISION=s,n.RGBADepthPacking=3201,n.RGBAFormat=1023,n.RGBAIntegerFormat=1033,n.RGBA_ASTC_10x10_Format=37819,n.RGBA_ASTC_10x5_Format=37816,n.RGBA_ASTC_10x6_Format=37817,n.RGBA_ASTC_10x8_Format=37818,n.RGBA_ASTC_12x10_Format=37820,n.RGBA_ASTC_12x12_Format=37821,n.RGBA_ASTC_4x4_Format=37808,n.RGBA_ASTC_5x4_Format=37809,n.RGBA_ASTC_5x5_Format=37810,n.RGBA_ASTC_6x5_Format=37811,n.RGBA_ASTC_6x6_Format=37812,n.RGBA_ASTC_8x5_Format=37813,n.RGBA_ASTC_8x6_Format=37814,n.RGBA_ASTC_8x8_Format=37815,n.RGBA_BPTC_Format=36492,n.RGBA_ETC2_EAC_Format=37496,n.RGBA_PVRTC_2BPPV1_Format=35843,n.RGBA_PVRTC_4BPPV1_Format=35842,n.RGBA_S3TC_DXT1_Format=33777,n.RGBA_S3TC_DXT3_Format=33778,n.RGBA_S3TC_DXT5_Format=33779,n.RGBDEncoding=3006,n.RGBEEncoding=3002,n.RGBEFormat=1023,n.RGBFormat=1022,n.RGBIntegerFormat=1032,n.RGBM16Encoding=3005,n.RGBM7Encoding=3004,n.RGB_ETC1_Format=36196,n.RGB_ETC2_Format=37492,n.RGB_PVRTC_2BPPV1_Format=35841,n.RGB_PVRTC_4BPPV1_Format=35840,n.RGB_S3TC_DXT1_Format=33776,n.RGFormat=1030,n.RGIntegerFormat=1031,n.RawShaderMaterial=Gs,n.Ray=gi,n.Raycaster=class{constructor(o,e,t=0,r=1/0){this.ray=new gi(o,e),this.near=t,this.far=r,this.camera=null,this.layers=new Zc,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(o,e){this.ray.set(o,e)}setFromCamera(o,e){e&&e.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(o.x,o.y,.5).unproject(e).sub(this.ray.origin).normalize(),this.camera=e):e&&e.isOrthographicCamera?(this.ray.origin.set(o.x,o.y,(e.near+e.far)/(e.near-e.far)).unproject(e),this.ray.direction.set(0,0,-1).transformDirection(e.matrixWorld),this.camera=e):console.error("THREE.Raycaster: Unsupported camera type: "+e.type)}intersectObject(o,e=!1,t=[]){return ch(o,this,t,e),t.sort(Kf),t}intersectObjects(o,e=!1,t=[]){for(let r=0,i=o.length;r<i;r++)ch(o[r],this,t,e);return t.sort(Kf),t}},n.RectAreaLight=eh,n.RedFormat=1028,n.RedIntegerFormat=1029,n.ReinhardToneMapping=2,n.RepeatWrapping=1e3,n.ReplaceStencilOp=7681,n.ReverseSubtractEquation=102,n.RingBufferGeometry=Sl,n.RingGeometry=Sl,n.SRGB8_ALPHA8_ASTC_10x10_Format=37851,n.SRGB8_ALPHA8_ASTC_10x5_Format=37848,n.SRGB8_ALPHA8_ASTC_10x6_Format=37849,n.SRGB8_ALPHA8_ASTC_10x8_Format=37850,n.SRGB8_ALPHA8_ASTC_12x10_Format=37852,n.SRGB8_ALPHA8_ASTC_12x12_Format=37853,n.SRGB8_ALPHA8_ASTC_4x4_Format=37840,n.SRGB8_ALPHA8_ASTC_5x4_Format=37841,n.SRGB8_ALPHA8_ASTC_5x5_Format=37842,n.SRGB8_ALPHA8_ASTC_6x5_Format=37843,n.SRGB8_ALPHA8_ASTC_6x6_Format=37844,n.SRGB8_ALPHA8_ASTC_8x5_Format=37845,n.SRGB8_ALPHA8_ASTC_8x6_Format=37846,n.SRGB8_ALPHA8_ASTC_8x8_Format=37847,n.Scene=Ja,n.SceneUtils=r_,n.ShaderChunk=_t,n.ShaderLib=pr,n.ShaderMaterial=Kr,n.ShadowMaterial=Au,n.Shape=Ei,n.ShapeBufferGeometry=Co,n.ShapeGeometry=Co,n.ShapePath=Df,n.ShapeUtils=Ar,n.ShortType=1011,n.Skeleton=al,n.SkeletonHelper=nm,n.SkinnedMesh=sl,n.SmoothShading=2,n.Sphere=fi,n.SphereBufferGeometry=Po,n.SphereGeometry=Po,n.Spherical=class{constructor(o=1,e=0,t=0){return this.radius=o,this.phi=e,this.theta=t,this}set(o,e,t){return this.radius=o,this.phi=e,this.theta=t,this}copy(o){return this.radius=o.radius,this.phi=o.phi,this.theta=o.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(o){return this.setFromCartesianCoords(o.x,o.y,o.z)}setFromCartesianCoords(o,e,t){return this.radius=Math.sqrt(o*o+e*e+t*t),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(o,t),this.phi=Math.acos(ct(e/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}},n.SphericalHarmonics3=th,n.SplineCurve=Nl,n.SpotLight=Zu,n.SpotLightHelper=class extends yt{constructor(o,e){super(),this.light=o,this.light.updateMatrixWorld(),this.matrix=o.matrixWorld,this.matrixAutoUpdate=!1,this.color=e;const t=new Qe,r=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let a=0,c=1,u=32;a<u;a++,c++){const h=a/u*Math.PI*2,p=c/u*Math.PI*2;r.push(Math.cos(h),Math.sin(h),1,Math.cos(p),Math.sin(p),1)}t.setAttribute("position",new qe(r,3));const i=new vn({fog:!1,toneMapped:!1});this.cone=new jn(t,i),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateMatrixWorld();const o=this.light.distance?this.light.distance:1e3,e=o*Math.tan(this.light.angle);this.cone.scale.set(e,e,o),tm.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(tm),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}},n.Sprite=nl,n.SpriteMaterial=Qa,n.SrcAlphaFactor=204,n.SrcAlphaSaturateFactor=210,n.SrcColorFactor=202,n.StaticCopyUsage=35046,n.StaticDrawUsage=35044,n.StaticReadUsage=35045,n.StereoCamera=class{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new gn,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new gn,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(o){const e=this._cache;if(e.focus!==o.focus||e.fov!==o.fov||e.aspect!==o.aspect*this.aspect||e.near!==o.near||e.far!==o.far||e.zoom!==o.zoom||e.eyeSep!==this.eyeSep){e.focus=o.focus,e.fov=o.fov,e.aspect=o.aspect*this.aspect,e.near=o.near,e.far=o.far,e.zoom=o.zoom,e.eyeSep=this.eyeSep;const t=o.projectionMatrix.clone(),r=e.eyeSep/2,i=r*e.near/e.focus,a=e.near*Math.tan(Ue*e.fov*.5)/e.zoom;let c,u;Bf.elements[12]=-r,Ff.elements[12]=r,c=-a*e.aspect+i,u=a*e.aspect+i,t.elements[0]=2*e.near/(u-c),t.elements[8]=(u+c)/(u-c),this.cameraL.projectionMatrix.copy(t),c=-a*e.aspect-i,u=a*e.aspect-i,t.elements[0]=2*e.near/(u-c),t.elements[8]=(u+c)/(u-c),this.cameraR.projectionMatrix.copy(t)}this.cameraL.matrixWorld.copy(o.matrixWorld).multiply(Bf),this.cameraR.matrixWorld.copy(o.matrixWorld).multiply(Ff)}},n.StreamCopyUsage=35042,n.StreamDrawUsage=35040,n.StreamReadUsage=35041,n.StringKeyframeTrack=Wi,n.SubtractEquation=101,n.SubtractiveBlending=3,n.TOUCH={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},n.TangentSpaceNormalMap=0,n.TetrahedronBufferGeometry=El,n.TetrahedronGeometry=El,n.TextBufferGeometry=Tl,n.TextGeometry=Tl,n.Texture=un,n.TextureLoader=yf,n.TorusBufferGeometry=Al,n.TorusGeometry=Al,n.TorusKnotBufferGeometry=Rl,n.TorusKnotGeometry=Rl,n.Triangle=Jt,n.TriangleFanDrawMode=2,n.TriangleStripDrawMode=1,n.TrianglesDrawMode=0,n.TubeBufferGeometry=Ll,n.TubeGeometry=Ll,n.UVMapping=300,n.Uint16Attribute=function(o,e){return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."),new Ha(o,e)},n.Uint16BufferAttribute=Ha,n.Uint32Attribute=function(o,e){return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."),new Fa(o,e)},n.Uint32BufferAttribute=Fa,n.Uint8Attribute=function(o,e){return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."),new rp(o,e)},n.Uint8BufferAttribute=rp,n.Uint8ClampedAttribute=function(o,e){return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."),new ip(o,e)},n.Uint8ClampedBufferAttribute=ip,n.Uniform=Hl,n.UniformsLib=Be,n.UniformsUtils=hp,n.UnsignedByteType=1009,n.UnsignedInt248Type=1020,n.UnsignedIntType=1014,n.UnsignedShort4444Type=1017,n.UnsignedShort5551Type=1018,n.UnsignedShort565Type=1019,n.UnsignedShortType=1012,n.VSMShadowMap=3,n.Vector2=Ee,n.Vector3=O,n.Vector4=Dt,n.VectorKeyframeTrack=Oo,n.Vertex=function(o,e,t){return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."),new O(o,e,t)},n.VertexColors=2,n.VideoTexture=nf,n.WebGL1Renderer=kp,n.WebGLCubeRenderTarget=Ya,n.WebGLMultisampleRenderTarget=Wd,n.WebGLRenderTarget=Vr,n.WebGLRenderTargetCube=function(o,e,t){return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."),new Ya(o,t)},n.WebGLRenderer=Ut,n.WebGLUtils=Np,n.WireframeGeometry=Tu,n.WireframeHelper=function(o,e){return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."),new jn(new Tu(o.geometry),new vn({color:e!==void 0?e:16777215}))},n.WrapAroundEnding=2402,n.XHRLoader=function(o){return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."),new Rr(o)},n.ZeroCurvatureEnding=2400,n.ZeroFactor=200,n.ZeroSlopeEnding=2401,n.ZeroStencilOp=0,n.sRGBEncoding=3001,Object.defineProperty(n,"__esModule",{value:!0})});(function(n){var s=n.noise={};function l(C,z,j){this.x=C,this.y=z,this.z=j}l.prototype.dot2=function(C,z){return this.x*C+this.y*z},l.prototype.dot3=function(C,z,j){return this.x*C+this.y*z+this.z*j};var d=[new l(1,1,0),new l(-1,1,0),new l(1,-1,0),new l(-1,-1,0),new l(1,0,1),new l(-1,0,1),new l(1,0,-1),new l(-1,0,-1),new l(0,1,1),new l(0,-1,1),new l(0,1,-1),new l(0,-1,-1)],f=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180],v=new Array(512),_=new Array(512);s.seed=function(C){C>0&&C<1&&(C*=65536),C=Math.floor(C),C<256&&(C|=C<<8);for(var z=0;z<256;z++){var j;z&1?j=f[z]^C&255:j=f[z]^C>>8&255,v[z]=v[z+256]=j,_[z]=_[z+256]=d[j%12]}},s.seed(0);var w=.5*(Math.sqrt(3)-1),R=(3-Math.sqrt(3))/6,L=1/3,T=1/6;s.simplex2=function(C,z){var j,ne,pe,ie=(C+z)*w,ae=Math.floor(C+ie),xe=Math.floor(z+ie),Te=(ae+xe)*R,Ke=C-ae+Te,at=z-xe+Te,lt,pt;Ke>at?(lt=1,pt=0):(lt=0,pt=1);var Ct=Ke-lt+R,Mt=at-pt+R,At=Ke-1+2*R,Et=at-1+2*R;ae&=255,xe&=255;var tn=_[ae+v[xe]],zt=_[ae+lt+v[xe+pt]],It=_[ae+1+v[xe+1]],Je=.5-Ke*Ke-at*at;Je<0?j=0:(Je*=Je,j=Je*Je*tn.dot2(Ke,at));var et=.5-Ct*Ct-Mt*Mt;et<0?ne=0:(et*=et,ne=et*et*zt.dot2(Ct,Mt));var Vt=.5-At*At-Et*Et;return Vt<0?pe=0:(Vt*=Vt,pe=Vt*Vt*It.dot2(At,Et)),70*(j+ne+pe)},s.simplex3=function(C,z,j){var ne,pe,ie,ae,xe=(C+z+j)*L,Te=Math.floor(C+xe),Ke=Math.floor(z+xe),at=Math.floor(j+xe),lt=(Te+Ke+at)*T,pt=C-Te+lt,Ct=z-Ke+lt,Mt=j-at+lt,At,Et,tn,zt,It,Je;pt>=Ct?Ct>=Mt?(At=1,Et=0,tn=0,zt=1,It=1,Je=0):pt>=Mt?(At=1,Et=0,tn=0,zt=1,It=0,Je=1):(At=0,Et=0,tn=1,zt=1,It=0,Je=1):Ct<Mt?(At=0,Et=0,tn=1,zt=0,It=1,Je=1):pt<Mt?(At=0,Et=1,tn=0,zt=0,It=1,Je=1):(At=0,Et=1,tn=0,zt=1,It=1,Je=0);var et=pt-At+T,Vt=Ct-Et+T,Vn=Mt-tn+T,Cn=pt-zt+2*T,bn=Ct-It+2*T,cn=Mt-Je+2*T,Pn=pt-1+3*T,In=Ct-1+3*T,On=Mt-1+3*T;Te&=255,Ke&=255,at&=255;var se=_[Te+v[Ke+v[at]]],Fe=_[Te+At+v[Ke+Et+v[at+tn]]],Ne=_[Te+zt+v[Ke+It+v[at+Je]]],Ye=_[Te+1+v[Ke+1+v[at+1]]],$e=.6-pt*pt-Ct*Ct-Mt*Mt;$e<0?ne=0:($e*=$e,ne=$e*$e*se.dot3(pt,Ct,Mt));var Pt=.6-et*et-Vt*Vt-Vn*Vn;Pt<0?pe=0:(Pt*=Pt,pe=Pt*Pt*Fe.dot3(et,Vt,Vn));var D=.6-Cn*Cn-bn*bn-cn*cn;D<0?ie=0:(D*=D,ie=D*D*Ne.dot3(Cn,bn,cn));var F=.6-Pn*Pn-In*In-On*On;return F<0?ae=0:(F*=F,ae=F*F*Ye.dot3(Pn,In,On)),32*(ne+pe+ie+ae)};function E(C){return C*C*C*(C*(C*6-15)+10)}function P(C,z,j){return(1-j)*C+j*z}s.perlin2=function(C,z){var j=Math.floor(C),ne=Math.floor(z);C=C-j,z=z-ne,j=j&255,ne=ne&255;var pe=_[j+v[ne]].dot2(C,z),ie=_[j+v[ne+1]].dot2(C,z-1),ae=_[j+1+v[ne]].dot2(C-1,z),xe=_[j+1+v[ne+1]].dot2(C-1,z-1),Te=E(C);return P(P(pe,ae,Te),P(ie,xe,Te),E(z))},s.perlin3=function(C,z,j){var ne=Math.floor(C),pe=Math.floor(z),ie=Math.floor(j);C=C-ne,z=z-pe,j=j-ie,ne=ne&255,pe=pe&255,ie=ie&255;var ae=_[ne+v[pe+v[ie]]].dot3(C,z,j),xe=_[ne+v[pe+v[ie+1]]].dot3(C,z,j-1),Te=_[ne+v[pe+1+v[ie]]].dot3(C,z-1,j),Ke=_[ne+v[pe+1+v[ie+1]]].dot3(C,z-1,j-1),at=_[ne+1+v[pe+v[ie]]].dot3(C-1,z,j),lt=_[ne+1+v[pe+v[ie+1]]].dot3(C-1,z,j-1),pt=_[ne+1+v[pe+1+v[ie]]].dot3(C-1,z-1,j),Ct=_[ne+1+v[pe+1+v[ie+1]]].dot3(C-1,z-1,j-1),Mt=E(C),At=E(z),Et=E(j);return P(P(P(ae,at,Mt),P(xe,lt,Mt),Et),P(P(Te,pt,Mt),P(Ke,Ct,Mt),Et),At)}})(void 0);THREE.OrbitControls=function(n,s){this.object=n,this.domElement=s!==void 0?s:document,this.enabled=!0,this.target=new THREE.Vector3,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.25,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.enableKeys=!0,this.keys={LEFT:37,UP:38,RIGHT:39,BOTTOM:40},this.mouseButtons={ORBIT:THREE.MOUSE.LEFT,ZOOM:THREE.MOUSE.MIDDLE,PAN:THREE.MOUSE.RIGHT},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this.getPolarAngle=function(){return L.phi},this.getAzimuthalAngle=function(){return L.theta},this.reset=function(){l.target.copy(l.target0),l.object.position.copy(l.position0),l.object.zoom=l.zoom0,l.object.updateProjectionMatrix(),l.dispatchEvent(d),l.update(),w=_.NONE},this.update=function(){var X=new THREE.Vector3,Se=new THREE.Quaternion().setFromUnitVectors(n.up,new THREE.Vector3(0,1,0)),we=Se.clone().inverse(),ce=new THREE.Vector3,He=new THREE.Quaternion;return function(){var Ue=l.object.position;return X.copy(Ue).sub(l.target),X.applyQuaternion(Se),L.setFromVector3(X),l.autoRotate&&w===_.NONE&&pt(at()),L.theta+=T.theta,L.phi+=T.phi,L.theta=Math.max(l.minAzimuthAngle,Math.min(l.maxAzimuthAngle,L.theta)),L.phi=Math.max(l.minPolarAngle,Math.min(l.maxPolarAngle,L.phi)),L.makeSafe(),L.radius*=E,L.radius=Math.max(l.minDistance,Math.min(l.maxDistance,L.radius)),l.target.add(P),X.setFromSpherical(L),X.applyQuaternion(we),Ue.copy(l.target).add(X),l.object.lookAt(l.target),l.enableDamping===!0?(T.theta*=1-l.dampingFactor,T.phi*=1-l.dampingFactor):T.set(0,0,0),E=1,P.set(0,0,0),C||ce.distanceToSquared(l.object.position)>R||8*(1-He.dot(l.object.quaternion))>R?(l.dispatchEvent(d),ce.copy(l.object.position),He.copy(l.object.quaternion),C=!1,!0):!1}}(),this.dispose=function(){l.domElement.removeEventListener("contextmenu",be,!1),l.domElement.removeEventListener("mousedown",Ye,!1),l.domElement.removeEventListener("wheel",D,!1),l.domElement.removeEventListener("touchstart",$,!1),l.domElement.removeEventListener("touchend",ue,!1),l.domElement.removeEventListener("touchmove",_e,!1),document.removeEventListener("mousemove",$e,!1),document.removeEventListener("mouseup",Pt,!1),window.removeEventListener("keydown",F,!1)};var l=this,d={type:"change"},f={type:"start"},v={type:"end"},_={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_DOLLY:4,TOUCH_PAN:5},w=_.NONE,R=1e-6,L=new THREE.Spherical,T=new THREE.Spherical,E=1,P=new THREE.Vector3,C=!1,z=new THREE.Vector2,j=new THREE.Vector2,ne=new THREE.Vector2,pe=new THREE.Vector2,ie=new THREE.Vector2,ae=new THREE.Vector2,xe=new THREE.Vector2,Te=new THREE.Vector2,Ke=new THREE.Vector2;function at(){return 2*Math.PI/60/60*l.autoRotateSpeed}function lt(){return Math.pow(.95,l.zoomSpeed)}function pt(X){T.theta-=X}function Ct(X){T.phi-=X}var Mt=function(){var X=new THREE.Vector3;return function(we,ce){X.setFromMatrixColumn(ce,0),X.multiplyScalar(-we),P.add(X)}}(),At=function(){var X=new THREE.Vector3;return function(we,ce){X.setFromMatrixColumn(ce,1),X.multiplyScalar(we),P.add(X)}}(),Et=function(){var X=new THREE.Vector3;return function(we,ce){var He=l.domElement===document?l.domElement.body:l.domElement;if(l.object instanceof THREE.PerspectiveCamera){var Le=l.object.position;X.copy(Le).sub(l.target);var Ue=X.length();Ue*=Math.tan(l.object.fov/2*Math.PI/180),Mt(2*we*Ue/He.clientHeight,l.object.matrix),At(2*ce*Ue/He.clientHeight,l.object.matrix)}else l.object instanceof THREE.OrthographicCamera?(Mt(we*(l.object.right-l.object.left)/l.object.zoom/He.clientWidth,l.object.matrix),At(ce*(l.object.top-l.object.bottom)/l.object.zoom/He.clientHeight,l.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),l.enablePan=!1)}}();function tn(X){l.object instanceof THREE.PerspectiveCamera?E/=X:l.object instanceof THREE.OrthographicCamera?(l.object.zoom=Math.max(l.minZoom,Math.min(l.maxZoom,l.object.zoom*X)),l.object.updateProjectionMatrix(),C=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),l.enableZoom=!1)}function zt(X){l.object instanceof THREE.PerspectiveCamera?E*=X:l.object instanceof THREE.OrthographicCamera?(l.object.zoom=Math.max(l.minZoom,Math.min(l.maxZoom,l.object.zoom/X)),l.object.updateProjectionMatrix(),C=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),l.enableZoom=!1)}function It(X){z.set(X.clientX,X.clientY)}function Je(X){xe.set(X.clientX,X.clientY)}function et(X){pe.set(X.clientX,X.clientY)}function Vt(X){j.set(X.clientX,X.clientY),ne.subVectors(j,z);var Se=l.domElement===document?l.domElement.body:l.domElement;pt(2*Math.PI*ne.x/Se.clientWidth*l.rotateSpeed),Ct(2*Math.PI*ne.y/Se.clientHeight*l.rotateSpeed),z.copy(j),l.update()}function Vn(X){Te.set(X.clientX,X.clientY),Ke.subVectors(Te,xe),Ke.y>0?tn(lt()):Ke.y<0&&zt(lt()),xe.copy(Te),l.update()}function Cn(X){ie.set(X.clientX,X.clientY),ae.subVectors(ie,pe),Et(ae.x,ae.y),pe.copy(ie),l.update()}function bn(X){X.deltaY<0?zt(lt()):X.deltaY>0&&tn(lt()),l.update()}function cn(X){switch(X.keyCode){case l.keys.UP:Et(0,l.keyPanSpeed),l.update();break;case l.keys.BOTTOM:Et(0,-l.keyPanSpeed),l.update();break;case l.keys.LEFT:Et(l.keyPanSpeed,0),l.update();break;case l.keys.RIGHT:Et(-l.keyPanSpeed,0),l.update();break}}function Pn(X){z.set(X.touches[0].pageX,X.touches[0].pageY)}function In(X){var Se=X.touches[0].pageX-X.touches[1].pageX,we=X.touches[0].pageY-X.touches[1].pageY,ce=Math.sqrt(Se*Se+we*we);xe.set(0,ce)}function On(X){pe.set(X.touches[0].pageX,X.touches[0].pageY)}function se(X){j.set(X.touches[0].pageX,X.touches[0].pageY),ne.subVectors(j,z);var Se=l.domElement===document?l.domElement.body:l.domElement;pt(2*Math.PI*ne.x/Se.clientWidth*l.rotateSpeed),Ct(2*Math.PI*ne.y/Se.clientHeight*l.rotateSpeed),z.copy(j),l.update()}function Fe(X){var Se=X.touches[0].pageX-X.touches[1].pageX,we=X.touches[0].pageY-X.touches[1].pageY,ce=Math.sqrt(Se*Se+we*we);Te.set(0,ce),Ke.subVectors(Te,xe),Ke.y>0?zt(lt()):Ke.y<0&&tn(lt()),xe.copy(Te),l.update()}function Ne(X){ie.set(X.touches[0].pageX,X.touches[0].pageY),ae.subVectors(ie,pe),Et(ae.x,ae.y),pe.copy(ie),l.update()}function Ye(X){if(l.enabled!==!1){if(X.preventDefault(),X.button===l.mouseButtons.ORBIT){if(l.enableRotate===!1)return;It(X),w=_.ROTATE}else if(X.button===l.mouseButtons.ZOOM){if(l.enableZoom===!1)return;Je(X),w=_.DOLLY}else if(X.button===l.mouseButtons.PAN){if(l.enablePan===!1)return;et(X),w=_.PAN}w!==_.NONE&&(document.addEventListener("mousemove",$e,!1),document.addEventListener("mouseup",Pt,!1),l.dispatchEvent(f))}}function $e(X){if(l.enabled!==!1){if(X.preventDefault(),w===_.ROTATE){if(l.enableRotate===!1)return;Vt(X)}else if(w===_.DOLLY){if(l.enableZoom===!1)return;Vn(X)}else if(w===_.PAN){if(l.enablePan===!1)return;Cn(X)}}}function Pt(X){l.enabled!==!1&&(document.removeEventListener("mousemove",$e,!1),document.removeEventListener("mouseup",Pt,!1),l.dispatchEvent(v),w=_.NONE)}function D(X){l.enabled===!1||l.enableZoom===!1||w!==_.NONE&&w!==_.ROTATE||(X.preventDefault(),X.stopPropagation(),bn(X),l.dispatchEvent(f),l.dispatchEvent(v))}function F(X){l.enabled===!1||l.enableKeys===!1||l.enablePan===!1||cn(X)}function $(X){if(l.enabled!==!1){switch(X.touches.length){case 1:if(l.enableRotate===!1)return;Pn(X),w=_.TOUCH_ROTATE;break;case 2:if(l.enableZoom===!1)return;In(X),w=_.TOUCH_DOLLY;break;case 3:if(l.enablePan===!1)return;On(X),w=_.TOUCH_PAN;break;default:w=_.NONE}w!==_.NONE&&l.dispatchEvent(f)}}function _e(X){if(l.enabled!==!1)switch(X.preventDefault(),X.stopPropagation(),X.touches.length){case 1:if(l.enableRotate===!1||w!==_.TOUCH_ROTATE)return;se(X);break;case 2:if(l.enableZoom===!1||w!==_.TOUCH_DOLLY)return;Fe(X);break;case 3:if(l.enablePan===!1||w!==_.TOUCH_PAN)return;Ne(X);break;default:w=_.NONE}}function ue(X){l.enabled!==!1&&(l.dispatchEvent(v),w=_.NONE)}function be(X){X.preventDefault()}l.domElement.addEventListener("contextmenu",be,!1),l.domElement.addEventListener("mousedown",Ye,!1),l.domElement.addEventListener("wheel",D,!1),l.domElement.addEventListener("touchstart",$,!1),l.domElement.addEventListener("touchend",ue,!1),l.domElement.addEventListener("touchmove",_e,!1),window.addEventListener("keydown",F,!1),this.update()};THREE.OrbitControls.prototype=Object.create(THREE.EventDispatcher.prototype);THREE.OrbitControls.prototype.constructor=THREE.OrbitControls;Object.defineProperties(THREE.OrbitControls.prototype,{center:{get:function(){return console.warn("THREE.OrbitControls: .center has been renamed to .target"),this.target}},noZoom:{get:function(){return console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."),!this.enableZoom},set:function(n){console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."),this.enableZoom=!n}},noRotate:{get:function(){return console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."),!this.enableRotate},set:function(n){console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."),this.enableRotate=!n}},noPan:{get:function(){return console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."),!this.enablePan},set:function(n){console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."),this.enablePan=!n}},noKeys:{get:function(){return console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."),!this.enableKeys},set:function(n){console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."),this.enableKeys=!n}},staticMoving:{get:function(){return console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."),!this.enableDamping},set:function(n){console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."),this.enableDamping=!n}},dynamicDampingFactor:{get:function(){return console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."),this.dampingFactor},set:function(n){console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."),this.dampingFactor=n}}});let tr=new THREE.Scene,Fh=0;const s_=new THREE.Clock,Dm=new THREE.Raycaster,xh=new THREE.Vector2,qo=new THREE.Group,Ri=new THREE.PerspectiveCamera(45,window.innerWidth/window.innerHeight,1,1e3),eo=["box","cone","cylinder","octahedron","sphere","tetrahedron","torus","torusKnot"],o_=n=>{xh.x=n.clientX/window.innerWidth*2-1,xh.y=-(n.clientY/window.innerHeight)*2+1,Dm.setFromCamera(xh,Ri);const s=Dm.intersectObjects(tr.children,!0);if(s.length>0){const l=s[0].object;eo.includes(l.name)&&(Fh=(Fh+1)%eo.length)}},a_=()=>{tr.clear(),qo.clear(),tr.add(qo);const n=c_("standard","rgb(255, 255, 255)");eo.forEach(function(C){const z=l_(C,5,n);tr.add(z),tr.background});const l=Nm(1,"rgb(255, 220, 180)"),d=Nm(1,"rgb(255, 220, 180)"),f=u_(.33,"rgb(255, 220, 150)");l.position.x=-5,l.position.y=2,l.position.z=-4,d.position.x=5,d.position.y=2,d.position.z=-4,f.position.x=0,f.position.y=10,f.position.z=0;const v="/assets/cubemap/",_=".png",w=["nx","ny","nz","px","py","pz"],R=new THREE.CubeTextureLoader().load(w.map(function(C){return v+C+_}));tr.background=R;const L=new THREE.TextureLoader;n.roughnessMap=L.load("/assets/textures/scratch.jpg"),n.bumpMap=L.load("/assets/textures/scratch.jpg"),n.bumpScale=.01,n.envMap=R,n.roughness=.5,n.metalness=.7,["bumpMap","roughnessMap"].forEach(function(C){const z=n[C];z.wrapS=THREE.RepeatWrapping,z.wrapT=THREE.RepeatWrapping,z.repeat.set(1,1)}),tr.add(l),tr.add(d),tr.add(f),Ri.position.z=20,Ri.position.x=0,Ri.position.y=5,Ri.lookAt(new THREE.Vector3(0,0,0)),qo.add(Ri),qo.name="sceneCameraGroup",tr.add(qo);const E=new THREE.WebGLRenderer,P=document.querySelector("#three-container");return E.setSize(window.innerWidth,window.innerHeight-50),E.domElement.addEventListener("click",o_,!1),E.shadowMap.type=THREE.PCFSoftShadowMap,E.shadowMap.enabled=!0,P.appendChild(E.domElement),new THREE.OrbitControls(Ri,E.domElement),Vg(E,tr,Ri,s_),tr},l_=(n,s,l)=>{let d;switch(n){case"box":d=new THREE.BoxGeometry(s,s,s);break;case"cone":d=new THREE.ConeGeometry(s,s,256*1);break;case"cylinder":d=new THREE.CylinderGeometry(s,s,s,32*1);break;case"octahedron":d=new THREE.OctahedronGeometry(s);break;case"sphere":d=new THREE.SphereGeometry(s,32*1,32*1);break;case"tetrahedron":d=new THREE.TetrahedronGeometry(s);break;case"torus":d=new THREE.TorusGeometry(s/2,s/4,16*1,100*1);break;case"torusKnot":d=new THREE.TorusKnotGeometry(s/2,s/6,256*1,100*1);break}const v=new THREE.Mesh(d,l);return v.castShadow=!0,v.name=n,v},c_=(n,s)=>{let l;const d={color:s};switch(n){case"basic":l=new THREE.MeshBasicMaterial(d);break;case"lambert":l=new THREE.MeshLambertMaterial(d);break;case"phong":l=new THREE.MeshPhongMaterial(d);break;case"standard":l=new THREE.MeshStandardMaterial(d);break;default:l=new THREE.MeshBasicMaterial(d);break}return l},u_=(n,s)=>{const l=new THREE.PointLight(s,n);return l.castShadow=!0,l},Nm=(n,s)=>{s=s===void 0?"rgb(255, 255, 255)":s;const l=new THREE.SpotLight(s,n);return l.castShadow=!0,l.penumbra=.5,l.shadow.mapSize.width=1024,l.shadow.mapSize.height=1024,l.shadow.camera.near=.1,l.shadow.camera.far=500,l.shadow.camera.fov=30,l.shadow.bias=.001,l},Vg=(n,s,l,d)=>{const f=s.getObjectByName("sceneCameraGroup");f&&(f.rotation.y+=.002);const _=(Math.floor(d.getElapsedTime()/4%eo.length)+Fh)%eo.length;eo.forEach(function(w,R){const L=s.getObjectByName(w);R===_?L.visible=!0:L.visible=!1}),n.render(s,l),requestAnimationFrame(function(){Vg(n,s,l,d)})};function hd(){const n=document.querySelector("#three-container");n&&n.offsetParent!==null?tr=a_():setTimeout(hd,100)}window.waitForContainer=hd;hd();/**
* @vue/shared v3.5.24
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/function li(n){const s=Object.create(null);for(const l of n.split(","))s[l]=1;return l=>l in s}const Bt=Object.freeze({}),to=Object.freeze([]),Ln=()=>{},Wg=()=>!1,ba=n=>n.charCodeAt(0)===111&&n.charCodeAt(1)===110&&(n.charCodeAt(2)>122||n.charCodeAt(2)<97),oc=n=>n.startsWith("onUpdate:"),ln=Object.assign,dd=(n,s)=>{const l=n.indexOf(s);l>-1&&n.splice(l,1)},h_=Object.prototype.hasOwnProperty,Tt=(n,s)=>h_.call(n,s),nt=Array.isArray,ps=n=>Sc(n)==="[object Map]",jg=n=>Sc(n)==="[object Set]",ot=n=>typeof n=="function",Yt=n=>typeof n=="string",ci=n=>typeof n=="symbol",Ft=n=>n!==null&&typeof n=="object",pd=n=>(Ft(n)||ot(n))&&ot(n.then)&&ot(n.catch),qg=Object.prototype.toString,Sc=n=>qg.call(n),fd=n=>Sc(n).slice(8,-1),Xg=n=>Sc(n)==="[object Object]",md=n=>Yt(n)&&n!=="NaN"&&n[0]!=="-"&&""+parseInt(n,10)===n,oa=li(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),d_=li("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"),Ec=n=>{const s=Object.create(null);return l=>s[l]||(s[l]=n(l))},p_=/-\w/g,Un=Ec(n=>n.replace(p_,s=>s.slice(1).toUpperCase())),f_=/\B([A-Z])/g,Di=Ec(n=>n.replace(f_,"-$1").toLowerCase()),ys=Ec(n=>n.charAt(0).toUpperCase()+n.slice(1)),ss=Ec(n=>n?`on${ys(n)}`:""),Oi=(n,s)=>!Object.is(n,s),Xo=(n,...s)=>{for(let l=0;l<n.length;l++)n[l](...s)},ac=(n,s,l,d=!1)=>{Object.defineProperty(n,s,{configurable:!0,enumerable:!1,writable:d,value:l})},m_=n=>{const s=parseFloat(n);return isNaN(s)?n:s};let km;const wa=()=>km||(km=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{});function gd(n){if(nt(n)){const s={};for(let l=0;l<n.length;l++){const d=n[l],f=Yt(d)?x_(d):gd(d);if(f)for(const v in f)s[v]=f[v]}return s}else if(Yt(n)||Ft(n))return n}const g_=/;(?![^(]*\))/g,v_=/:([^]+)/,y_=/\/\*[^]*?\*\//g;function x_(n){const s={};return n.replace(y_,"").split(g_).forEach(l=>{if(l){const d=l.split(v_);d.length>1&&(s[d[0].trim()]=d[1].trim())}}),s}function Tc(n){let s="";if(Yt(n))s=n;else if(nt(n))for(let l=0;l<n.length;l++){const d=Tc(n[l]);d&&(s+=d+" ")}else if(Ft(n))for(const l in n)n[l]&&(s+=l+" ");return s.trim()}const __="html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot",b_="svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view",w_="annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics",M_=li(__),S_=li(b_),E_=li(w_),T_="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",A_=li(T_);function Yg(n){return!!n||n===""}const Zg=n=>!!(n&&n.__v_isRef===!0),Kg=n=>Yt(n)?n:n==null?"":nt(n)||Ft(n)&&(n.toString===qg||!ot(n.toString))?Zg(n)?Kg(n.value):JSON.stringify(n,$g,2):String(n),$g=(n,s)=>Zg(s)?$g(n,s.value):ps(s)?{[`Map(${s.size})`]:[...s.entries()].reduce((l,[d,f],v)=>(l[_h(d,v)+" =>"]=f,l),{})}:jg(s)?{[`Set(${s.size})`]:[...s.values()].map(l=>_h(l))}:ci(s)?_h(s):Ft(s)&&!nt(s)&&!Xg(s)?String(s):s,_h=(n,s="")=>{var l;return ci(n)?`Symbol(${(l=n.description)!=null?l:s})`:n};/**
* @vue/reactivity v3.5.24
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/function wr(n,...s){console.warn(`[Vue warn] ${n}`,...s)}let Xn;class R_{constructor(s=!1){this.detached=s,this._active=!0,this._on=0,this.effects=[],this.cleanups=[],this._isPaused=!1,this.parent=Xn,!s&&Xn&&(this.index=(Xn.scopes||(Xn.scopes=[])).push(this)-1)}get active(){return this._active}pause(){if(this._active){this._isPaused=!0;let s,l;if(this.scopes)for(s=0,l=this.scopes.length;s<l;s++)this.scopes[s].pause();for(s=0,l=this.effects.length;s<l;s++)this.effects[s].pause()}}resume(){if(this._active&&this._isPaused){this._isPaused=!1;let s,l;if(this.scopes)for(s=0,l=this.scopes.length;s<l;s++)this.scopes[s].resume();for(s=0,l=this.effects.length;s<l;s++)this.effects[s].resume()}}run(s){if(this._active){const l=Xn;try{return Xn=this,s()}finally{Xn=l}}else wr("cannot run an inactive effect scope.")}on(){++this._on===1&&(this.prevScope=Xn,Xn=this)}off(){this._on>0&&--this._on===0&&(Xn=this.prevScope,this.prevScope=void 0)}stop(s){if(this._active){this._active=!1;let l,d;for(l=0,d=this.effects.length;l<d;l++)this.effects[l].stop();for(this.effects.length=0,l=0,d=this.cleanups.length;l<d;l++)this.cleanups[l]();if(this.cleanups.length=0,this.scopes){for(l=0,d=this.scopes.length;l<d;l++)this.scopes[l].stop(!0);this.scopes.length=0}if(!this.detached&&this.parent&&!s){const f=this.parent.scopes.pop();f&&f!==this&&(this.parent.scopes[this.index]=f,f.index=this.index)}this.parent=void 0}}}function L_(){return Xn}let Ht;const bh=new WeakSet;class Jg{constructor(s){this.fn=s,this.deps=void 0,this.depsTail=void 0,this.flags=5,this.next=void 0,this.cleanup=void 0,this.scheduler=void 0,Xn&&Xn.active&&Xn.effects.push(this)}pause(){this.flags|=64}resume(){this.flags&64&&(this.flags&=-65,bh.has(this)&&(bh.delete(this),this.trigger()))}notify(){this.flags&2&&!(this.flags&32)||this.flags&8||ev(this)}run(){if(!(this.flags&1))return this.fn();this.flags|=2,Hm(this),tv(this);const s=Ht,l=_r;Ht=this,_r=!0;try{return this.fn()}finally{Ht!==this&&wr("Active effect was not restored correctly - this is likely a Vue internal bug."),nv(this),Ht=s,_r=l,this.flags&=-3}}stop(){if(this.flags&1){for(let s=this.deps;s;s=s.nextDep)xd(s);this.deps=this.depsTail=void 0,Hm(this),this.onStop&&this.onStop(),this.flags&=-2}}trigger(){this.flags&64?bh.add(this):this.scheduler?this.scheduler():this.runIfDirty()}runIfDirty(){Bh(this)&&this.run()}get dirty(){return Bh(this)}}let Qg=0,aa,la;function ev(n,s=!1){if(n.flags|=8,s){n.next=la,la=n;return}n.next=aa,aa=n}function vd(){Qg++}function yd(){if(--Qg>0)return;if(la){let s=la;for(la=void 0;s;){const l=s.next;s.next=void 0,s.flags&=-9,s=l}}let n;for(;aa;){let s=aa;for(aa=void 0;s;){const l=s.next;if(s.next=void 0,s.flags&=-9,s.flags&1)try{s.trigger()}catch(d){n||(n=d)}s=l}}if(n)throw n}function tv(n){for(let s=n.deps;s;s=s.nextDep)s.version=-1,s.prevActiveLink=s.dep.activeLink,s.dep.activeLink=s}function nv(n){let s,l=n.depsTail,d=l;for(;d;){const f=d.prevDep;d.version===-1?(d===l&&(l=f),xd(d),C_(d)):s=d,d.dep.activeLink=d.prevActiveLink,d.prevActiveLink=void 0,d=f}n.deps=s,n.depsTail=l}function Bh(n){for(let s=n.deps;s;s=s.nextDep)if(s.dep.version!==s.version||s.dep.computed&&(rv(s.dep.computed)||s.dep.version!==s.version))return!0;return!!n._dirty}function rv(n){if(n.flags&4&&!(n.flags&16)||(n.flags&=-17,n.globalVersion===fa)||(n.globalVersion=fa,!n.isSSR&&n.flags&128&&(!n.deps&&!n._dirty||!Bh(n))))return;n.flags|=2;const s=n.dep,l=Ht,d=_r;Ht=n,_r=!0;try{tv(n);const f=n.fn(n._value);(s.version===0||Oi(f,n._value))&&(n.flags|=128,n._value=f,s.version++)}catch(f){throw s.version++,f}finally{Ht=l,_r=d,nv(n),n.flags&=-3}}function xd(n,s=!1){const{dep:l,prevSub:d,nextSub:f}=n;if(d&&(d.nextSub=f,n.prevSub=void 0),f&&(f.prevSub=d,n.nextSub=void 0),l.subsHead===n&&(l.subsHead=f),l.subs===n&&(l.subs=d,!d&&l.computed)){l.computed.flags&=-5;for(let v=l.computed.deps;v;v=v.nextDep)xd(v,!0)}!s&&!--l.sc&&l.map&&l.map.delete(l.key)}function C_(n){const{prevDep:s,nextDep:l}=n;s&&(s.nextDep=l,n.prevDep=void 0),l&&(l.prevDep=s,n.nextDep=void 0)}let _r=!0;const iv=[];function Mr(){iv.push(_r),_r=!1}function Sr(){const n=iv.pop();_r=n===void 0?!0:n}function Hm(n){const{cleanup:s}=n;if(n.cleanup=void 0,s){const l=Ht;Ht=void 0;try{s()}finally{Ht=l}}}let fa=0;class P_{constructor(s,l){this.sub=s,this.dep=l,this.version=l.version,this.nextDep=this.prevDep=this.nextSub=this.prevSub=this.prevActiveLink=void 0}}class _d{constructor(s){this.computed=s,this.version=0,this.activeLink=void 0,this.subs=void 0,this.map=void 0,this.key=void 0,this.sc=0,this.__v_skip=!0,this.subsHead=void 0}track(s){if(!Ht||!_r||Ht===this.computed)return;let l=this.activeLink;if(l===void 0||l.sub!==Ht)l=this.activeLink=new P_(Ht,this),Ht.deps?(l.prevDep=Ht.depsTail,Ht.depsTail.nextDep=l,Ht.depsTail=l):Ht.deps=Ht.depsTail=l,sv(l);else if(l.version===-1&&(l.version=this.version,l.nextDep)){const d=l.nextDep;d.prevDep=l.prevDep,l.prevDep&&(l.prevDep.nextDep=d),l.prevDep=Ht.depsTail,l.nextDep=void 0,Ht.depsTail.nextDep=l,Ht.depsTail=l,Ht.deps===l&&(Ht.deps=d)}return Ht.onTrack&&Ht.onTrack(ln({effect:Ht},s)),l}trigger(s){this.version++,fa++,this.notify(s)}notify(s){vd();try{for(let l=this.subsHead;l;l=l.nextSub)l.sub.onTrigger&&!(l.sub.flags&8)&&l.sub.onTrigger(ln({effect:l.sub},s));for(let l=this.subs;l;l=l.prevSub)l.sub.notify()&&l.sub.dep.notify()}finally{yd()}}}function sv(n){if(n.dep.sc++,n.sub.flags&4){const s=n.dep.computed;if(s&&!n.dep.subs){s.flags|=20;for(let d=s.deps;d;d=d.nextDep)sv(d)}const l=n.dep.subs;l!==n&&(n.prevSub=l,l&&(l.nextSub=n)),n.dep.subsHead===void 0&&(n.dep.subsHead=n),n.dep.subs=n}}const zh=new WeakMap,fs=Symbol("Object iterate"),Uh=Symbol("Map keys iterate"),ma=Symbol("Array iterate");function yn(n,s,l){if(_r&&Ht){let d=zh.get(n);d||zh.set(n,d=new Map);let f=d.get(l);f||(d.set(l,f=new _d),f.map=d,f.key=l),f.track({target:n,type:s,key:l})}}function Hr(n,s,l,d,f,v){const _=zh.get(n);if(!_){fa++;return}const w=R=>{R&&R.trigger({target:n,type:s,key:l,newValue:d,oldValue:f,oldTarget:v})};if(vd(),s==="clear")_.forEach(w);else{const R=nt(n),L=R&&md(l);if(R&&l==="length"){const T=Number(d);_.forEach((E,P)=>{(P==="length"||P===ma||!ci(P)&&P>=T)&&w(E)})}else switch((l!==void 0||_.has(void 0))&&w(_.get(l)),L&&w(_.get(ma)),s){case"add":R?L&&w(_.get("length")):(w(_.get(fs)),ps(n)&&w(_.get(Uh)));break;case"delete":R||(w(_.get(fs)),ps(n)&&w(_.get(Uh)));break;case"set":ps(n)&&w(_.get(fs));break}}yd()}function qs(n){const s=gt(n);return s===n?s:(yn(s,"iterate",ma),Gn(n)?s:s.map(Sn))}function Ac(n){return yn(n=gt(n),"iterate",ma),n}const I_={__proto__:null,[Symbol.iterator](){return wh(this,Symbol.iterator,Sn)},concat(...n){return qs(this).concat(...n.map(s=>nt(s)?qs(s):s))},entries(){return wh(this,"entries",n=>(n[1]=Sn(n[1]),n))},every(n,s){return ni(this,"every",n,s,void 0,arguments)},filter(n,s){return ni(this,"filter",n,s,l=>l.map(Sn),arguments)},find(n,s){return ni(this,"find",n,s,Sn,arguments)},findIndex(n,s){return ni(this,"findIndex",n,s,void 0,arguments)},findLast(n,s){return ni(this,"findLast",n,s,Sn,arguments)},findLastIndex(n,s){return ni(this,"findLastIndex",n,s,void 0,arguments)},forEach(n,s){return ni(this,"forEach",n,s,void 0,arguments)},includes(...n){return Mh(this,"includes",n)},indexOf(...n){return Mh(this,"indexOf",n)},join(n){return qs(this).join(n)},lastIndexOf(...n){return Mh(this,"lastIndexOf",n)},map(n,s){return ni(this,"map",n,s,void 0,arguments)},pop(){return Yo(this,"pop")},push(...n){return Yo(this,"push",n)},reduce(n,...s){return Fm(this,"reduce",n,s)},reduceRight(n,...s){return Fm(this,"reduceRight",n,s)},shift(){return Yo(this,"shift")},some(n,s){return ni(this,"some",n,s,void 0,arguments)},splice(...n){return Yo(this,"splice",n)},toReversed(){return qs(this).toReversed()},toSorted(n){return qs(this).toSorted(n)},toSpliced(...n){return qs(this).toSpliced(...n)},unshift(...n){return Yo(this,"unshift",n)},values(){return wh(this,"values",Sn)}};function wh(n,s,l){const d=Ac(n),f=d[s]();return d!==n&&!Gn(n)&&(f._next=f.next,f.next=()=>{const v=f._next();return v.done||(v.value=l(v.value)),v}),f}const O_=Array.prototype;function ni(n,s,l,d,f,v){const _=Ac(n),w=_!==n&&!Gn(n),R=_[s];if(R!==O_[s]){const E=R.apply(n,v);return w?Sn(E):E}let L=l;_!==n&&(w?L=function(E,P){return l.call(this,Sn(E),P,n)}:l.length>2&&(L=function(E,P){return l.call(this,E,P,n)}));const T=R.call(_,L,d);return w&&f?f(T):T}function Fm(n,s,l,d){const f=Ac(n);let v=l;return f!==n&&(Gn(n)?l.length>3&&(v=function(_,w,R){return l.call(this,_,w,R,n)}):v=function(_,w,R){return l.call(this,_,Sn(w),R,n)}),f[s](v,...d)}function Mh(n,s,l){const d=gt(n);yn(d,"iterate",ma);const f=d[s](...l);return(f===-1||f===!1)&&lc(l[0])?(l[0]=gt(l[0]),d[s](...l)):f}function Yo(n,s,l=[]){Mr(),vd();const d=gt(n)[s].apply(n,l);return yd(),Sr(),d}const D_=li("__proto__,__v_isRef,__isVue"),ov=new Set(Object.getOwnPropertyNames(Symbol).filter(n=>n!=="arguments"&&n!=="caller").map(n=>Symbol[n]).filter(ci));function N_(n){ci(n)||(n=String(n));const s=gt(this);return yn(s,"has",n),s.hasOwnProperty(n)}class av{constructor(s=!1,l=!1){this._isReadonly=s,this._isShallow=l}get(s,l,d){if(l==="__v_skip")return s.__v_skip;const f=this._isReadonly,v=this._isShallow;if(l==="__v_isReactive")return!f;if(l==="__v_isReadonly")return f;if(l==="__v_isShallow")return v;if(l==="__v_raw")return d===(f?v?pv:dv:v?hv:uv).get(s)||Object.getPrototypeOf(s)===Object.getPrototypeOf(d)?s:void 0;const _=nt(s);if(!f){let R;if(_&&(R=I_[l]))return R;if(l==="hasOwnProperty")return N_}const w=Reflect.get(s,l,an(s)?s:d);if((ci(l)?ov.has(l):D_(l))||(f||yn(s,"get",l),v))return w;if(an(w)){const R=_&&md(l)?w:w.value;return f&&Ft(R)?Vh(R):R}return Ft(w)?f?Vh(w):Lc(w):w}}class lv extends av{constructor(s=!1){super(!1,s)}set(s,l,d,f){let v=s[l];if(!this._isShallow){const R=Ur(v);if(!Gn(d)&&!Ur(d)&&(v=gt(v),d=gt(d)),!nt(s)&&an(v)&&!an(d))return R?(wr(`Set operation on key "${String(l)}" failed: target is readonly.`,s[l]),!0):(v.value=d,!0)}const _=nt(s)&&md(l)?Number(l)<s.length:Tt(s,l),w=Reflect.set(s,l,d,an(s)?s:f);return s===gt(f)&&(_?Oi(d,v)&&Hr(s,"set",l,d,v):Hr(s,"add",l,d)),w}deleteProperty(s,l){const d=Tt(s,l),f=s[l],v=Reflect.deleteProperty(s,l);return v&&d&&Hr(s,"delete",l,void 0,f),v}has(s,l){const d=Reflect.has(s,l);return(!ci(l)||!ov.has(l))&&yn(s,"has",l),d}ownKeys(s){return yn(s,"iterate",nt(s)?"length":fs),Reflect.ownKeys(s)}}class cv extends av{constructor(s=!1){super(!0,s)}set(s,l){return wr(`Set operation on key "${String(l)}" failed: target is readonly.`,s),!0}deleteProperty(s,l){return wr(`Delete operation on key "${String(l)}" failed: target is readonly.`,s),!0}}const k_=new lv,H_=new cv,F_=new lv(!0),B_=new cv(!0),Gh=n=>n,Xl=n=>Reflect.getPrototypeOf(n);function z_(n,s,l){return function(...d){const f=this.__v_raw,v=gt(f),_=ps(v),w=n==="entries"||n===Symbol.iterator&&_,R=n==="keys"&&_,L=f[n](...d),T=l?Gh:s?cc:Sn;return!s&&yn(v,"iterate",R?Uh:fs),{next(){const{value:E,done:P}=L.next();return P?{value:E,done:P}:{value:w?[T(E[0]),T(E[1])]:T(E),done:P}},[Symbol.iterator](){return this}}}}function Yl(n){return function(...s){{const l=s[0]?`on key "${s[0]}" `:"";wr(`${ys(n)} operation ${l}failed: target is readonly.`,gt(this))}return n==="delete"?!1:n==="clear"?void 0:this}}function U_(n,s){const l={get(f){const v=this.__v_raw,_=gt(v),w=gt(f);n||(Oi(f,w)&&yn(_,"get",f),yn(_,"get",w));const{has:R}=Xl(_),L=s?Gh:n?cc:Sn;if(R.call(_,f))return L(v.get(f));if(R.call(_,w))return L(v.get(w));v!==_&&v.get(f)},get size(){const f=this.__v_raw;return!n&&yn(gt(f),"iterate",fs),f.size},has(f){const v=this.__v_raw,_=gt(v),w=gt(f);return n||(Oi(f,w)&&yn(_,"has",f),yn(_,"has",w)),f===w?v.has(f):v.has(f)||v.has(w)},forEach(f,v){const _=this,w=_.__v_raw,R=gt(w),L=s?Gh:n?cc:Sn;return!n&&yn(R,"iterate",fs),w.forEach((T,E)=>f.call(v,L(T),L(E),_))}};return ln(l,n?{add:Yl("add"),set:Yl("set"),delete:Yl("delete"),clear:Yl("clear")}:{add(f){!s&&!Gn(f)&&!Ur(f)&&(f=gt(f));const v=gt(this);return Xl(v).has.call(v,f)||(v.add(f),Hr(v,"add",f,f)),this},set(f,v){!s&&!Gn(v)&&!Ur(v)&&(v=gt(v));const _=gt(this),{has:w,get:R}=Xl(_);let L=w.call(_,f);L?Bm(_,w,f):(f=gt(f),L=w.call(_,f));const T=R.call(_,f);return _.set(f,v),L?Oi(v,T)&&Hr(_,"set",f,v,T):Hr(_,"add",f,v),this},delete(f){const v=gt(this),{has:_,get:w}=Xl(v);let R=_.call(v,f);R?Bm(v,_,f):(f=gt(f),R=_.call(v,f));const L=w?w.call(v,f):void 0,T=v.delete(f);return R&&Hr(v,"delete",f,void 0,L),T},clear(){const f=gt(this),v=f.size!==0,_=ps(f)?new Map(f):new Set(f),w=f.clear();return v&&Hr(f,"clear",void 0,void 0,_),w}}),["keys","values","entries",Symbol.iterator].forEach(f=>{l[f]=z_(f,n,s)}),l}function Rc(n,s){const l=U_(n,s);return(d,f,v)=>f==="__v_isReactive"?!n:f==="__v_isReadonly"?n:f==="__v_raw"?d:Reflect.get(Tt(l,f)&&f in d?l:d,f,v)}const G_={get:Rc(!1,!1)},V_={get:Rc(!1,!0)},W_={get:Rc(!0,!1)},j_={get:Rc(!0,!0)};function Bm(n,s,l){const d=gt(l);if(d!==l&&s.call(n,d)){const f=fd(n);wr(`Reactive ${f} contains both the raw and reactive versions of the same object${f==="Map"?" as keys":""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`)}}const uv=new WeakMap,hv=new WeakMap,dv=new WeakMap,pv=new WeakMap;function q_(n){switch(n){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function X_(n){return n.__v_skip||!Object.isExtensible(n)?0:q_(fd(n))}function Lc(n){return Ur(n)?n:Cc(n,!1,k_,G_,uv)}function fv(n){return Cc(n,!1,F_,V_,hv)}function Vh(n){return Cc(n,!0,H_,W_,dv)}function Br(n){return Cc(n,!0,B_,j_,pv)}function Cc(n,s,l,d,f){if(!Ft(n))return wr(`value cannot be made ${s?"readonly":"reactive"}: ${String(n)}`),n;if(n.__v_raw&&!(s&&n.__v_isReactive))return n;const v=X_(n);if(v===0)return n;const _=f.get(n);if(_)return _;const w=new Proxy(n,v===2?d:l);return f.set(n,w),w}function ms(n){return Ur(n)?ms(n.__v_raw):!!(n&&n.__v_isReactive)}function Ur(n){return!!(n&&n.__v_isReadonly)}function Gn(n){return!!(n&&n.__v_isShallow)}function lc(n){return n?!!n.__v_raw:!1}function gt(n){const s=n&&n.__v_raw;return s?gt(s):n}function Y_(n){return!Tt(n,"__v_skip")&&Object.isExtensible(n)&&ac(n,"__v_skip",!0),n}const Sn=n=>Ft(n)?Lc(n):n,cc=n=>Ft(n)?Vh(n):n;function an(n){return n?n.__v_isRef===!0:!1}function ir(n){return mv(n,!1)}function Z_(n){return mv(n,!0)}function mv(n,s){return an(n)?n:new K_(n,s)}class K_{constructor(s,l){this.dep=new _d,this.__v_isRef=!0,this.__v_isShallow=!1,this._rawValue=l?s:gt(s),this._value=l?s:Sn(s),this.__v_isShallow=l}get value(){return this.dep.track({target:this,type:"get",key:"value"}),this._value}set value(s){const l=this._rawValue,d=this.__v_isShallow||Gn(s)||Ur(s);s=d?s:gt(s),Oi(s,l)&&(this._rawValue=s,this._value=d?s:Sn(s),this.dep.trigger({target:this,type:"set",key:"value",newValue:s,oldValue:l}))}}function us(n){return an(n)?n.value:n}const $_={get:(n,s,l)=>s==="__v_raw"?n:us(Reflect.get(n,s,l)),set:(n,s,l,d)=>{const f=n[s];return an(f)&&!an(l)?(f.value=l,!0):Reflect.set(n,s,l,d)}};function gv(n){return ms(n)?n:new Proxy(n,$_)}class J_{constructor(s,l,d){this.fn=s,this.setter=l,this._value=void 0,this.dep=new _d(this),this.__v_isRef=!0,this.deps=void 0,this.depsTail=void 0,this.flags=16,this.globalVersion=fa-1,this.next=void 0,this.effect=this,this.__v_isReadonly=!l,this.isSSR=d}notify(){if(this.flags|=16,!(this.flags&8)&&Ht!==this)return ev(this,!0),!0}get value(){const s=this.dep.track({target:this,type:"get",key:"value"});return rv(this),s&&(s.version=this.dep.version),this._value}set value(s){this.setter?this.setter(s):wr("Write operation failed: computed value is readonly")}}function Q_(n,s,l=!1){let d,f;return ot(n)?d=n:(d=n.get,f=n.set),new J_(d,f,l)}const Zl={},uc=new WeakMap;let os;function eb(n,s=!1,l=os){if(l){let d=uc.get(l);d||uc.set(l,d=[]),d.push(n)}else s||wr("onWatcherCleanup() was called when there was no active watcher to associate with.")}function tb(n,s,l=Bt){const{immediate:d,deep:f,once:v,scheduler:_,augmentJob:w,call:R}=l,L=Te=>{(l.onWarn||wr)("Invalid watch source: ",Te,"A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.")},T=Te=>f?Te:Gn(Te)||f===!1||f===0?Ii(Te,1):Ii(Te);let E,P,C,z,j=!1,ne=!1;if(an(n)?(P=()=>n.value,j=Gn(n)):ms(n)?(P=()=>T(n),j=!0):nt(n)?(ne=!0,j=n.some(Te=>ms(Te)||Gn(Te)),P=()=>n.map(Te=>{if(an(Te))return Te.value;if(ms(Te))return T(Te);if(ot(Te))return R?R(Te,2):Te();L(Te)})):ot(n)?s?P=R?()=>R(n,2):n:P=()=>{if(C){Mr();try{C()}finally{Sr()}}const Te=os;os=E;try{return R?R(n,3,[z]):n(z)}finally{os=Te}}:(P=Ln,L(n)),s&&f){const Te=P,Ke=f===!0?1/0:f;P=()=>Ii(Te(),Ke)}const pe=L_(),ie=()=>{E.stop(),pe&&pe.active&&dd(pe.effects,E)};if(v&&s){const Te=s;s=(...Ke)=>{Te(...Ke),ie()}}let ae=ne?new Array(n.length).fill(Zl):Zl;const xe=Te=>{if(!(!(E.flags&1)||!E.dirty&&!Te))if(s){const Ke=E.run();if(f||j||(ne?Ke.some((at,lt)=>Oi(at,ae[lt])):Oi(Ke,ae))){C&&C();const at=os;os=E;try{const lt=[Ke,ae===Zl?void 0:ne&&ae[0]===Zl?[]:ae,z];ae=Ke,R?R(s,3,lt):s(...lt)}finally{os=at}}}else E.run()};return w&&w(xe),E=new Jg(P),E.scheduler=_?()=>_(xe,!1):xe,z=Te=>eb(Te,!1,E),C=E.onStop=()=>{const Te=uc.get(E);if(Te){if(R)R(Te,4);else for(const Ke of Te)Ke();uc.delete(E)}},E.onTrack=l.onTrack,E.onTrigger=l.onTrigger,s?d?xe(!0):ae=E.run():_?_(xe.bind(null,!0),!0):E.run(),ie.pause=E.pause.bind(E),ie.resume=E.resume.bind(E),ie.stop=ie,ie}function Ii(n,s=1/0,l){if(s<=0||!Ft(n)||n.__v_skip||(l=l||new Map,(l.get(n)||0)>=s))return n;if(l.set(n,s),s--,an(n))Ii(n.value,s,l);else if(nt(n))for(let d=0;d<n.length;d++)Ii(n[d],s,l);else if(jg(n)||ps(n))n.forEach(d=>{Ii(d,s,l)});else if(Xg(n)){for(const d in n)Ii(n[d],s,l);for(const d of Object.getOwnPropertySymbols(n))Object.prototype.propertyIsEnumerable.call(n,d)&&Ii(n[d],s,l)}return n}/**
* @vue/runtime-core v3.5.24
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/const gs=[];function Ql(n){gs.push(n)}function ec(){gs.pop()}let Sh=!1;function Re(n,...s){if(Sh)return;Sh=!0,Mr();const l=gs.length?gs[gs.length-1].component:null,d=l&&l.appContext.config.warnHandler,f=nb();if(d)ao(d,l,11,[n+s.map(v=>{var _,w;return(w=(_=v.toString)==null?void 0:_.call(v))!=null?w:JSON.stringify(v)}).join(""),l&&l.proxy,f.map(({vnode:v})=>`at <${Nc(l,v.type)}>`).join(`
`),f]);else{const v=[`[Vue warn]: ${n}`,...s];f.length&&v.push(`
`,...rb(f)),console.warn(...v)}Sr(),Sh=!1}function nb(){let n=gs[gs.length-1];if(!n)return[];const s=[];for(;n;){const l=s[0];l&&l.vnode===n?l.recurseCount++:s.push({vnode:n,recurseCount:0});const d=n.component&&n.component.parent;n=d&&d.vnode}return s}function rb(n){const s=[];return n.forEach((l,d)=>{s.push(...d===0?[]:[`
`],...ib(l))}),s}function ib({vnode:n,recurseCount:s}){const l=s>0?`... (${s} recursive calls)`:"",d=n.component?n.component.parent==null:!1,f=` at <${Nc(n.component,n.type,d)}`,v=">"+l;return n.props?[f,...sb(n.props),v]:[f+v]}function sb(n){const s=[],l=Object.keys(n);return l.slice(0,3).forEach(d=>{s.push(...vv(d,n[d]))}),l.length>3&&s.push(" ..."),s}function vv(n,s,l){return Yt(s)?(s=JSON.stringify(s),l?s:[`${n}=${s}`]):typeof s=="number"||typeof s=="boolean"||s==null?l?s:[`${n}=${s}`]:an(s)?(s=vv(n,gt(s.value),!0),l?s:[`${n}=Ref<`,s,">"]):ot(s)?[`${n}=fn${s.name?`<${s.name}>`:""}`]:(s=gt(s),l?s:[`${n}=`,s])}const bd={sp:"serverPrefetch hook",bc:"beforeCreate hook",c:"created hook",bm:"beforeMount hook",m:"mounted hook",bu:"beforeUpdate hook",u:"updated",bum:"beforeUnmount hook",um:"unmounted hook",a:"activated hook",da:"deactivated hook",ec:"errorCaptured hook",rtc:"renderTracked hook",rtg:"renderTriggered hook",0:"setup function",1:"render function",2:"watcher getter",3:"watcher callback",4:"watcher cleanup function",5:"native event handler",6:"component event handler",7:"vnode hook",8:"directive hook",9:"transition hook",10:"app errorHandler",11:"app warnHandler",12:"ref function",13:"async component loader",14:"scheduler flush",15:"component update",16:"app unmount cleanup function"};function ao(n,s,l,d){try{return d?n(...d):n()}catch(f){Ma(f,s,l)}}function Gr(n,s,l,d){if(ot(n)){const f=ao(n,s,l,d);return f&&pd(f)&&f.catch(v=>{Ma(v,s,l)}),f}if(nt(n)){const f=[];for(let v=0;v<n.length;v++)f.push(Gr(n[v],s,l,d));return f}else Re(`Invalid value type passed to callWithAsyncErrorHandling(): ${typeof n}`)}function Ma(n,s,l,d=!0){const f=s?s.vnode:null,{errorHandler:v,throwUnhandledErrorInProduction:_}=s&&s.appContext.config||Bt;if(s){let w=s.parent;const R=s.proxy,L=bd[l];for(;w;){const T=w.ec;if(T){for(let E=0;E<T.length;E++)if(T[E](n,R,L)===!1)return}w=w.parent}if(v){Mr(),ao(v,null,10,[n,R,L]),Sr();return}}ob(n,l,f,d,_)}function ob(n,s,l,d=!0,f=!1){{const v=bd[s];if(l&&Ql(l),Re(`Unhandled error${v?` during execution of ${v}`:""}`),l&&ec(),d)throw n;console.error(n)}}const zn=[];let Nr=-1;const no=[];let Li=null,Ks=0;const yv=Promise.resolve();let hc=null;const ab=100;function xv(n){const s=hc||yv;return n?s.then(this?n.bind(this):n):s}function lb(n){let s=Nr+1,l=zn.length;for(;s<l;){const d=s+l>>>1,f=zn[d],v=ga(f);v<n||v===n&&f.flags&2?s=d+1:l=d}return s}function Pc(n){if(!(n.flags&1)){const s=ga(n),l=zn[zn.length-1];!l||!(n.flags&2)&&s>=ga(l)?zn.push(n):zn.splice(lb(s),0,n),n.flags|=1,_v()}}function _v(){hc||(hc=yv.then(Mv))}function bv(n){nt(n)?no.push(...n):Li&&n.id===-1?Li.splice(Ks+1,0,n):n.flags&1||(no.push(n),n.flags|=1),_v()}function zm(n,s,l=Nr+1){for(s=s||new Map;l<zn.length;l++){const d=zn[l];if(d&&d.flags&2){if(n&&d.id!==n.uid||wd(s,d))continue;zn.splice(l,1),l--,d.flags&4&&(d.flags&=-2),d(),d.flags&4||(d.flags&=-2)}}}function wv(n){if(no.length){const s=[...new Set(no)].sort((l,d)=>ga(l)-ga(d));if(no.length=0,Li){Li.push(...s);return}for(Li=s,n=n||new Map,Ks=0;Ks<Li.length;Ks++){const l=Li[Ks];wd(n,l)||(l.flags&4&&(l.flags&=-2),l.flags&8||l(),l.flags&=-2)}Li=null,Ks=0}}const ga=n=>n.id==null?n.flags&2?-1:1/0:n.id;function Mv(n){n=n||new Map;const s=l=>wd(n,l);try{for(Nr=0;Nr<zn.length;Nr++){const l=zn[Nr];if(l&&!(l.flags&8)){if(s(l))continue;l.flags&4&&(l.flags&=-2),ao(l,l.i,l.i?15:14),l.flags&4||(l.flags&=-2)}}}finally{for(;Nr<zn.length;Nr++){const l=zn[Nr];l&&(l.flags&=-2)}Nr=-1,zn.length=0,wv(n),hc=null,(zn.length||no.length)&&Mv(n)}}function wd(n,s){const l=n.get(s)||0;if(l>ab){const d=s.i,f=d&&Od(d.type);return Ma(`Maximum recursive updates exceeded${f?` in component <${f}>`:""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,null,10),!0}return n.set(s,l+1),!1}let zr=!1;const tc=new Map;wa().__VUE_HMR_RUNTIME__={createRecord:Eh(Sv),rerender:Eh(hb),reload:Eh(db)};const xs=new Map;function cb(n){const s=n.type.__hmrId;let l=xs.get(s);l||(Sv(s,n.type),l=xs.get(s)),l.instances.add(n)}function ub(n){xs.get(n.type.__hmrId).instances.delete(n)}function Sv(n,s){return xs.has(n)?!1:(xs.set(n,{initialDef:dc(s),instances:new Set}),!0)}function dc(n){return sy(n)?n.__vccOpts:n}function hb(n,s){const l=xs.get(n);l&&(l.initialDef.render=s,[...l.instances].forEach(d=>{s&&(d.render=s,dc(d.type).render=s),d.renderCache=[],zr=!0,d.job.flags&8||d.update(),zr=!1}))}function db(n,s){const l=xs.get(n);if(!l)return;s=dc(s),Um(l.initialDef,s);const d=[...l.instances];for(let f=0;f<d.length;f++){const v=d[f],_=dc(v.type);let w=tc.get(_);w||(_!==l.initialDef&&Um(_,s),tc.set(_,w=new Set)),w.add(v),v.appContext.propsCache.delete(v.type),v.appContext.emitsCache.delete(v.type),v.appContext.optionsCache.delete(v.type),v.ceReload?(w.add(v),v.ceReload(s.styles),w.delete(v)):v.parent?Pc(()=>{v.job.flags&8||(zr=!0,v.parent.update(),zr=!1,w.delete(v))}):v.appContext.reload?v.appContext.reload():typeof window<"u"?window.location.reload():console.warn("[HMR] Root or manually mounted instance modified. Full reload required."),v.root.ce&&v!==v.root&&v.root.ce._removeChildStyle(_)}bv(()=>{tc.clear()})}function Um(n,s){ln(n,s);for(const l in n)l!=="__file"&&!(l in s)&&delete n[l]}function Eh(n){return(s,l)=>{try{return n(s,l)}catch(d){console.error(d),console.warn("[HMR] Something went wrong during Vue component hot-reload. Full reload required.")}}}let Fr,ta=[],Wh=!1;function Sa(n,...s){Fr?Fr.emit(n,...s):Wh||ta.push({event:n,args:s})}function Ev(n,s){var l,d;Fr=n,Fr?(Fr.enabled=!0,ta.forEach(({event:f,args:v})=>Fr.emit(f,...v)),ta=[]):typeof window<"u"&&window.HTMLElement&&!((d=(l=window.navigator)==null?void 0:l.userAgent)!=null&&d.includes("jsdom"))?((s.__VUE_DEVTOOLS_HOOK_REPLAY__=s.__VUE_DEVTOOLS_HOOK_REPLAY__||[]).push(v=>{Ev(v,s)}),setTimeout(()=>{Fr||(s.__VUE_DEVTOOLS_HOOK_REPLAY__=null,Wh=!0,ta=[])},3e3)):(Wh=!0,ta=[])}function pb(n,s){Sa("app:init",n,s,{Fragment:rr,Text:Ea,Comment:Yn,Static:ha})}function fb(n){Sa("app:unmount",n)}const mb=Md("component:added"),Tv=Md("component:updated"),gb=Md("component:removed"),vb=n=>{Fr&&typeof Fr.cleanupBuffer=="function"&&!Fr.cleanupBuffer(n)&&gb(n)};function Md(n){return s=>{Sa(n,s.appContext.app,s.uid,s.parent?s.parent.uid:void 0,s)}}const yb=Av("perf:start"),xb=Av("perf:end");function Av(n){return(s,l,d)=>{Sa(n,s.appContext.app,s.uid,s,l,d)}}function _b(n,s,l){Sa("component:emit",n.appContext.app,n,s,l)}let _n=null,Rv=null;function pc(n){const s=_n;return _n=n,Rv=n&&n.type.__scopeId||null,s}function bb(n,s=_n,l){if(!s||n._n)return n;const d=(...f)=>{d._d&&yc(-1);const v=pc(s);let _;try{_=n(...f)}finally{pc(v),d._d&&yc(1)}return Tv(s),_};return d._n=!0,d._c=!0,d._d=!0,d}function Lv(n){d_(n)&&Re("Do not use built-in directive ids as custom directive id: "+n)}function ns(n,s,l,d){const f=n.dirs,v=s&&s.dirs;for(let _=0;_<f.length;_++){const w=f[_];v&&(w.oldValue=v[_].value);let R=w.dir[d];R&&(Mr(),Gr(R,l,8,[n.el,w,n,s]),Sr())}}const wb=Symbol("_vte"),Mb=n=>n.__isTeleport,Sb=Symbol("_leaveCb");function Sd(n,s){n.shapeFlag&6&&n.component?(n.transition=s,Sd(n.component.subTree,s)):n.shapeFlag&128?(n.ssContent.transition=s.clone(n.ssContent),n.ssFallback.transition=s.clone(n.ssFallback)):n.transition=s}function Cv(n,s){return ot(n)?ln({name:n.name},s,{setup:n}):n}function Pv(n){n.ids=[n.ids[0]+n.ids[2]+++"-",0,0]}const Gm=new WeakSet,fc=new WeakMap;function ca(n,s,l,d,f=!1){if(nt(n)){n.forEach((j,ne)=>ca(j,s&&(nt(s)?s[ne]:s),l,d,f));return}if(ro(d)&&!f){d.shapeFlag&512&&d.type.__asyncResolved&&d.component.subTree.component&&ca(n,s,l,d.component.subTree);return}const v=d.shapeFlag&4?Id(d.component):d.el,_=f?null:v,{i:w,r:R}=n;if(!w){Re("Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.");return}const L=s&&s.r,T=w.refs===Bt?w.refs={}:w.refs,E=w.setupState,P=gt(E),C=E===Bt?Wg:j=>(Tt(P,j)&&!an(P[j])&&Re(`Template ref "${j}" used on a non-ref value. It will not work in the production build.`),Gm.has(P[j])?!1:Tt(P,j)),z=j=>!Gm.has(j);if(L!=null&&L!==R){if(Vm(s),Yt(L))T[L]=null,C(L)&&(E[L]=null);else if(an(L)){z(L)&&(L.value=null);const j=s;j.k&&(T[j.k]=null)}}if(ot(R))ao(R,w,12,[_,T]);else{const j=Yt(R),ne=an(R);if(j||ne){const pe=()=>{if(n.f){const ie=j?C(R)?E[R]:T[R]:z(R)||!n.k?R.value:T[n.k];if(f)nt(ie)&&dd(ie,v);else if(nt(ie))ie.includes(v)||ie.push(v);else if(j)T[R]=[v],C(R)&&(E[R]=T[R]);else{const ae=[v];z(R)&&(R.value=ae),n.k&&(T[n.k]=ae)}}else j?(T[R]=_,C(R)&&(E[R]=_)):ne?(z(R)&&(R.value=_),n.k&&(T[n.k]=_)):Re("Invalid template ref type:",R,`(${typeof R})`)};if(_){const ie=()=>{pe(),fc.delete(n)};ie.id=-1,fc.set(n,ie),nr(ie,l)}else Vm(n),pe()}else Re("Invalid template ref type:",R,`(${typeof R})`)}}function Vm(n){const s=fc.get(n);s&&(s.flags|=8,fc.delete(n))}wa().requestIdleCallback;wa().cancelIdleCallback;const ro=n=>!!n.type.__asyncLoader,Ed=n=>n.type.__isKeepAlive;function Eb(n,s){Iv(n,"a",s)}function Tb(n,s){Iv(n,"da",s)}function Iv(n,s,l=xn){const d=n.__wdc||(n.__wdc=()=>{let f=l;for(;f;){if(f.isDeactivated)return;f=f.parent}return n()});if(Ic(s,d,l),l){let f=l.parent;for(;f&&f.parent;)Ed(f.parent.vnode)&&Ab(d,s,l,f),f=f.parent}}function Ab(n,s,l,d){const f=Ic(s,n,d,!0);Dv(()=>{dd(d[s],f)},l)}function Ic(n,s,l=xn,d=!1){if(l){const f=l[n]||(l[n]=[]),v=s.__weh||(s.__weh=(..._)=>{Mr();const w=Ta(l),R=Gr(s,l,n,_);return w(),Sr(),R});return d?f.unshift(v):f.push(v),v}else{const f=ss(bd[n].replace(/ hook$/,""));Re(`${f} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`)}}const ui=n=>(s,l=xn)=>{(!xa||n==="sp")&&Ic(n,(...d)=>s(...d),l)},Rb=ui("bm"),Ov=ui("m"),Lb=ui("bu"),Cb=ui("u"),Pb=ui("bum"),Dv=ui("um"),Ib=ui("sp"),Ob=ui("rtg"),Db=ui("rtc");function Nb(n,s=xn){Ic("ec",n,s)}const kb="components";function Hb(n,s){return Bb(kb,n,!0,s)||n}const Fb=Symbol.for("v-ndc");function Bb(n,s,l=!0,d=!1){const f=_n||xn;if(f){const v=f.type;{const w=Od(v,!1);if(w&&(w===s||w===Un(s)||w===ys(Un(s))))return v}const _=Wm(f[n]||v[n],s)||Wm(f.appContext[n],s);return!_&&d?v:(l&&!_&&Re(`Failed to resolve ${n.slice(0,-1)}: ${s}
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.`),_)}else Re(`resolve${ys(n.slice(0,-1))} can only be used in render() or setup().`)}function Wm(n,s){return n&&(n[s]||n[Un(s)]||n[ys(Un(s))])}function QS(n,s,l,d){let f;const v=l,_=nt(n);if(_||Yt(n)){const w=_&&ms(n);let R=!1,L=!1;w&&(R=!Gn(n),L=Ur(n),n=Ac(n)),f=new Array(n.length);for(let T=0,E=n.length;T<E;T++)f[T]=s(R?L?cc(Sn(n[T])):Sn(n[T]):n[T],T,void 0,v)}else if(typeof n=="number"){Number.isInteger(n)||Re(`The v-for range expect an integer value but got ${n}.`),f=new Array(n);for(let w=0;w<n;w++)f[w]=s(w+1,w,void 0,v)}else if(Ft(n))if(n[Symbol.iterator])f=Array.from(n,(w,R)=>s(w,R,void 0,v));else{const w=Object.keys(n);f=new Array(w.length);for(let R=0,L=w.length;R<L;R++){const T=w[R];f[R]=s(n[T],T,R,v)}}else f=[];return f}function eE(n,s,l={},d,f){if(_n.ce||_n.parent&&ro(_n.parent)&&_n.parent.ce){const L=Object.keys(l).length>0;return va(),Jh(rr,null,[En("slot",l,d)],L?-2:64)}let v=n[s];v&&v.length>1&&(Re("SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template."),v=()=>[]),v&&v._c&&(v._d=!1),va();const _=v&&Nv(v(l)),w=l.key||_&&_.key,R=Jh(rr,{key:(w&&!ci(w)?w:`_${s}`)+""},_||[],_&&n._===1?64:-2);return v&&v._c&&(v._d=!0),R}function Nv(n){return n.some(s=>_s(s)?!(s.type===Yn||s.type===rr&&!Nv(s.children)):!0)?n:null}const jh=n=>n?ry(n)?Id(n):jh(n.parent):null,vs=ln(Object.create(null),{$:n=>n,$el:n=>n.vnode.el,$data:n=>n.data,$props:n=>Br(n.props),$attrs:n=>Br(n.attrs),$slots:n=>Br(n.slots),$refs:n=>Br(n.refs),$parent:n=>jh(n.parent),$root:n=>jh(n.root),$host:n=>n.ce,$emit:n=>n.emit,$options:n=>Fv(n),$forceUpdate:n=>n.f||(n.f=()=>{Pc(n.update)}),$nextTick:n=>n.n||(n.n=xv.bind(n.proxy)),$watch:n=>yw.bind(n)}),Td=n=>n==="_"||n==="$",Th=(n,s)=>n!==Bt&&!n.__isScriptSetup&&Tt(n,s),kv={get({_:n},s){if(s==="__v_skip")return!0;const{ctx:l,setupState:d,data:f,props:v,accessCache:_,type:w,appContext:R}=n;if(s==="__isVue")return!0;let L;if(s[0]!=="$"){const C=_[s];if(C!==void 0)switch(C){case 1:return d[s];case 2:return f[s];case 4:return l[s];case 3:return v[s]}else{if(Th(d,s))return _[s]=1,d[s];if(f!==Bt&&Tt(f,s))return _[s]=2,f[s];if((L=n.propsOptions[0])&&Tt(L,s))return _[s]=3,v[s];if(l!==Bt&&Tt(l,s))return _[s]=4,l[s];qh&&(_[s]=0)}}const T=vs[s];let E,P;if(T)return s==="$attrs"?(yn(n.attrs,"get",""),vc()):s==="$slots"&&yn(n,"get",s),T(n);if((E=w.__cssModules)&&(E=E[s]))return E;if(l!==Bt&&Tt(l,s))return _[s]=4,l[s];if(P=R.config.globalProperties,Tt(P,s))return P[s];_n&&(!Yt(s)||s.indexOf("__v")!==0)&&(f!==Bt&&Td(s[0])&&Tt(f,s)?Re(`Property ${JSON.stringify(s)} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`):n===_n&&Re(`Property ${JSON.stringify(s)} was accessed during render but is not defined on instance.`))},set({_:n},s,l){const{data:d,setupState:f,ctx:v}=n;return Th(f,s)?(f[s]=l,!0):f.__isScriptSetup&&Tt(f,s)?(Re(`Cannot mutate <script setup> binding "${s}" from Options API.`),!1):d!==Bt&&Tt(d,s)?(d[s]=l,!0):Tt(n.props,s)?(Re(`Attempting to mutate prop "${s}". Props are readonly.`),!1):s[0]==="$"&&s.slice(1)in n?(Re(`Attempting to mutate public property "${s}". Properties starting with $ are reserved and readonly.`),!1):(s in n.appContext.config.globalProperties?Object.defineProperty(v,s,{enumerable:!0,configurable:!0,value:l}):v[s]=l,!0)},has({_:{data:n,setupState:s,accessCache:l,ctx:d,appContext:f,propsOptions:v,type:_}},w){let R,L;return!!(l[w]||n!==Bt&&w[0]!=="$"&&Tt(n,w)||Th(s,w)||(R=v[0])&&Tt(R,w)||Tt(d,w)||Tt(vs,w)||Tt(f.config.globalProperties,w)||(L=_.__cssModules)&&L[w])},defineProperty(n,s,l){return l.get!=null?n._.accessCache[s]=0:Tt(l,"value")&&this.set(n,s,l.value,null),Reflect.defineProperty(n,s,l)}};kv.ownKeys=n=>(Re("Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."),Reflect.ownKeys(n));function zb(n){const s={};return Object.defineProperty(s,"_",{configurable:!0,enumerable:!1,get:()=>n}),Object.keys(vs).forEach(l=>{Object.defineProperty(s,l,{configurable:!0,enumerable:!1,get:()=>vs[l](n),set:Ln})}),s}function Ub(n){const{ctx:s,propsOptions:[l]}=n;l&&Object.keys(l).forEach(d=>{Object.defineProperty(s,d,{enumerable:!0,configurable:!0,get:()=>n.props[d],set:Ln})})}function Gb(n){const{ctx:s,setupState:l}=n;Object.keys(gt(l)).forEach(d=>{if(!l.__isScriptSetup){if(Td(d[0])){Re(`setup() return property ${JSON.stringify(d)} should not start with "$" or "_" which are reserved prefixes for Vue internals.`);return}Object.defineProperty(s,d,{enumerable:!0,configurable:!0,get:()=>l[d],set:Ln})}})}function jm(n){return nt(n)?n.reduce((s,l)=>(s[l]=null,s),{}):n}function Vb(){const n=Object.create(null);return(s,l)=>{n[l]?Re(`${s} property "${l}" is already defined in ${n[l]}.`):n[l]=s}}let qh=!0;function Wb(n){const s=Fv(n),l=n.proxy,d=n.ctx;qh=!1,s.beforeCreate&&qm(s.beforeCreate,n,"bc");const{data:f,computed:v,methods:_,watch:w,provide:R,inject:L,created:T,beforeMount:E,mounted:P,beforeUpdate:C,updated:z,activated:j,deactivated:ne,beforeDestroy:pe,beforeUnmount:ie,destroyed:ae,unmounted:xe,render:Te,renderTracked:Ke,renderTriggered:at,errorCaptured:lt,serverPrefetch:pt,expose:Ct,inheritAttrs:Mt,components:At,directives:Et,filters:tn}=s,zt=Vb();{const[Je]=n.propsOptions;if(Je)for(const et in Je)zt("Props",et)}if(L&&jb(L,d,zt),_)for(const Je in _){const et=_[Je];ot(et)?(Object.defineProperty(d,Je,{value:et.bind(l),configurable:!0,enumerable:!0,writable:!0}),zt("Methods",Je)):Re(`Method "${Je}" has type "${typeof et}" in the component definition. Did you reference the function correctly?`)}if(f){ot(f)||Re("The data option must be a function. Plain object usage is no longer supported.");const Je=f.call(l,l);if(pd(Je)&&Re("data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>."),!Ft(Je))Re("data() should return an object.");else{n.data=Lc(Je);for(const et in Je)zt("Data",et),Td(et[0])||Object.defineProperty(d,et,{configurable:!0,enumerable:!0,get:()=>Je[et],set:Ln})}}if(qh=!0,v)for(const Je in v){const et=v[Je],Vt=ot(et)?et.bind(l,l):ot(et.get)?et.get.bind(l,l):Ln;Vt===Ln&&Re(`Computed property "${Je}" has no getter.`);const Vn=!ot(et)&&ot(et.set)?et.set.bind(l):()=>{Re(`Write operation failed: computed property "${Je}" is readonly.`)},Cn=ar({get:Vt,set:Vn});Object.defineProperty(d,Je,{enumerable:!0,configurable:!0,get:()=>Cn.value,set:bn=>Cn.value=bn}),zt("Computed",Je)}if(w)for(const Je in w)Hv(w[Je],d,l,Je);if(R){const Je=ot(R)?R.call(l):R;Reflect.ownKeys(Je).forEach(et=>{nc(et,Je[et])})}T&&qm(T,n,"c");function It(Je,et){nt(et)?et.forEach(Vt=>Je(Vt.bind(l))):et&&Je(et.bind(l))}if(It(Rb,E),It(Ov,P),It(Lb,C),It(Cb,z),It(Eb,j),It(Tb,ne),It(Nb,lt),It(Db,Ke),It(Ob,at),It(Pb,ie),It(Dv,xe),It(Ib,pt),nt(Ct))if(Ct.length){const Je=n.exposed||(n.exposed={});Ct.forEach(et=>{Object.defineProperty(Je,et,{get:()=>l[et],set:Vt=>l[et]=Vt,enumerable:!0})})}else n.exposed||(n.exposed={});Te&&n.render===Ln&&(n.render=Te),Mt!=null&&(n.inheritAttrs=Mt),At&&(n.components=At),Et&&(n.directives=Et),pt&&Pv(n)}function jb(n,s,l=Ln){nt(n)&&(n=Xh(n));for(const d in n){const f=n[d];let v;Ft(f)?"default"in f?v=br(f.from||d,f.default,!0):v=br(f.from||d):v=br(f),an(v)?Object.defineProperty(s,d,{enumerable:!0,configurable:!0,get:()=>v.value,set:_=>v.value=_}):s[d]=v,l("Inject",d)}}function qm(n,s,l){Gr(nt(n)?n.map(d=>d.bind(s.proxy)):n.bind(s.proxy),s,l)}function Hv(n,s,l,d){let f=d.includes(".")?Zv(l,d):()=>l[d];if(Yt(n)){const v=s[n];ot(v)?ua(f,v):Re(`Invalid watch handler specified by key "${n}"`,v)}else if(ot(n))ua(f,n.bind(l));else if(Ft(n))if(nt(n))n.forEach(v=>Hv(v,s,l,d));else{const v=ot(n.handler)?n.handler.bind(l):s[n.handler];ot(v)?ua(f,v,n):Re(`Invalid watch handler specified by key "${n.handler}"`,v)}else Re(`Invalid watch option: "${d}"`,n)}function Fv(n){const s=n.type,{mixins:l,extends:d}=s,{mixins:f,optionsCache:v,config:{optionMergeStrategies:_}}=n.appContext,w=v.get(s);let R;return w?R=w:!f.length&&!l&&!d?R=s:(R={},f.length&&f.forEach(L=>mc(R,L,_,!0)),mc(R,s,_)),Ft(s)&&v.set(s,R),R}function mc(n,s,l,d=!1){const{mixins:f,extends:v}=s;v&&mc(n,v,l,!0),f&&f.forEach(_=>mc(n,_,l,!0));for(const _ in s)if(d&&_==="expose")Re('"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.');else{const w=qb[_]||l&&l[_];n[_]=w?w(n[_],s[_]):s[_]}return n}const qb={data:Xm,props:Ym,emits:Ym,methods:na,computed:na,beforeCreate:Hn,created:Hn,beforeMount:Hn,mounted:Hn,beforeUpdate:Hn,updated:Hn,beforeDestroy:Hn,beforeUnmount:Hn,destroyed:Hn,unmounted:Hn,activated:Hn,deactivated:Hn,errorCaptured:Hn,serverPrefetch:Hn,components:na,directives:na,watch:Yb,provide:Xm,inject:Xb};function Xm(n,s){return s?n?function(){return ln(ot(n)?n.call(this,this):n,ot(s)?s.call(this,this):s)}:s:n}function Xb(n,s){return na(Xh(n),Xh(s))}function Xh(n){if(nt(n)){const s={};for(let l=0;l<n.length;l++)s[n[l]]=n[l];return s}return n}function Hn(n,s){return n?[...new Set([].concat(n,s))]:s}function na(n,s){return n?ln(Object.create(null),n,s):s}function Ym(n,s){return n?nt(n)&&nt(s)?[...new Set([...n,...s])]:ln(Object.create(null),jm(n),jm(s??{})):s}function Yb(n,s){if(!n)return s;if(!s)return n;const l=ln(Object.create(null),n);for(const d in s)l[d]=Hn(n[d],s[d]);return l}function Bv(){return{app:null,config:{isNativeTag:Wg,performance:!1,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap,propsCache:new WeakMap,emitsCache:new WeakMap}}let Zb=0;function Kb(n,s){return function(d,f=null){ot(d)||(d=ln({},d)),f!=null&&!Ft(f)&&(Re("root props passed to app.mount() must be an object."),f=null);const v=Bv(),_=new WeakSet,w=[];let R=!1;const L=v.app={_uid:Zb++,_component:d,_props:f,_container:null,_context:v,_instance:null,version:ig,get config(){return v.config},set config(T){Re("app.config cannot be replaced. Modify individual options instead.")},use(T,...E){return _.has(T)?Re("Plugin has already been applied to target app."):T&&ot(T.install)?(_.add(T),T.install(L,...E)):ot(T)?(_.add(T),T(L,...E)):Re('A plugin must either be a function or an object with an "install" function.'),L},mixin(T){return v.mixins.includes(T)?Re("Mixin has already been applied to target app"+(T.name?`: ${T.name}`:"")):v.mixins.push(T),L},component(T,E){return ed(T,v.config),E?(v.components[T]&&Re(`Component "${T}" has already been registered in target app.`),v.components[T]=E,L):v.components[T]},directive(T,E){return Lv(T),E?(v.directives[T]&&Re(`Directive "${T}" has already been registered in target app.`),v.directives[T]=E,L):v.directives[T]},mount(T,E,P){if(R)Re("App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. `const createMyApp = () => createApp(App)`");else{T.__vue_app__&&Re("There is already an app instance mounted on the host container.\n If you want to mount another app on the same host container, you need to unmount the previous app by calling `app.unmount()` first.");const C=L._ceVNode||En(d,f);return C.appContext=v,P===!0?P="svg":P===!1&&(P=void 0),v.reload=()=>{const z=Ni(C);z.el=null,n(z,T,P)},n(C,T,P),R=!0,L._container=T,T.__vue_app__=L,L._instance=C.component,pb(L,ig),Id(C.component)}},onUnmount(T){typeof T!="function"&&Re(`Expected function as first argument to app.onUnmount(), but got ${typeof T}`),w.push(T)},unmount(){R?(Gr(w,L._instance,16),n(null,L._container),L._instance=null,fb(L),delete L._container.__vue_app__):Re("Cannot unmount an app that is not mounted.")},provide(T,E){return T in v.provides&&(Tt(v.provides,T)?Re(`App already provides property with key "${String(T)}". It will be overwritten with the new value.`):Re(`App already provides property with key "${String(T)}" inherited from its parent element. It will be overwritten with the new value.`)),v.provides[T]=E,L},runWithContext(T){const E=io;io=L;try{return T()}finally{io=E}}};return L}}let io=null;function nc(n,s){if(!xn)Re("provide() can only be used inside setup().");else{let l=xn.provides;const d=xn.parent&&xn.parent.provides;d===l&&(l=xn.provides=Object.create(d)),l[n]=s}}function br(n,s,l=!1){const d=Dc();if(d||io){let f=io?io._context.provides:d?d.parent==null||d.ce?d.vnode.appContext&&d.vnode.appContext.provides:d.parent.provides:void 0;if(f&&n in f)return f[n];if(arguments.length>1)return l&&ot(s)?s.call(d&&d.proxy):s;Re(`injection "${String(n)}" not found.`)}else Re("inject() can only be used inside setup() or functional components.")}const zv={},Uv=()=>Object.create(zv),Gv=n=>Object.getPrototypeOf(n)===zv;function $b(n,s,l,d=!1){const f={},v=Uv();n.propsDefaults=Object.create(null),Vv(n,s,f,v);for(const _ in n.propsOptions[0])_ in f||(f[_]=void 0);jv(s||{},f,n),l?n.props=d?f:fv(f):n.type.props?n.props=f:n.props=v,n.attrs=v}function Jb(n){for(;n;){if(n.type.__hmrId)return!0;n=n.parent}}function Qb(n,s,l,d){const{props:f,attrs:v,vnode:{patchFlag:_}}=n,w=gt(f),[R]=n.propsOptions;let L=!1;if(!Jb(n)&&(d||_>0)&&!(_&16)){if(_&8){const T=n.vnode.dynamicProps;for(let E=0;E<T.length;E++){let P=T[E];if(Oc(n.emitsOptions,P))continue;const C=s[P];if(R)if(Tt(v,P))C!==v[P]&&(v[P]=C,L=!0);else{const z=Un(P);f[z]=Yh(R,w,z,C,n,!1)}else C!==v[P]&&(v[P]=C,L=!0)}}}else{Vv(n,s,f,v)&&(L=!0);let T;for(const E in w)(!s||!Tt(s,E)&&((T=Di(E))===E||!Tt(s,T)))&&(R?l&&(l[E]!==void 0||l[T]!==void 0)&&(f[E]=Yh(R,w,E,void 0,n,!0)):delete f[E]);if(v!==w)for(const E in v)(!s||!Tt(s,E))&&(delete v[E],L=!0)}L&&Hr(n.attrs,"set",""),jv(s||{},f,n)}function Vv(n,s,l,d){const[f,v]=n.propsOptions;let _=!1,w;if(s)for(let R in s){if(oa(R))continue;const L=s[R];let T;f&&Tt(f,T=Un(R))?!v||!v.includes(T)?l[T]=L:(w||(w={}))[T]=L:Oc(n.emitsOptions,R)||(!(R in d)||L!==d[R])&&(d[R]=L,_=!0)}if(v){const R=gt(l),L=w||Bt;for(let T=0;T<v.length;T++){const E=v[T];l[E]=Yh(f,R,E,L[E],n,!Tt(L,E))}}return _}function Yh(n,s,l,d,f,v){const _=n[l];if(_!=null){const w=Tt(_,"default");if(w&&d===void 0){const R=_.default;if(_.type!==Function&&!_.skipFactory&&ot(R)){const{propsDefaults:L}=f;if(l in L)d=L[l];else{const T=Ta(f);d=L[l]=R.call(null,s),T()}}else d=R;f.ce&&f.ce._setProp(l,d)}_[0]&&(v&&!w?d=!1:_[1]&&(d===""||d===Di(l))&&(d=!0))}return d}const ew=new WeakMap;function Wv(n,s,l=!1){const d=l?ew:s.propsCache,f=d.get(n);if(f)return f;const v=n.props,_={},w=[];let R=!1;if(!ot(n)){const T=E=>{R=!0;const[P,C]=Wv(E,s,!0);ln(_,P),C&&w.push(...C)};!l&&s.mixins.length&&s.mixins.forEach(T),n.extends&&T(n.extends),n.mixins&&n.mixins.forEach(T)}if(!v&&!R)return Ft(n)&&d.set(n,to),to;if(nt(v))for(let T=0;T<v.length;T++){Yt(v[T])||Re("props must be strings when using array syntax.",v[T]);const E=Un(v[T]);Zm(E)&&(_[E]=Bt)}else if(v){Ft(v)||Re("invalid props options",v);for(const T in v){const E=Un(T);if(Zm(E)){const P=v[T],C=_[E]=nt(P)||ot(P)?{type:P}:ln({},P),z=C.type;let j=!1,ne=!0;if(nt(z))for(let pe=0;pe<z.length;++pe){const ie=z[pe],ae=ot(ie)&&ie.name;if(ae==="Boolean"){j=!0;break}else ae==="String"&&(ne=!1)}else j=ot(z)&&z.name==="Boolean";C[0]=j,C[1]=ne,(j||Tt(C,"default"))&&w.push(E)}}}const L=[_,w];return Ft(n)&&d.set(n,L),L}function Zm(n){return n[0]!=="$"&&!oa(n)?!0:(Re(`Invalid prop name: "${n}" is a reserved property.`),!1)}function tw(n){return n===null?"null":typeof n=="function"?n.name||"":typeof n=="object"&&n.constructor&&n.constructor.name||""}function jv(n,s,l){const d=gt(s),f=l.propsOptions[0],v=Object.keys(n).map(_=>Un(_));for(const _ in f){let w=f[_];w!=null&&nw(_,d[_],w,Br(d),!v.includes(_))}}function nw(n,s,l,d,f){const{type:v,required:_,validator:w,skipCheck:R}=l;if(_&&f){Re('Missing required prop: "'+n+'"');return}if(!(s==null&&!_)){if(v!=null&&v!==!0&&!R){let L=!1;const T=nt(v)?v:[v],E=[];for(let P=0;P<T.length&&!L;P++){const{valid:C,expectedType:z}=iw(s,T[P]);E.push(z||""),L=C}if(!L){Re(sw(n,s,E));return}}w&&!w(s,d)&&Re('Invalid prop: custom validator check failed for prop "'+n+'".')}}const rw=li("String,Number,Boolean,Function,Symbol,BigInt");function iw(n,s){let l;const d=tw(s);if(d==="null")l=n===null;else if(rw(d)){const f=typeof n;l=f===d.toLowerCase(),!l&&f==="object"&&(l=n instanceof s)}else d==="Object"?l=Ft(n):d==="Array"?l=nt(n):l=n instanceof s;return{valid:l,expectedType:d}}function sw(n,s,l){if(l.length===0)return`Prop type [] for prop "${n}" won't match anything. Did you mean to use type Array instead?`;let d=`Invalid prop: type check failed for prop "${n}". Expected ${l.map(ys).join(" | ")}`;const f=l[0],v=fd(s),_=Km(s,f),w=Km(s,v);return l.length===1&&$m(f)&&!ow(f,v)&&(d+=` with value ${_}`),d+=`, got ${v} `,$m(v)&&(d+=`with value ${w}.`),d}function Km(n,s){return s==="String"?`"${n}"`:s==="Number"?`${Number(n)}`:`${n}`}function $m(n){return["string","number","boolean"].some(l=>n.toLowerCase()===l)}function ow(...n){return n.some(s=>s.toLowerCase()==="boolean")}const Ad=n=>n==="_"||n==="_ctx"||n==="$stable",Rd=n=>nt(n)?n.map(xr):[xr(n)],aw=(n,s,l)=>{if(s._n)return s;const d=bb((...f)=>(xn&&!(l===null&&_n)&&!(l&&l.root!==xn.root)&&Re(`Slot "${n}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`),Rd(s(...f))),l);return d._c=!1,d},qv=(n,s,l)=>{const d=n._ctx;for(const f in n){if(Ad(f))continue;const v=n[f];if(ot(v))s[f]=aw(f,v,d);else if(v!=null){Re(`Non-function value encountered for slot "${f}". Prefer function slots for better performance.`);const _=Rd(v);s[f]=()=>_}}},Xv=(n,s)=>{Ed(n.vnode)||Re("Non-function value encountered for default slot. Prefer function slots for better performance.");const l=Rd(s);n.slots.default=()=>l},Zh=(n,s,l)=>{for(const d in s)(l||!Ad(d))&&(n[d]=s[d])},lw=(n,s,l)=>{const d=n.slots=Uv();if(n.vnode.shapeFlag&32){const f=s._;f?(Zh(d,s,l),l&&ac(d,"_",f,!0)):qv(s,d)}else s&&Xv(n,s)},cw=(n,s,l)=>{const{vnode:d,slots:f}=n;let v=!0,_=Bt;if(d.shapeFlag&32){const w=s._;w?zr?(Zh(f,s,l),Hr(n,"set","$slots")):l&&w===1?v=!1:Zh(f,s,l):(v=!s.$stable,qv(s,f)),_=s}else s&&(Xv(n,s),_={default:1});if(v)for(const w in f)!Ad(w)&&_[w]==null&&delete f[w]};let Zo,si;function Xs(n,s){n.appContext.config.performance&&gc()&&si.mark(`vue-${s}-${n.uid}`),yb(n,s,gc()?si.now():Date.now())}function Ys(n,s){if(n.appContext.config.performance&&gc()){const l=`vue-${s}-${n.uid}`,d=l+":end",f=`<${Nc(n,n.type)}> ${s}`;si.mark(d),si.measure(f,l,d),si.clearMeasures(f),si.clearMarks(l),si.clearMarks(d)}xb(n,s,gc()?si.now():Date.now())}function gc(){return Zo!==void 0||(typeof window<"u"&&window.performance?(Zo=!0,si=window.performance):Zo=!1),Zo}function uw(){const n=[];if(n.length){const s=n.length>1;console.warn(`Feature flag${s?"s":""} ${n.join(", ")} ${s?"are":"is"} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`)}}const nr=Tw;function hw(n){return dw(n)}function dw(n,s){uw();const l=wa();l.__VUE__=!0,Ev(l.__VUE_DEVTOOLS_GLOBAL_HOOK__,l);const{insert:d,remove:f,patchProp:v,createElement:_,createText:w,createComment:R,setText:L,setElementText:T,parentNode:E,nextSibling:P,setScopeId:C=Ln,insertStaticContent:z}=n,j=(D,F,$,_e=null,ue=null,be=null,X=void 0,Se=null,we=zr?!1:!!F.dynamicChildren)=>{if(D===F)return;D&&!Ko(D,F)&&(_e=Fe(D),cn(D,ue,be,!0),D=null),F.patchFlag===-2&&(we=!1,F.dynamicChildren=null);const{type:ce,ref:He,shapeFlag:Le}=F;switch(ce){case Ea:ne(D,F,$,_e);break;case Yn:pe(D,F,$,_e);break;case ha:D==null?ie(F,$,_e,X):ae(D,F,$,X);break;case rr:Et(D,F,$,_e,ue,be,X,Se,we);break;default:Le&1?Ke(D,F,$,_e,ue,be,X,Se,we):Le&6?tn(D,F,$,_e,ue,be,X,Se,we):Le&64||Le&128?ce.process(D,F,$,_e,ue,be,X,Se,we,$e):Re("Invalid VNode type:",ce,`(${typeof ce})`)}He!=null&&ue?ca(He,D&&D.ref,be,F||D,!F):He==null&&D&&D.ref!=null&&ca(D.ref,null,be,D,!0)},ne=(D,F,$,_e)=>{if(D==null)d(F.el=w(F.children),$,_e);else{const ue=F.el=D.el;F.children!==D.children&&L(ue,F.children)}},pe=(D,F,$,_e)=>{D==null?d(F.el=R(F.children||""),$,_e):F.el=D.el},ie=(D,F,$,_e)=>{[D.el,D.anchor]=z(D.children,F,$,_e,D.el,D.anchor)},ae=(D,F,$,_e)=>{if(F.children!==D.children){const ue=P(D.anchor);Te(D),[F.el,F.anchor]=z(F.children,$,ue,_e)}else F.el=D.el,F.anchor=D.anchor},xe=({el:D,anchor:F},$,_e)=>{let ue;for(;D&&D!==F;)ue=P(D),d(D,$,_e),D=ue;d(F,$,_e)},Te=({el:D,anchor:F})=>{let $;for(;D&&D!==F;)$=P(D),f(D),D=$;f(F)},Ke=(D,F,$,_e,ue,be,X,Se,we)=>{if(F.type==="svg"?X="svg":F.type==="math"&&(X="mathml"),D==null)at(F,$,_e,ue,be,X,Se,we);else{const ce=D.el&&D.el._isVueCE?D.el:null;try{ce&&ce._beginPatch(),Ct(D,F,ue,be,X,Se,we)}finally{ce&&ce._endPatch()}}},at=(D,F,$,_e,ue,be,X,Se)=>{let we,ce;const{props:He,shapeFlag:Le,transition:Ue,dirs:tt}=D;if(we=D.el=_(D.type,be,He&&He.is,He),Le&8?T(we,D.children):Le&16&&pt(D.children,we,null,_e,ue,Ah(D,be),X,Se),tt&&ns(D,null,_e,"created"),lt(we,D,D.scopeId,X,_e),He){for(const ct in He)ct!=="value"&&!oa(ct)&&v(we,ct,null,He[ct],be,_e);"value"in He&&v(we,"value",null,He.value,be),(ce=He.onVnodeBeforeMount)&&Dr(ce,_e,D)}ac(we,"__vnode",D,!0),ac(we,"__vueParentComponent",_e,!0),tt&&ns(D,null,_e,"beforeMount");const it=pw(ue,Ue);it&&Ue.beforeEnter(we),d(we,F,$),((ce=He&&He.onVnodeMounted)||it||tt)&&nr(()=>{ce&&Dr(ce,_e,D),it&&Ue.enter(we),tt&&ns(D,null,_e,"mounted")},ue)},lt=(D,F,$,_e,ue)=>{if($&&C(D,$),_e)for(let be=0;be<_e.length;be++)C(D,_e[be]);if(ue){let be=ue.subTree;if(be.patchFlag>0&&be.patchFlag&2048&&(be=Cd(be.children)||be),F===be||Jv(be.type)&&(be.ssContent===F||be.ssFallback===F)){const X=ue.vnode;lt(D,X,X.scopeId,X.slotScopeIds,ue.parent)}}},pt=(D,F,$,_e,ue,be,X,Se,we=0)=>{for(let ce=we;ce<D.length;ce++){const He=D[ce]=Se?Ci(D[ce]):xr(D[ce]);j(null,He,F,$,_e,ue,be,X,Se)}},Ct=(D,F,$,_e,ue,be,X)=>{const Se=F.el=D.el;Se.__vnode=F;let{patchFlag:we,dynamicChildren:ce,dirs:He}=F;we|=D.patchFlag&16;const Le=D.props||Bt,Ue=F.props||Bt;let tt;if($&&rs($,!1),(tt=Ue.onVnodeBeforeUpdate)&&Dr(tt,$,F,D),He&&ns(F,D,$,"beforeUpdate"),$&&rs($,!0),zr&&(we=0,X=!1,ce=null),(Le.innerHTML&&Ue.innerHTML==null||Le.textContent&&Ue.textContent==null)&&T(Se,""),ce?(Mt(D.dynamicChildren,ce,Se,$,_e,Ah(F,ue),be),Kh(D,F)):X||Vt(D,F,Se,null,$,_e,Ah(F,ue),be,!1),we>0){if(we&16)At(Se,Le,Ue,$,ue);else if(we&2&&Le.class!==Ue.class&&v(Se,"class",null,Ue.class,ue),we&4&&v(Se,"style",Le.style,Ue.style,ue),we&8){const it=F.dynamicProps;for(let ct=0;ct<it.length;ct++){const Rt=it[ct],nn=Le[Rt],pn=Ue[Rt];(pn!==nn||Rt==="value")&&v(Se,Rt,nn,pn,ue,$)}}we&1&&D.children!==F.children&&T(Se,F.children)}else!X&&ce==null&&At(Se,Le,Ue,$,ue);((tt=Ue.onVnodeUpdated)||He)&&nr(()=>{tt&&Dr(tt,$,F,D),He&&ns(F,D,$,"updated")},_e)},Mt=(D,F,$,_e,ue,be,X)=>{for(let Se=0;Se<F.length;Se++){const we=D[Se],ce=F[Se],He=we.el&&(we.type===rr||!Ko(we,ce)||we.shapeFlag&198)?E(we.el):$;j(we,ce,He,null,_e,ue,be,X,!0)}},At=(D,F,$,_e,ue)=>{if(F!==$){if(F!==Bt)for(const be in F)!oa(be)&&!(be in $)&&v(D,be,F[be],null,ue,_e);for(const be in $){if(oa(be))continue;const X=$[be],Se=F[be];X!==Se&&be!=="value"&&v(D,be,Se,X,ue,_e)}"value"in $&&v(D,"value",F.value,$.value,ue)}},Et=(D,F,$,_e,ue,be,X,Se,we)=>{const ce=F.el=D?D.el:w(""),He=F.anchor=D?D.anchor:w("");let{patchFlag:Le,dynamicChildren:Ue,slotScopeIds:tt}=F;(zr||Le&2048)&&(Le=0,we=!1,Ue=null),tt&&(Se=Se?Se.concat(tt):tt),D==null?(d(ce,$,_e),d(He,$,_e),pt(F.children||[],$,He,ue,be,X,Se,we)):Le>0&&Le&64&&Ue&&D.dynamicChildren?(Mt(D.dynamicChildren,Ue,$,ue,be,X,Se),Kh(D,F)):Vt(D,F,$,He,ue,be,X,Se,we)},tn=(D,F,$,_e,ue,be,X,Se,we)=>{F.slotScopeIds=Se,D==null?F.shapeFlag&512?ue.ctx.activate(F,$,_e,X,we):zt(F,$,_e,ue,be,X,we):It(D,F,we)},zt=(D,F,$,_e,ue,be,X)=>{const Se=D.component=Nw(D,_e,ue);if(Se.type.__hmrId&&cb(Se),Ql(D),Xs(Se,"mount"),Ed(D)&&(Se.ctx.renderer=$e),Xs(Se,"init"),Hw(Se,!1,X),Ys(Se,"init"),zr&&(D.el=null),Se.asyncDep){if(ue&&ue.registerDep(Se,Je,X),!D.el){const we=Se.subTree=En(Yn);pe(null,we,F,$),D.placeholder=we.el}}else Je(Se,D,F,$,ue,be,X);ec(),Ys(Se,"mount")},It=(D,F,$)=>{const _e=F.component=D.component;if(Sw(D,F,$))if(_e.asyncDep&&!_e.asyncResolved){Ql(F),et(_e,F,$),ec();return}else _e.next=F,_e.update();else F.el=D.el,_e.vnode=F},Je=(D,F,$,_e,ue,be,X)=>{const Se=()=>{if(D.isMounted){let{next:Le,bu:Ue,u:tt,parent:it,vnode:ct}=D;{const Kn=Yv(D);if(Kn){Le&&(Le.el=ct.el,et(D,Le,X)),Kn.asyncDep.then(()=>{D.isUnmounted||Se()});return}}let Rt=Le,nn;Ql(Le||D.vnode),rs(D,!1),Le?(Le.el=ct.el,et(D,Le,X)):Le=ct,Ue&&Xo(Ue),(nn=Le.props&&Le.props.onVnodeBeforeUpdate)&&Dr(nn,it,Le,ct),rs(D,!0),Xs(D,"render");const pn=Qm(D);Ys(D,"render");const Zn=D.subTree;D.subTree=pn,Xs(D,"patch"),j(Zn,pn,E(Zn.el),Fe(Zn),D,ue,be),Ys(D,"patch"),Le.el=pn.el,Rt===null&&Ew(D,pn.el),tt&&nr(tt,ue),(nn=Le.props&&Le.props.onVnodeUpdated)&&nr(()=>Dr(nn,it,Le,ct),ue),Tv(D),ec()}else{let Le;const{el:Ue,props:tt}=F,{bm:it,m:ct,parent:Rt,root:nn,type:pn}=D,Zn=ro(F);rs(D,!1),it&&Xo(it),!Zn&&(Le=tt&&tt.onVnodeBeforeMount)&&Dr(Le,Rt,F),rs(D,!0);{nn.ce&&nn.ce._def.shadowRoot!==!1&&nn.ce._injectChildStyle(pn),Xs(D,"render");const Kn=D.subTree=Qm(D);Ys(D,"render"),Xs(D,"patch"),j(null,Kn,$,_e,D,ue,be),Ys(D,"patch"),F.el=Kn.el}if(ct&&nr(ct,ue),!Zn&&(Le=tt&&tt.onVnodeMounted)){const Kn=F;nr(()=>Dr(Le,Rt,Kn),ue)}(F.shapeFlag&256||Rt&&ro(Rt.vnode)&&Rt.vnode.shapeFlag&256)&&D.a&&nr(D.a,ue),D.isMounted=!0,mb(D),F=$=_e=null}};D.scope.on();const we=D.effect=new Jg(Se);D.scope.off();const ce=D.update=we.run.bind(we),He=D.job=we.runIfDirty.bind(we);He.i=D,He.id=D.uid,we.scheduler=()=>Pc(He),rs(D,!0),we.onTrack=D.rtc?Le=>Xo(D.rtc,Le):void 0,we.onTrigger=D.rtg?Le=>Xo(D.rtg,Le):void 0,ce()},et=(D,F,$)=>{F.component=D;const _e=D.vnode.props;D.vnode=F,D.next=null,Qb(D,F.props,_e,$),cw(D,F.children,$),Mr(),zm(D),Sr()},Vt=(D,F,$,_e,ue,be,X,Se,we=!1)=>{const ce=D&&D.children,He=D?D.shapeFlag:0,Le=F.children,{patchFlag:Ue,shapeFlag:tt}=F;if(Ue>0){if(Ue&128){Cn(ce,Le,$,_e,ue,be,X,Se,we);return}else if(Ue&256){Vn(ce,Le,$,_e,ue,be,X,Se,we);return}}tt&8?(He&16&&se(ce,ue,be),Le!==ce&&T($,Le)):He&16?tt&16?Cn(ce,Le,$,_e,ue,be,X,Se,we):se(ce,ue,be,!0):(He&8&&T($,""),tt&16&&pt(Le,$,_e,ue,be,X,Se,we))},Vn=(D,F,$,_e,ue,be,X,Se,we)=>{D=D||to,F=F||to;const ce=D.length,He=F.length,Le=Math.min(ce,He);let Ue;for(Ue=0;Ue<Le;Ue++){const tt=F[Ue]=we?Ci(F[Ue]):xr(F[Ue]);j(D[Ue],tt,$,null,ue,be,X,Se,we)}ce>He?se(D,ue,be,!0,!1,Le):pt(F,$,_e,ue,be,X,Se,we,Le)},Cn=(D,F,$,_e,ue,be,X,Se,we)=>{let ce=0;const He=F.length;let Le=D.length-1,Ue=He-1;for(;ce<=Le&&ce<=Ue;){const tt=D[ce],it=F[ce]=we?Ci(F[ce]):xr(F[ce]);if(Ko(tt,it))j(tt,it,$,null,ue,be,X,Se,we);else break;ce++}for(;ce<=Le&&ce<=Ue;){const tt=D[Le],it=F[Ue]=we?Ci(F[Ue]):xr(F[Ue]);if(Ko(tt,it))j(tt,it,$,null,ue,be,X,Se,we);else break;Le--,Ue--}if(ce>Le){if(ce<=Ue){const tt=Ue+1,it=tt<He?F[tt].el:_e;for(;ce<=Ue;)j(null,F[ce]=we?Ci(F[ce]):xr(F[ce]),$,it,ue,be,X,Se,we),ce++}}else if(ce>Ue)for(;ce<=Le;)cn(D[ce],ue,be,!0),ce++;else{const tt=ce,it=ce,ct=new Map;for(ce=it;ce<=Ue;ce++){const St=F[ce]=we?Ci(F[ce]):xr(F[ce]);St.key!=null&&(ct.has(St.key)&&Re("Duplicate keys found during update:",JSON.stringify(St.key),"Make sure keys are unique."),ct.set(St.key,ce))}let Rt,nn=0;const pn=Ue-it+1;let Zn=!1,Kn=0;const hi=new Array(pn);for(ce=0;ce<pn;ce++)hi[ce]=0;for(ce=tt;ce<=Le;ce++){const St=D[ce];if(nn>=pn){cn(St,ue,be,!0);continue}let wn;if(St.key!=null)wn=ct.get(St.key);else for(Rt=it;Rt<=Ue;Rt++)if(hi[Rt-it]===0&&Ko(St,F[Rt])){wn=Rt;break}wn===void 0?cn(St,ue,be,!0):(hi[wn-it]=ce+1,wn>=Kn?Kn=wn:Zn=!0,j(St,F[wn],$,null,ue,be,X,Se,we),nn++)}const Ee=Zn?fw(hi):to;for(Rt=Ee.length-1,ce=pn-1;ce>=0;ce--){const St=it+ce,wn=F[St],Er=F[St+1],Ra=St+1<He?Er.el||Er.placeholder:_e;hi[ce]===0?j(null,wn,$,Ra,ue,be,X,Se,we):Zn&&(Rt<0||ce!==Ee[Rt]?bn(wn,$,Ra,2):Rt--)}}},bn=(D,F,$,_e,ue=null)=>{const{el:be,type:X,transition:Se,children:we,shapeFlag:ce}=D;if(ce&6){bn(D.component.subTree,F,$,_e);return}if(ce&128){D.suspense.move(F,$,_e);return}if(ce&64){X.move(D,F,$,$e);return}if(X===rr){d(be,F,$);for(let Le=0;Le<we.length;Le++)bn(we[Le],F,$,_e);d(D.anchor,F,$);return}if(X===ha){xe(D,F,$);return}if(_e!==2&&ce&1&&Se)if(_e===0)Se.beforeEnter(be),d(be,F,$),nr(()=>Se.enter(be),ue);else{const{leave:Le,delayLeave:Ue,afterLeave:tt}=Se,it=()=>{D.ctx.isUnmounted?f(be):d(be,F,$)},ct=()=>{be._isLeaving&&be[Sb](!0),Le(be,()=>{it(),tt&&tt()})};Ue?Ue(be,it,ct):ct()}else d(be,F,$)},cn=(D,F,$,_e=!1,ue=!1)=>{const{type:be,props:X,ref:Se,children:we,dynamicChildren:ce,shapeFlag:He,patchFlag:Le,dirs:Ue,cacheIndex:tt}=D;if(Le===-2&&(ue=!1),Se!=null&&(Mr(),ca(Se,null,$,D,!0),Sr()),tt!=null&&(F.renderCache[tt]=void 0),He&256){F.ctx.deactivate(D);return}const it=He&1&&Ue,ct=!ro(D);let Rt;if(ct&&(Rt=X&&X.onVnodeBeforeUnmount)&&Dr(Rt,F,D),He&6)On(D.component,$,_e);else{if(He&128){D.suspense.unmount($,_e);return}it&&ns(D,null,F,"beforeUnmount"),He&64?D.type.remove(D,F,$,$e,_e):ce&&!ce.hasOnce&&(be!==rr||Le>0&&Le&64)?se(ce,F,$,!1,!0):(be===rr&&Le&384||!ue&&He&16)&&se(we,F,$),_e&&Pn(D)}(ct&&(Rt=X&&X.onVnodeUnmounted)||it)&&nr(()=>{Rt&&Dr(Rt,F,D),it&&ns(D,null,F,"unmounted")},$)},Pn=D=>{const{type:F,el:$,anchor:_e,transition:ue}=D;if(F===rr){D.patchFlag>0&&D.patchFlag&2048&&ue&&!ue.persisted?D.children.forEach(X=>{X.type===Yn?f(X.el):Pn(X)}):In($,_e);return}if(F===ha){Te(D);return}const be=()=>{f($),ue&&!ue.persisted&&ue.afterLeave&&ue.afterLeave()};if(D.shapeFlag&1&&ue&&!ue.persisted){const{leave:X,delayLeave:Se}=ue,we=()=>X($,be);Se?Se(D.el,be,we):we()}else be()},In=(D,F)=>{let $;for(;D!==F;)$=P(D),f(D),D=$;f(F)},On=(D,F,$)=>{D.type.__hmrId&&ub(D);const{bum:_e,scope:ue,job:be,subTree:X,um:Se,m:we,a:ce}=D;Jm(we),Jm(ce),_e&&Xo(_e),ue.stop(),be&&(be.flags|=8,cn(X,D,F,$)),Se&&nr(Se,F),nr(()=>{D.isUnmounted=!0},F),vb(D)},se=(D,F,$,_e=!1,ue=!1,be=0)=>{for(let X=be;X<D.length;X++)cn(D[X],F,$,_e,ue)},Fe=D=>{if(D.shapeFlag&6)return Fe(D.component.subTree);if(D.shapeFlag&128)return D.suspense.next();const F=P(D.anchor||D.el),$=F&&F[wb];return $?P($):F};let Ne=!1;const Ye=(D,F,$)=>{D==null?F._vnode&&cn(F._vnode,null,null,!0):j(F._vnode||null,D,F,null,null,null,$),F._vnode=D,Ne||(Ne=!0,zm(),wv(),Ne=!1)},$e={p:j,um:cn,m:bn,r:Pn,mt:zt,mc:pt,pc:Vt,pbc:Mt,n:Fe,o:n};return{render:Ye,hydrate:void 0,createApp:Kb(Ye)}}function Ah({type:n,props:s},l){return l==="svg"&&n==="foreignObject"||l==="mathml"&&n==="annotation-xml"&&s&&s.encoding&&s.encoding.includes("html")?void 0:l}function rs({effect:n,job:s},l){l?(n.flags|=32,s.flags|=4):(n.flags&=-33,s.flags&=-5)}function pw(n,s){return(!n||n&&!n.pendingBranch)&&s&&!s.persisted}function Kh(n,s,l=!1){const d=n.children,f=s.children;if(nt(d)&&nt(f))for(let v=0;v<d.length;v++){const _=d[v];let w=f[v];w.shapeFlag&1&&!w.dynamicChildren&&((w.patchFlag<=0||w.patchFlag===32)&&(w=f[v]=Ci(f[v]),w.el=_.el),!l&&w.patchFlag!==-2&&Kh(_,w)),w.type===Ea&&w.patchFlag!==-1&&(w.el=_.el),w.type===Yn&&!w.el&&(w.el=_.el),w.el&&(w.el.__vnode=w)}}function fw(n){const s=n.slice(),l=[0];let d,f,v,_,w;const R=n.length;for(d=0;d<R;d++){const L=n[d];if(L!==0){if(f=l[l.length-1],n[f]<L){s[d]=f,l.push(d);continue}for(v=0,_=l.length-1;v<_;)w=v+_>>1,n[l[w]]<L?v=w+1:_=w;L<n[l[v]]&&(v>0&&(s[d]=l[v-1]),l[v]=d)}}for(v=l.length,_=l[v-1];v-- >0;)l[v]=_,_=s[_];return l}function Yv(n){const s=n.subTree.component;if(s)return s.asyncDep&&!s.asyncResolved?s:Yv(s)}function Jm(n){if(n)for(let s=0;s<n.length;s++)n[s].flags|=8}const mw=Symbol.for("v-scx"),gw=()=>{{const n=br(mw);return n||Re("Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build."),n}};function vw(n,s){return Ld(n,null,s)}function ua(n,s,l){return ot(s)||Re("`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature."),Ld(n,s,l)}function Ld(n,s,l=Bt){const{immediate:d,deep:f,flush:v,once:_}=l;s||(d!==void 0&&Re('watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.'),f!==void 0&&Re('watch() "deep" option is only respected when using the watch(source, callback, options?) signature.'),_!==void 0&&Re('watch() "once" option is only respected when using the watch(source, callback, options?) signature.'));const w=ln({},l);w.onWarn=Re;const R=s&&d||!s&&v!=="post";let L;if(xa){if(v==="sync"){const C=gw();L=C.__watcherHandles||(C.__watcherHandles=[])}else if(!R){const C=()=>{};return C.stop=Ln,C.resume=Ln,C.pause=Ln,C}}const T=xn;w.call=(C,z,j)=>Gr(C,T,z,j);let E=!1;v==="post"?w.scheduler=C=>{nr(C,T&&T.suspense)}:v!=="sync"&&(E=!0,w.scheduler=(C,z)=>{z?C():Pc(C)}),w.augmentJob=C=>{s&&(C.flags|=4),E&&(C.flags|=2,T&&(C.id=T.uid,C.i=T))};const P=tb(n,s,w);return xa&&(L?L.push(P):R&&P()),P}function yw(n,s,l){const d=this.proxy,f=Yt(n)?n.includes(".")?Zv(d,n):()=>d[n]:n.bind(d,d);let v;ot(s)?v=s:(v=s.handler,l=s);const _=Ta(this),w=Ld(f,v.bind(d),l);return _(),w}function Zv(n,s){const l=s.split(".");return()=>{let d=n;for(let f=0;f<l.length&&d;f++)d=d[l[f]];return d}}const xw=(n,s)=>s==="modelValue"||s==="model-value"?n.modelModifiers:n[`${s}Modifiers`]||n[`${Un(s)}Modifiers`]||n[`${Di(s)}Modifiers`];function _w(n,s,...l){if(n.isUnmounted)return;const d=n.vnode.props||Bt;{const{emitsOptions:T,propsOptions:[E]}=n;if(T)if(!(s in T))(!E||!(ss(Un(s))in E))&&Re(`Component emitted event "${s}" but it is neither declared in the emits option nor as an "${ss(Un(s))}" prop.`);else{const P=T[s];ot(P)&&(P(...l)||Re(`Invalid event arguments: event validation failed for event "${s}".`))}}let f=l;const v=s.startsWith("update:"),_=v&&xw(d,s.slice(7));_&&(_.trim&&(f=l.map(T=>Yt(T)?T.trim():T)),_.number&&(f=l.map(m_))),_b(n,s,f);{const T=s.toLowerCase();T!==s&&d[ss(T)]&&Re(`Event "${T}" is emitted in component ${Nc(n,n.type)} but the handler is registered for "${s}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${Di(s)}" instead of "${s}".`)}let w,R=d[w=ss(s)]||d[w=ss(Un(s))];!R&&v&&(R=d[w=ss(Di(s))]),R&&Gr(R,n,6,f);const L=d[w+"Once"];if(L){if(!n.emitted)n.emitted={};else if(n.emitted[w])return;n.emitted[w]=!0,Gr(L,n,6,f)}}const bw=new WeakMap;function Kv(n,s,l=!1){const d=l?bw:s.emitsCache,f=d.get(n);if(f!==void 0)return f;const v=n.emits;let _={},w=!1;if(!ot(n)){const R=L=>{const T=Kv(L,s,!0);T&&(w=!0,ln(_,T))};!l&&s.mixins.length&&s.mixins.forEach(R),n.extends&&R(n.extends),n.mixins&&n.mixins.forEach(R)}return!v&&!w?(Ft(n)&&d.set(n,null),null):(nt(v)?v.forEach(R=>_[R]=null):ln(_,v),Ft(n)&&d.set(n,_),_)}function Oc(n,s){return!n||!ba(s)?!1:(s=s.slice(2).replace(/Once$/,""),Tt(n,s[0].toLowerCase()+s.slice(1))||Tt(n,Di(s))||Tt(n,s))}let $h=!1;function vc(){$h=!0}function Qm(n){const{type:s,vnode:l,proxy:d,withProxy:f,propsOptions:[v],slots:_,attrs:w,emit:R,render:L,renderCache:T,props:E,data:P,setupState:C,ctx:z,inheritAttrs:j}=n,ne=pc(n);let pe,ie;$h=!1;try{if(l.shapeFlag&4){const Te=f||d,Ke=C.__isScriptSetup?new Proxy(Te,{get(at,lt,pt){return Re(`Property '${String(lt)}' was accessed via 'this'. Avoid using 'this' in templates.`),Reflect.get(at,lt,pt)}}):Te;pe=xr(L.call(Ke,Te,T,Br(E),C,P,z)),ie=w}else{const Te=s;w===E&&vc(),pe=xr(Te.length>1?Te(Br(E),{get attrs(){return vc(),Br(w)},slots:_,emit:R}):Te(Br(E),null)),ie=s.props?w:ww(w)}}catch(Te){da.length=0,Ma(Te,n,1),pe=En(Yn)}let ae=pe,xe;if(pe.patchFlag>0&&pe.patchFlag&2048&&([ae,xe]=$v(pe)),ie&&j!==!1){const Te=Object.keys(ie),{shapeFlag:Ke}=ae;if(Te.length){if(Ke&7)v&&Te.some(oc)&&(ie=Mw(ie,v)),ae=Ni(ae,ie,!1,!0);else if(!$h&&ae.type!==Yn){const at=Object.keys(w),lt=[],pt=[];for(let Ct=0,Mt=at.length;Ct<Mt;Ct++){const At=at[Ct];ba(At)?oc(At)||lt.push(At[2].toLowerCase()+At.slice(3)):pt.push(At)}pt.length&&Re(`Extraneous non-props attributes (${pt.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text or teleport root nodes.`),lt.length&&Re(`Extraneous non-emits event listeners (${lt.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`)}}}return l.dirs&&(eg(ae)||Re("Runtime directive used on component with non-element root node. The directives will not function as intended."),ae=Ni(ae,null,!1,!0),ae.dirs=ae.dirs?ae.dirs.concat(l.dirs):l.dirs),l.transition&&(eg(ae)||Re("Component inside <Transition> renders non-element root node that cannot be animated."),Sd(ae,l.transition)),xe?xe(ae):pe=ae,pc(ne),pe}const $v=n=>{const s=n.children,l=n.dynamicChildren,d=Cd(s,!1);if(d){if(d.patchFlag>0&&d.patchFlag&2048)return $v(d)}else return[n,void 0];const f=s.indexOf(d),v=l?l.indexOf(d):-1,_=w=>{s[f]=w,l&&(v>-1?l[v]=w:w.patchFlag>0&&(n.dynamicChildren=[...l,w]))};return[xr(d),_]};function Cd(n,s=!0){let l;for(let d=0;d<n.length;d++){const f=n[d];if(_s(f)){if(f.type!==Yn||f.children==="v-if"){if(l)return;if(l=f,s&&l.patchFlag>0&&l.patchFlag&2048)return Cd(l.children)}}else return}return l}const ww=n=>{let s;for(const l in n)(l==="class"||l==="style"||ba(l))&&((s||(s={}))[l]=n[l]);return s},Mw=(n,s)=>{const l={};for(const d in n)(!oc(d)||!(d.slice(9)in s))&&(l[d]=n[d]);return l},eg=n=>n.shapeFlag&7||n.type===Yn;function Sw(n,s,l){const{props:d,children:f,component:v}=n,{props:_,children:w,patchFlag:R}=s,L=v.emitsOptions;if((f||w)&&zr||s.dirs||s.transition)return!0;if(l&&R>=0){if(R&1024)return!0;if(R&16)return d?tg(d,_,L):!!_;if(R&8){const T=s.dynamicProps;for(let E=0;E<T.length;E++){const P=T[E];if(_[P]!==d[P]&&!Oc(L,P))return!0}}}else return(f||w)&&(!w||!w.$stable)?!0:d===_?!1:d?_?tg(d,_,L):!0:!!_;return!1}function tg(n,s,l){const d=Object.keys(s);if(d.length!==Object.keys(n).length)return!0;for(let f=0;f<d.length;f++){const v=d[f];if(s[v]!==n[v]&&!Oc(l,v))return!0}return!1}function Ew({vnode:n,parent:s},l){for(;s;){const d=s.subTree;if(d.suspense&&d.suspense.activeBranch===n&&(d.el=n.el),d===n)(n=s.vnode).el=l,s=s.parent;else break}}const Jv=n=>n.__isSuspense;function Tw(n,s){s&&s.pendingBranch?nt(n)?s.effects.push(...n):s.effects.push(n):bv(n)}const rr=Symbol.for("v-fgt"),Ea=Symbol.for("v-txt"),Yn=Symbol.for("v-cmt"),ha=Symbol.for("v-stc"),da=[];let sr=null;function va(n=!1){da.push(sr=n?null:[])}function Aw(){da.pop(),sr=da[da.length-1]||null}let ya=1;function yc(n,s=!1){ya+=n,n<0&&sr&&s&&(sr.hasOnce=!0)}function Qv(n){return n.dynamicChildren=ya>0?sr||to:null,Aw(),ya>0&&sr&&sr.push(n),n}function ey(n,s,l,d,f,v){return Qv(Fn(n,s,l,d,f,v,!0))}function Jh(n,s,l,d,f){return Qv(En(n,s,l,d,f,!0))}function _s(n){return n?n.__v_isVNode===!0:!1}function Ko(n,s){if(s.shapeFlag&6&&n.component){const l=tc.get(s.type);if(l&&l.has(n.component))return n.shapeFlag&=-257,s.shapeFlag&=-513,!1}return n.type===s.type&&n.key===s.key}const Rw=(...n)=>Lw(...n),ty=({key:n})=>n??null,rc=({ref:n,ref_key:s,ref_for:l})=>(typeof n=="number"&&(n=""+n),n!=null?Yt(n)||an(n)||ot(n)?{i:_n,r:n,k:s,f:!!l}:n:null);function Fn(n,s=null,l=null,d=0,f=null,v=n===rr?0:1,_=!1,w=!1){const R={__v_isVNode:!0,__v_skip:!0,type:n,props:s,key:s&&ty(s),ref:s&&rc(s),scopeId:Rv,slotScopeIds:null,children:l,component:null,suspense:null,ssContent:null,ssFallback:null,dirs:null,transition:null,el:null,anchor:null,target:null,targetStart:null,targetAnchor:null,staticCount:0,shapeFlag:v,patchFlag:d,dynamicProps:f,dynamicChildren:null,appContext:null,ctx:_n};return w?(Pd(R,l),v&128&&n.normalize(R)):l&&(R.shapeFlag|=Yt(l)?8:16),R.key!==R.key&&Re("VNode created with invalid key (NaN). VNode type:",R.type),ya>0&&!_&&sr&&(R.patchFlag>0||v&6)&&R.patchFlag!==32&&sr.push(R),R}const En=Rw;function Lw(n,s=null,l=null,d=0,f=null,v=!1){if((!n||n===Fb)&&(n||Re(`Invalid vnode type when creating vnode: ${n}.`),n=Yn),_s(n)){const w=Ni(n,s,!0);return l&&Pd(w,l),ya>0&&!v&&sr&&(w.shapeFlag&6?sr[sr.indexOf(n)]=w:sr.push(w)),w.patchFlag=-2,w}if(sy(n)&&(n=n.__vccOpts),s){s=Cw(s);let{class:w,style:R}=s;w&&!Yt(w)&&(s.class=Tc(w)),Ft(R)&&(lc(R)&&!nt(R)&&(R=ln({},R)),s.style=gd(R))}const _=Yt(n)?1:Jv(n)?128:Mb(n)?64:Ft(n)?4:ot(n)?2:0;return _&4&&lc(n)&&(n=gt(n),Re("Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.",`
Component that was made reactive: `,n)),Fn(n,s,l,d,f,_,v,!0)}function Cw(n){return n?lc(n)||Gv(n)?ln({},n):n:null}function Ni(n,s,l=!1,d=!1){const{props:f,ref:v,patchFlag:_,children:w,transition:R}=n,L=s?Iw(f||{},s):f,T={__v_isVNode:!0,__v_skip:!0,type:n.type,props:L,key:L&&ty(L),ref:s&&s.ref?l&&v?nt(v)?v.concat(rc(s)):[v,rc(s)]:rc(s):v,scopeId:n.scopeId,slotScopeIds:n.slotScopeIds,children:_===-1&&nt(w)?w.map(ny):w,target:n.target,targetStart:n.targetStart,targetAnchor:n.targetAnchor,staticCount:n.staticCount,shapeFlag:n.shapeFlag,patchFlag:s&&n.type!==rr?_===-1?16:_|16:_,dynamicProps:n.dynamicProps,dynamicChildren:n.dynamicChildren,appContext:n.appContext,dirs:n.dirs,transition:R,component:n.component,suspense:n.suspense,ssContent:n.ssContent&&Ni(n.ssContent),ssFallback:n.ssFallback&&Ni(n.ssFallback),placeholder:n.placeholder,el:n.el,anchor:n.anchor,ctx:n.ctx,ce:n.ce};return R&&d&&Sd(T,R.clone(T)),T}function ny(n){const s=Ni(n);return nt(n.children)&&(s.children=n.children.map(ny)),s}function Pw(n=" ",s=0){return En(Ea,null,n,s)}function tE(n,s){const l=En(ha,null,n);return l.staticCount=s,l}function nE(n="",s=!1){return s?(va(),Jh(Yn,null,n)):En(Yn,null,n)}function xr(n){return n==null||typeof n=="boolean"?En(Yn):nt(n)?En(rr,null,n.slice()):_s(n)?Ci(n):En(Ea,null,String(n))}function Ci(n){return n.el===null&&n.patchFlag!==-1||n.memo?n:Ni(n)}function Pd(n,s){let l=0;const{shapeFlag:d}=n;if(s==null)s=null;else if(nt(s))l=16;else if(typeof s=="object")if(d&65){const f=s.default;f&&(f._c&&(f._d=!1),Pd(n,f()),f._c&&(f._d=!0));return}else{l=32;const f=s._;!f&&!Gv(s)?s._ctx=_n:f===3&&_n&&(_n.slots._===1?s._=1:(s._=2,n.patchFlag|=1024))}else ot(s)?(s={default:s,_ctx:_n},l=32):(s=String(s),d&64?(l=16,s=[Pw(s)]):l=8);n.children=s,n.shapeFlag|=l}function Iw(...n){const s={};for(let l=0;l<n.length;l++){const d=n[l];for(const f in d)if(f==="class")s.class!==d.class&&(s.class=Tc([s.class,d.class]));else if(f==="style")s.style=gd([s.style,d.style]);else if(ba(f)){const v=s[f],_=d[f];_&&v!==_&&!(nt(v)&&v.includes(_))&&(s[f]=v?[].concat(v,_):_)}else f!==""&&(s[f]=d[f])}return s}function Dr(n,s,l,d=null){Gr(n,s,7,[l,d])}const Ow=Bv();let Dw=0;function Nw(n,s,l){const d=n.type,f=(s?s.appContext:n.appContext)||Ow,v={uid:Dw++,vnode:n,type:d,parent:s,appContext:f,root:null,next:null,subTree:null,effect:null,update:null,job:null,scope:new R_(!0),render:null,proxy:null,exposed:null,exposeProxy:null,withProxy:null,provides:s?s.provides:Object.create(f.provides),ids:s?s.ids:["",0,0],accessCache:null,renderCache:[],components:null,directives:null,propsOptions:Wv(d,f),emitsOptions:Kv(d,f),emit:null,emitted:null,propsDefaults:Bt,inheritAttrs:d.inheritAttrs,ctx:Bt,data:Bt,props:Bt,attrs:Bt,slots:Bt,refs:Bt,setupState:Bt,setupContext:null,suspense:l,suspenseId:l?l.pendingId:0,asyncDep:null,asyncResolved:!1,isMounted:!1,isUnmounted:!1,isDeactivated:!1,bc:null,c:null,bm:null,m:null,bu:null,u:null,um:null,bum:null,da:null,a:null,rtg:null,rtc:null,ec:null,sp:null};return v.ctx=zb(v),v.root=s?s.root:v,v.emit=_w.bind(null,v),n.ce&&n.ce(v),v}let xn=null;const Dc=()=>xn||_n;let xc,Qh;{const n=wa(),s=(l,d)=>{let f;return(f=n[l])||(f=n[l]=[]),f.push(d),v=>{f.length>1?f.forEach(_=>_(v)):f[0](v)}};xc=s("__VUE_INSTANCE_SETTERS__",l=>xn=l),Qh=s("__VUE_SSR_SETTERS__",l=>xa=l)}const Ta=n=>{const s=xn;return xc(n),n.scope.on(),()=>{n.scope.off(),xc(s)}},ng=()=>{xn&&xn.scope.off(),xc(null)},kw=li("slot,component");function ed(n,{isNativeTag:s}){(kw(n)||s(n))&&Re("Do not use built-in or reserved HTML elements as component id: "+n)}function ry(n){return n.vnode.shapeFlag&4}let xa=!1;function Hw(n,s=!1,l=!1){s&&Qh(s);const{props:d,children:f}=n.vnode,v=ry(n);$b(n,d,v,s),lw(n,f,l||s);const _=v?Fw(n,s):void 0;return s&&Qh(!1),_}function Fw(n,s){var l;const d=n.type;{if(d.name&&ed(d.name,n.appContext.config),d.components){const v=Object.keys(d.components);for(let _=0;_<v.length;_++)ed(v[_],n.appContext.config)}if(d.directives){const v=Object.keys(d.directives);for(let _=0;_<v.length;_++)Lv(v[_])}d.compilerOptions&&Bw()&&Re('"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.')}n.accessCache=Object.create(null),n.proxy=new Proxy(n.ctx,kv),Ub(n);const{setup:f}=d;if(f){Mr();const v=n.setupContext=f.length>1?Gw(n):null,_=Ta(n),w=ao(f,n,0,[Br(n.props),v]),R=pd(w);if(Sr(),_(),(R||n.sp)&&!ro(n)&&Pv(n),R){if(w.then(ng,ng),s)return w.then(L=>{rg(n,L,s)}).catch(L=>{Ma(L,n,0)});if(n.asyncDep=w,!n.suspense){const L=(l=d.name)!=null?l:"Anonymous";Re(`Component <${L}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`)}}else rg(n,w,s)}else iy(n,s)}function rg(n,s,l){ot(s)?n.type.__ssrInlineRender?n.ssrRender=s:n.render=s:Ft(s)?(_s(s)&&Re("setup() should not return VNodes directly - return a render function instead."),n.devtoolsRawSetupState=s,n.setupState=gv(s),Gb(n)):s!==void 0&&Re(`setup() should return an object. Received: ${s===null?"null":typeof s}`),iy(n,l)}const Bw=()=>!0;function iy(n,s,l){const d=n.type;n.render||(n.render=d.render||Ln);{const f=Ta(n);Mr();try{Wb(n)}finally{Sr(),f()}}!d.render&&n.render===Ln&&!s&&(d.template?Re('Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".'):Re("Component is missing template or render function: ",d))}const zw={get(n,s){return vc(),yn(n,"get",""),n[s]},set(){return Re("setupContext.attrs is readonly."),!1},deleteProperty(){return Re("setupContext.attrs is readonly."),!1}};function Uw(n){return new Proxy(n.slots,{get(s,l){return yn(n,"get","$slots"),s[l]}})}function Gw(n){const s=l=>{if(n.exposed&&Re("expose() should be called only once per setup()."),l!=null){let d=typeof l;d==="object"&&(nt(l)?d="array":an(l)&&(d="ref")),d!=="object"&&Re(`expose() should be passed a plain object, received ${d}.`)}n.exposed=l||{}};{let l,d;return Object.freeze({get attrs(){return l||(l=new Proxy(n.attrs,zw))},get slots(){return d||(d=Uw(n))},get emit(){return(f,...v)=>n.emit(f,...v)},expose:s})}}function Id(n){return n.exposed?n.exposeProxy||(n.exposeProxy=new Proxy(gv(Y_(n.exposed)),{get(s,l){if(l in s)return s[l];if(l in vs)return vs[l](n)},has(s,l){return l in s||l in vs}})):n.proxy}const Vw=/(?:^|[-_])\w/g,Ww=n=>n.replace(Vw,s=>s.toUpperCase()).replace(/[-_]/g,"");function Od(n,s=!0){return ot(n)?n.displayName||n.name:n.name||s&&n.__name}function Nc(n,s,l=!1){let d=Od(s);if(!d&&s.__file){const f=s.__file.match(/([^/\\]+)\.\w+$/);f&&(d=f[1])}if(!d&&n&&n.parent){const f=v=>{for(const _ in v)if(v[_]===s)return _};d=f(n.components||n.parent.type.components)||f(n.appContext.components)}return d?Ww(d):l?"App":"Anonymous"}function sy(n){return ot(n)&&"__vccOpts"in n}const ar=(n,s)=>{const l=Q_(n,s,xa);{const d=Dc();d&&d.appContext.config.warnRecursiveComputed&&(l._warnRecursive=!0)}return l};function oy(n,s,l){try{yc(-1);const d=arguments.length;return d===2?Ft(s)&&!nt(s)?_s(s)?En(n,null,[s]):En(n,s):En(n,null,s):(d>3?l=Array.prototype.slice.call(arguments,2):d===3&&_s(l)&&(l=[l]),En(n,s,l))}finally{yc(1)}}function jw(){if(typeof window>"u")return;const n={style:"color:#3ba776"},s={style:"color:#1677ff"},l={style:"color:#f5222d"},d={style:"color:#eb2f96"},f={__vue_custom_formatter:!0,header(E){if(!Ft(E))return null;if(E.__isVue)return["div",n,"VueInstance"];if(an(E)){Mr();const P=E.value;return Sr(),["div",{},["span",n,T(E)],"<",w(P),">"]}else{if(ms(E))return["div",{},["span",n,Gn(E)?"ShallowReactive":"Reactive"],"<",w(E),`>${Ur(E)?" (readonly)":""}`];if(Ur(E))return["div",{},["span",n,Gn(E)?"ShallowReadonly":"Readonly"],"<",w(E),">"]}return null},hasBody(E){return E&&E.__isVue},body(E){if(E&&E.__isVue)return["div",{},...v(E.$)]}};function v(E){const P=[];E.type.props&&E.props&&P.push(_("props",gt(E.props))),E.setupState!==Bt&&P.push(_("setup",E.setupState)),E.data!==Bt&&P.push(_("data",gt(E.data)));const C=R(E,"computed");C&&P.push(_("computed",C));const z=R(E,"inject");return z&&P.push(_("injected",z)),P.push(["div",{},["span",{style:d.style+";opacity:0.66"},"$ (internal): "],["object",{object:E}]]),P}function _(E,P){return P=ln({},P),Object.keys(P).length?["div",{style:"line-height:1.25em;margin-bottom:0.6em"},["div",{style:"color:#476582"},E],["div",{style:"padding-left:1.25em"},...Object.keys(P).map(C=>["div",{},["span",d,C+": "],w(P[C],!1)])]]:["span",{}]}function w(E,P=!0){return typeof E=="number"?["span",s,E]:typeof E=="string"?["span",l,JSON.stringify(E)]:typeof E=="boolean"?["span",d,E]:Ft(E)?["object",{object:P?gt(E):E}]:["span",l,String(E)]}function R(E,P){const C=E.type;if(ot(C))return;const z={};for(const j in E.ctx)L(C,j,P)&&(z[j]=E.ctx[j]);return z}function L(E,P,C){const z=E[C];if(nt(z)&&z.includes(P)||Ft(z)&&P in z||E.extends&&L(E.extends,P,C)||E.mixins&&E.mixins.some(j=>L(j,P,C)))return!0}function T(E){return Gn(E)?"ShallowRef":E.effect?"ComputedRef":"Ref"}window.devtoolsFormatters?window.devtoolsFormatters.push(f):window.devtoolsFormatters=[f]}const ig="3.5.24",ai=Re;/**
* @vue/runtime-dom v3.5.24
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let td;const sg=typeof window<"u"&&window.trustedTypes;if(sg)try{td=sg.createPolicy("vue",{createHTML:n=>n})}catch(n){ai(`Error creating trusted types policy: ${n}`)}const ay=td?n=>td.createHTML(n):n=>n,qw="http://www.w3.org/2000/svg",Xw="http://www.w3.org/1998/Math/MathML",ii=typeof document<"u"?document:null,og=ii&&ii.createElement("template"),Yw={insert:(n,s,l)=>{s.insertBefore(n,l||null)},remove:n=>{const s=n.parentNode;s&&s.removeChild(n)},createElement:(n,s,l,d)=>{const f=s==="svg"?ii.createElementNS(qw,n):s==="mathml"?ii.createElementNS(Xw,n):l?ii.createElement(n,{is:l}):ii.createElement(n);return n==="select"&&d&&d.multiple!=null&&f.setAttribute("multiple",d.multiple),f},createText:n=>ii.createTextNode(n),createComment:n=>ii.createComment(n),setText:(n,s)=>{n.nodeValue=s},setElementText:(n,s)=>{n.textContent=s},parentNode:n=>n.parentNode,nextSibling:n=>n.nextSibling,querySelector:n=>ii.querySelector(n),setScopeId(n,s){n.setAttribute(s,"")},insertStaticContent(n,s,l,d,f,v){const _=l?l.previousSibling:s.lastChild;if(f&&(f===v||f.nextSibling))for(;s.insertBefore(f.cloneNode(!0),l),!(f===v||!(f=f.nextSibling)););else{og.innerHTML=ay(d==="svg"?`<svg>${n}</svg>`:d==="mathml"?`<math>${n}</math>`:n);const w=og.content;if(d==="svg"||d==="mathml"){const R=w.firstChild;for(;R.firstChild;)w.appendChild(R.firstChild);w.removeChild(R)}s.insertBefore(w,l)}return[_?_.nextSibling:s.firstChild,l?l.previousSibling:s.lastChild]}},Zw=Symbol("_vtc");function Kw(n,s,l){const d=n[Zw];d&&(s=(s?[s,...d]:[...d]).join(" ")),s==null?n.removeAttribute("class"):l?n.setAttribute("class",s):n.className=s}const ag=Symbol("_vod"),$w=Symbol("_vsh"),Jw=Symbol("CSS_VAR_TEXT"),Qw=/(?:^|;)\s*display\s*:/;function eM(n,s,l){const d=n.style,f=Yt(l);let v=!1;if(l&&!f){if(s)if(Yt(s))for(const _ of s.split(";")){const w=_.slice(0,_.indexOf(":")).trim();l[w]==null&&ic(d,w,"")}else for(const _ in s)l[_]==null&&ic(d,_,"");for(const _ in l)_==="display"&&(v=!0),ic(d,_,l[_])}else if(f){if(s!==l){const _=d[Jw];_&&(l+=";"+_),d.cssText=l,v=Qw.test(l)}}else s&&n.removeAttribute("style");ag in n&&(n[ag]=v?d.display:"",n[$w]&&(d.display="none"))}const tM=/[^\\];\s*$/,lg=/\s*!important$/;function ic(n,s,l){if(nt(l))l.forEach(d=>ic(n,s,d));else if(l==null&&(l=""),tM.test(l)&&ai(`Unexpected semicolon at the end of '${s}' style value: '${l}'`),s.startsWith("--"))n.setProperty(s,l);else{const d=nM(n,s);lg.test(l)?n.setProperty(Di(d),l.replace(lg,""),"important"):n[d]=l}}const cg=["Webkit","Moz","ms"],Rh={};function nM(n,s){const l=Rh[s];if(l)return l;let d=Un(s);if(d!=="filter"&&d in n)return Rh[s]=d;d=ys(d);for(let f=0;f<cg.length;f++){const v=cg[f]+d;if(v in n)return Rh[s]=v}return s}const ug="http://www.w3.org/1999/xlink";function hg(n,s,l,d,f,v=A_(s)){d&&s.startsWith("xlink:")?l==null?n.removeAttributeNS(ug,s.slice(6,s.length)):n.setAttributeNS(ug,s,l):l==null||v&&!Yg(l)?n.removeAttribute(s):n.setAttribute(s,v?"":ci(l)?String(l):l)}function dg(n,s,l,d,f){if(s==="innerHTML"||s==="textContent"){l!=null&&(n[s]=s==="innerHTML"?ay(l):l);return}const v=n.tagName;if(s==="value"&&v!=="PROGRESS"&&!v.includes("-")){const w=v==="OPTION"?n.getAttribute("value")||"":n.value,R=l==null?n.type==="checkbox"?"on":"":String(l);(w!==R||!("_value"in n))&&(n.value=R),l==null&&n.removeAttribute(s),n._value=l;return}let _=!1;if(l===""||l==null){const w=typeof n[s];w==="boolean"?l=Yg(l):l==null&&w==="string"?(l="",_=!0):w==="number"&&(l=0,_=!0)}try{n[s]=l}catch(w){_||ai(`Failed setting prop "${s}" on <${v.toLowerCase()}>: value ${l} is invalid.`,w)}_&&n.removeAttribute(f||s)}function rM(n,s,l,d){n.addEventListener(s,l,d)}function iM(n,s,l,d){n.removeEventListener(s,l,d)}const pg=Symbol("_vei");function sM(n,s,l,d,f=null){const v=n[pg]||(n[pg]={}),_=v[s];if(d&&_)_.value=mg(d,s);else{const[w,R]=oM(s);if(d){const L=v[s]=cM(mg(d,s),f);rM(n,w,L,R)}else _&&(iM(n,w,_,R),v[s]=void 0)}}const fg=/(?:Once|Passive|Capture)$/;function oM(n){let s;if(fg.test(n)){s={};let d;for(;d=n.match(fg);)n=n.slice(0,n.length-d[0].length),s[d[0].toLowerCase()]=!0}return[n[2]===":"?n.slice(3):Di(n.slice(2)),s]}let Lh=0;const aM=Promise.resolve(),lM=()=>Lh||(aM.then(()=>Lh=0),Lh=Date.now());function cM(n,s){const l=d=>{if(!d._vts)d._vts=Date.now();else if(d._vts<=l.attached)return;Gr(uM(d,l.value),s,5,[d])};return l.value=n,l.attached=lM(),l}function mg(n,s){return ot(n)||nt(n)?n:(ai(`Wrong type passed as event handler to ${s} - did you forget @ or : in front of your prop?
Expected function or array of functions, received type ${typeof n}.`),Ln)}function uM(n,s){if(nt(s)){const l=n.stopImmediatePropagation;return n.stopImmediatePropagation=()=>{l.call(n),n._stopped=!0},s.map(d=>f=>!f._stopped&&d&&d(f))}else return s}const gg=n=>n.charCodeAt(0)===111&&n.charCodeAt(1)===110&&n.charCodeAt(2)>96&&n.charCodeAt(2)<123,hM=(n,s,l,d,f,v)=>{const _=f==="svg";s==="class"?Kw(n,d,_):s==="style"?eM(n,l,d):ba(s)?oc(s)||sM(n,s,l,d,v):(s[0]==="."?(s=s.slice(1),!0):s[0]==="^"?(s=s.slice(1),!1):dM(n,s,d,_))?(dg(n,s,d),!n.tagName.includes("-")&&(s==="value"||s==="checked"||s==="selected")&&hg(n,s,d,_,v,s!=="value")):n._isVueCE&&(/[A-Z]/.test(s)||!Yt(d))?dg(n,Un(s),d,v,s):(s==="true-value"?n._trueValue=d:s==="false-value"&&(n._falseValue=d),hg(n,s,d,_))};function dM(n,s,l,d){if(d)return!!(s==="innerHTML"||s==="textContent"||s in n&&gg(s)&&ot(l));if(s==="spellcheck"||s==="draggable"||s==="translate"||s==="autocorrect"||s==="sandbox"&&n.tagName==="IFRAME"||s==="form"||s==="list"&&n.tagName==="INPUT"||s==="type"&&n.tagName==="TEXTAREA")return!1;if(s==="width"||s==="height"){const f=n.tagName;if(f==="IMG"||f==="VIDEO"||f==="CANVAS"||f==="SOURCE")return!1}return gg(s)&&Yt(l)?!1:s in n}const pM=["ctrl","shift","alt","meta"],fM={stop:n=>n.stopPropagation(),prevent:n=>n.preventDefault(),self:n=>n.target!==n.currentTarget,ctrl:n=>!n.ctrlKey,shift:n=>!n.shiftKey,alt:n=>!n.altKey,meta:n=>!n.metaKey,left:n=>"button"in n&&n.button!==0,middle:n=>"button"in n&&n.button!==1,right:n=>"button"in n&&n.button!==2,exact:(n,s)=>pM.some(l=>n[`${l}Key`]&&!s.includes(l))},Kl=(n,s)=>{const l=n._withMods||(n._withMods={}),d=s.join(".");return l[d]||(l[d]=(f,...v)=>{for(let _=0;_<s.length;_++){const w=fM[s[_]];if(w&&w(f,s))return}return n(f,...v)})},mM=ln({patchProp:hM},Yw);let vg;function gM(){return vg||(vg=hw(mM))}const vM=(...n)=>{const s=gM().createApp(...n);xM(s),_M(s);const{mount:l}=s;return s.mount=d=>{const f=bM(d);if(!f)return;const v=s._component;!ot(v)&&!v.render&&!v.template&&(v.template=f.innerHTML),f.nodeType===1&&(f.textContent="");const _=l(f,!1,yM(f));return f instanceof Element&&(f.removeAttribute("v-cloak"),f.setAttribute("data-v-app","")),_},s};function yM(n){if(n instanceof SVGElement)return"svg";if(typeof MathMLElement=="function"&&n instanceof MathMLElement)return"mathml"}function xM(n){Object.defineProperty(n.config,"isNativeTag",{value:s=>M_(s)||S_(s)||E_(s),writable:!1})}function _M(n){{const s=n.config.isCustomElement;Object.defineProperty(n.config,"isCustomElement",{get(){return s},set(){ai("The `isCustomElement` config option is deprecated. Use `compilerOptions.isCustomElement` instead.")}});const l=n.config.compilerOptions,d='The `compilerOptions` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, `compilerOptions` must be passed to `@vue/compiler-dom` in the build setup instead.\n- For vue-loader: pass it via vue-loader\'s `compilerOptions` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc';Object.defineProperty(n.config,"compilerOptions",{get(){return ai(d),l},set(){ai(d)}})}}function bM(n){if(Yt(n)){const s=document.querySelector(n);return s||ai(`Failed to mount app: mount target selector "${n}" returned null.`),s}return window.ShadowRoot&&n instanceof window.ShadowRoot&&n.mode==="closed"&&ai('mounting on a ShadowRoot with `{mode: "closed"}` may lead to unpredictable bugs'),n}/**
* vue v3.5.24
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/function wM(){jw()}wM();const MM=""+new URL("Cauliflower-DHeSJbMi.png",import.meta.url).href;function SM(){return ly().__VUE_DEVTOOLS_GLOBAL_HOOK__}function ly(){return typeof navigator<"u"&&typeof window<"u"?window:typeof globalThis<"u"?globalThis:{}}const EM=typeof Proxy=="function",TM="devtools-plugin:setup",AM="plugin:settings:set";let Zs,nd;function RM(){var n;return Zs!==void 0||(typeof window<"u"&&window.performance?(Zs=!0,nd=window.performance):typeof globalThis<"u"&&(!((n=globalThis.perf_hooks)===null||n===void 0)&&n.performance)?(Zs=!0,nd=globalThis.perf_hooks.performance):Zs=!1),Zs}function LM(){return RM()?nd.now():Date.now()}class CM{constructor(s,l){this.target=null,this.targetQueue=[],this.onQueue=[],this.plugin=s,this.hook=l;const d={};if(s.settings)for(const _ in s.settings){const w=s.settings[_];d[_]=w.defaultValue}const f=`__vue-devtools-plugin-settings__${s.id}`;let v=Object.assign({},d);try{const _=localStorage.getItem(f),w=JSON.parse(_);Object.assign(v,w)}catch{}this.fallbacks={getSettings(){return v},setSettings(_){try{localStorage.setItem(f,JSON.stringify(_))}catch{}v=_},now(){return LM()}},l&&l.on(AM,(_,w)=>{_===this.plugin.id&&this.fallbacks.setSettings(w)}),this.proxiedOn=new Proxy({},{get:(_,w)=>this.target?this.target.on[w]:(...R)=>{this.onQueue.push({method:w,args:R})}}),this.proxiedTarget=new Proxy({},{get:(_,w)=>this.target?this.target[w]:w==="on"?this.proxiedOn:Object.keys(this.fallbacks).includes(w)?(...R)=>(this.targetQueue.push({method:w,args:R,resolve:()=>{}}),this.fallbacks[w](...R)):(...R)=>new Promise(L=>{this.targetQueue.push({method:w,args:R,resolve:L})})})}async setRealTarget(s){this.target=s;for(const l of this.onQueue)this.target.on[l.method](...l.args);for(const l of this.targetQueue)l.resolve(await this.target[l.method](...l.args))}}function PM(n,s){const l=n,d=ly(),f=SM(),v=EM&&l.enableEarlyProxy;if(f&&(d.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__||!v))f.emit(TM,n,s);else{const _=v?new CM(l,f):null;(d.__VUE_DEVTOOLS_PLUGINS__=d.__VUE_DEVTOOLS_PLUGINS__||[]).push({pluginDescriptor:l,setupFn:s,proxy:_}),_&&s(_.proxiedTarget)}}/*!
 * vue-router v4.6.3
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */const oi=typeof document<"u";function cy(n){return typeof n=="object"||"displayName"in n||"props"in n||"__vccOpts"in n}function IM(n){return n.__esModule||n[Symbol.toStringTag]==="Module"||n.default&&cy(n.default)}const Ot=Object.assign;function Ch(n,s){const l={};for(const d in s){const f=s[d];l[d]=or(f)?f.map(n):n(f)}return l}const pa=()=>{},or=Array.isArray;function yg(n,s){const l={};for(const d in n)l[d]=d in s?s[d]:n[d];return l}function vt(n){const s=Array.from(arguments).slice(1);console.warn.apply(console,["[Vue Router warn]: "+n].concat(s))}const uy=/#/g,OM=/&/g,DM=/\//g,NM=/=/g,kM=/\?/g,hy=/\+/g,HM=/%5B/g,FM=/%5D/g,dy=/%5E/g,BM=/%60/g,py=/%7B/g,zM=/%7C/g,fy=/%7D/g,UM=/%20/g;function Dd(n){return n==null?"":encodeURI(""+n).replace(zM,"|").replace(HM,"[").replace(FM,"]")}function GM(n){return Dd(n).replace(py,"{").replace(fy,"}").replace(dy,"^")}function rd(n){return Dd(n).replace(hy,"%2B").replace(UM,"+").replace(uy,"%23").replace(OM,"%26").replace(BM,"`").replace(py,"{").replace(fy,"}").replace(dy,"^")}function VM(n){return rd(n).replace(NM,"%3D")}function WM(n){return Dd(n).replace(uy,"%23").replace(kM,"%3F")}function jM(n){return WM(n).replace(DM,"%2F")}function so(n){if(n==null)return null;try{return decodeURIComponent(""+n)}catch{vt(`Error decoding "${n}". Using original value`)}return""+n}const qM=/\/$/,XM=n=>n.replace(qM,"");function Ph(n,s,l="/"){let d,f={},v="",_="";const w=s.indexOf("#");let R=s.indexOf("?");return R=w>=0&&R>w?-1:R,R>=0&&(d=s.slice(0,R),v=s.slice(R,w>0?w:s.length),f=n(v.slice(1))),w>=0&&(d=d||s.slice(0,w),_=s.slice(w,s.length)),d=KM(d??s,l),{fullPath:d+v+_,path:d,query:f,hash:so(_)}}function YM(n,s){const l=s.query?n(s.query):"";return s.path+(l&&"?")+l+(s.hash||"")}function xg(n,s){return!s||!n.toLowerCase().startsWith(s.toLowerCase())?n:n.slice(s.length)||"/"}function _g(n,s,l){const d=s.matched.length-1,f=l.matched.length-1;return d>-1&&d===f&&ki(s.matched[d],l.matched[f])&&my(s.params,l.params)&&n(s.query)===n(l.query)&&s.hash===l.hash}function ki(n,s){return(n.aliasOf||n)===(s.aliasOf||s)}function my(n,s){if(Object.keys(n).length!==Object.keys(s).length)return!1;for(const l in n)if(!ZM(n[l],s[l]))return!1;return!0}function ZM(n,s){return or(n)?bg(n,s):or(s)?bg(s,n):n===s}function bg(n,s){return or(s)?n.length===s.length&&n.every((l,d)=>l===s[d]):n.length===1&&n[0]===s}function KM(n,s){if(n.startsWith("/"))return n;if(!s.startsWith("/"))return vt(`Cannot resolve a relative location without an absolute path. Trying to resolve "${n}" from "${s}". It should look like "/${s}".`),n;if(!n)return s;const l=s.split("/"),d=n.split("/"),f=d[d.length-1];(f===".."||f===".")&&d.push("");let v=l.length-1,_,w;for(_=0;_<d.length;_++)if(w=d[_],w!==".")if(w==="..")v>1&&v--;else break;return l.slice(0,v).join("/")+"/"+d.slice(_).join("/")}const Ai={path:"/",name:void 0,params:{},query:{},hash:"",fullPath:"/",matched:[],meta:{},redirectedFrom:void 0};let id=function(n){return n.pop="pop",n.push="push",n}({}),Ih=function(n){return n.back="back",n.forward="forward",n.unknown="",n}({});function $M(n){if(!n)if(oi){const s=document.querySelector("base");n=s&&s.getAttribute("href")||"/",n=n.replace(/^\w+:\/\/[^\/]+/,"")}else n="/";return n[0]!=="/"&&n[0]!=="#"&&(n="/"+n),XM(n)}const JM=/^[^#]+#/;function QM(n,s){return n.replace(JM,"#")+s}function e1(n,s){const l=document.documentElement.getBoundingClientRect(),d=n.getBoundingClientRect();return{behavior:s.behavior,left:d.left-l.left-(s.left||0),top:d.top-l.top-(s.top||0)}}const kc=()=>({left:window.scrollX,top:window.scrollY});function t1(n){let s;if("el"in n){const l=n.el,d=typeof l=="string"&&l.startsWith("#");if(typeof n.el=="string"&&(!d||!document.getElementById(n.el.slice(1))))try{const v=document.querySelector(n.el);if(d&&v){vt(`The selector "${n.el}" should be passed as "el: document.querySelector('${n.el}')" because it starts with "#".`);return}}catch{vt(`The selector "${n.el}" is invalid. If you are using an id selector, make sure to escape it. You can find more information about escaping characters in selectors at https://mathiasbynens.be/notes/css-escapes or use CSS.escape (https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape).`);return}const f=typeof l=="string"?d?document.getElementById(l.slice(1)):document.querySelector(l):l;if(!f){vt(`Couldn't find element using selector "${n.el}" returned by scrollBehavior.`);return}s=e1(f,n)}else s=n;"scrollBehavior"in document.documentElement.style?window.scrollTo(s):window.scrollTo(s.left!=null?s.left:window.scrollX,s.top!=null?s.top:window.scrollY)}function wg(n,s){return(history.state?history.state.position-s:-1)+n}const sd=new Map;function n1(n,s){sd.set(n,s)}function r1(n){const s=sd.get(n);return sd.delete(n),s}function _c(n){return typeof n=="string"||n&&typeof n=="object"}function gy(n){return typeof n=="string"||typeof n=="symbol"}let Kt=function(n){return n[n.MATCHER_NOT_FOUND=1]="MATCHER_NOT_FOUND",n[n.NAVIGATION_GUARD_REDIRECT=2]="NAVIGATION_GUARD_REDIRECT",n[n.NAVIGATION_ABORTED=4]="NAVIGATION_ABORTED",n[n.NAVIGATION_CANCELLED=8]="NAVIGATION_CANCELLED",n[n.NAVIGATION_DUPLICATED=16]="NAVIGATION_DUPLICATED",n}({});const vy=Symbol("navigation failure"),i1={[Kt.MATCHER_NOT_FOUND]({location:n,currentLocation:s}){return`No match for
 ${JSON.stringify(n)}${s?`
while being at
`+JSON.stringify(s):""}`},[Kt.NAVIGATION_GUARD_REDIRECT]({from:n,to:s}){return`Redirected from "${n.fullPath}" to "${o1(s)}" via a navigation guard.`},[Kt.NAVIGATION_ABORTED]({from:n,to:s}){return`Navigation aborted from "${n.fullPath}" to "${s.fullPath}" via a navigation guard.`},[Kt.NAVIGATION_CANCELLED]({from:n,to:s}){return`Navigation cancelled from "${n.fullPath}" to "${s.fullPath}" with a new navigation.`},[Kt.NAVIGATION_DUPLICATED]({from:n,to:s}){return`Avoided redundant navigation to current location: "${n.fullPath}".`}};function oo(n,s){return Ot(new Error(i1[n](s)),{type:n,[vy]:!0},s)}function ri(n,s){return n instanceof Error&&vy in n&&(s==null||!!(n.type&s))}const s1=["params","query","hash"];function o1(n){if(typeof n=="string")return n;if(n.path!=null)return n.path;const s={};for(const l of s1)l in n&&(s[l]=n[l]);return JSON.stringify(s,null,2)}function a1(n){const s={};if(n===""||n==="?")return s;const l=(n[0]==="?"?n.slice(1):n).split("&");for(let d=0;d<l.length;++d){const f=l[d].replace(hy," "),v=f.indexOf("="),_=so(v<0?f:f.slice(0,v)),w=v<0?null:so(f.slice(v+1));if(_ in s){let R=s[_];or(R)||(R=s[_]=[R]),R.push(w)}else s[_]=w}return s}function Mg(n){let s="";for(let l in n){const d=n[l];if(l=VM(l),d==null){d!==void 0&&(s+=(s.length?"&":"")+l);continue}(or(d)?d.map(f=>f&&rd(f)):[d&&rd(d)]).forEach(f=>{f!==void 0&&(s+=(s.length?"&":"")+l,f!=null&&(s+="="+f))})}return s}function l1(n){const s={};for(const l in n){const d=n[l];d!==void 0&&(s[l]=or(d)?d.map(f=>f==null?null:""+f):d==null?d:""+d)}return s}const c1=Symbol("router view location matched"),Sg=Symbol("router view depth"),Hc=Symbol("router"),yy=Symbol("route location"),od=Symbol("router view location");function $o(){let n=[];function s(d){return n.push(d),()=>{const f=n.indexOf(d);f>-1&&n.splice(f,1)}}function l(){n=[]}return{add:s,list:()=>n.slice(),reset:l}}function Pi(n,s,l,d,f,v=_=>_()){const _=d&&(d.enterCallbacks[f]=d.enterCallbacks[f]||[]);return()=>new Promise((w,R)=>{const L=P=>{P===!1?R(oo(Kt.NAVIGATION_ABORTED,{from:l,to:s})):P instanceof Error?R(P):_c(P)?R(oo(Kt.NAVIGATION_GUARD_REDIRECT,{from:s,to:P})):(_&&d.enterCallbacks[f]===_&&typeof P=="function"&&_.push(P),w())},T=v(()=>n.call(d&&d.instances[f],s,l,u1(L,s,l)));let E=Promise.resolve(T);if(n.length<3&&(E=E.then(L)),n.length>2){const P=`The "next" callback was never called inside of ${n.name?'"'+n.name+'"':""}:
${n.toString()}
. If you are returning a value instead of calling "next", make sure to remove the "next" parameter from your function.`;if(typeof T=="object"&&"then"in T)E=E.then(C=>L._called?C:(vt(P),Promise.reject(new Error("Invalid navigation guard"))));else if(T!==void 0&&!L._called){vt(P),R(new Error("Invalid navigation guard"));return}}E.catch(P=>R(P))})}function u1(n,s,l){let d=0;return function(){d++===1&&vt(`The "next" callback was called more than once in one navigation guard when going from "${l.fullPath}" to "${s.fullPath}". It should be called exactly one time in each navigation guard. This will fail in production.`),n._called=!0,d===1&&n.apply(null,arguments)}}function Oh(n,s,l,d,f=v=>v()){const v=[];for(const _ of n){!_.components&&_.children&&!_.children.length&&vt(`Record with path "${_.path}" is either missing a "component(s)" or "children" property.`);for(const w in _.components){let R=_.components[w];{if(!R||typeof R!="object"&&typeof R!="function")throw vt(`Component "${w}" in record with path "${_.path}" is not a valid component. Received "${String(R)}".`),new Error("Invalid route component");if("then"in R){vt(`Component "${w}" in record with path "${_.path}" is a Promise instead of a function that returns a Promise. Did you write "import('./MyPage.vue')" instead of "() => import('./MyPage.vue')" ? This will break in production if not fixed.`);const L=R;R=()=>L}else R.__asyncLoader&&!R.__warnedDefineAsync&&(R.__warnedDefineAsync=!0,vt(`Component "${w}" in record with path "${_.path}" is defined using "defineAsyncComponent()". Write "() => import('./MyPage.vue')" instead of "defineAsyncComponent(() => import('./MyPage.vue'))".`))}if(!(s!=="beforeRouteEnter"&&!_.instances[w]))if(cy(R)){const L=(R.__vccOpts||R)[s];L&&v.push(Pi(L,l,d,_,w,f))}else{let L=R();"catch"in L||(vt(`Component "${w}" in record with path "${_.path}" is a function that does not return a Promise. If you were passing a functional component, make sure to add a "displayName" to the component. This will break in production if not fixed.`),L=Promise.resolve(L)),v.push(()=>L.then(T=>{if(!T)throw new Error(`Couldn't resolve component "${w}" at "${_.path}"`);const E=IM(T)?T.default:T;_.mods[w]=T,_.components[w]=E;const P=(E.__vccOpts||E)[s];return P&&Pi(P,l,d,_,w,f)()}))}}}return v}function h1(n,s){const l=[],d=[],f=[],v=Math.max(s.matched.length,n.matched.length);for(let _=0;_<v;_++){const w=s.matched[_];w&&(n.matched.find(L=>ki(L,w))?d.push(w):l.push(w));const R=n.matched[_];R&&(s.matched.find(L=>ki(L,R))||f.push(R))}return[l,d,f]}function Jo(n,s){const l=Ot({},n,{matched:n.matched.map(d=>w1(d,["instances","children","aliasOf"]))});return{_custom:{type:null,readOnly:!0,display:n.fullPath,tooltip:s,value:l}}}function $l(n){return{_custom:{display:n}}}let d1=0;function p1(n,s,l){if(s.__hasDevtools)return;s.__hasDevtools=!0;const d=d1++;PM({id:"org.vuejs.router"+(d?"."+d:""),label:"Vue Router",packageName:"vue-router",homepage:"https://router.vuejs.org",logo:"https://router.vuejs.org/logo.png",componentStateTypes:["Routing"],app:n},f=>{typeof f.now!="function"&&vt("[Vue Router]: You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html."),f.on.inspectComponent((T,E)=>{T.instanceData&&T.instanceData.state.push({type:"Routing",key:"$route",editable:!1,value:Jo(s.currentRoute.value,"Current Route")})}),f.on.visitComponentTree(({treeNode:T,componentInstance:E})=>{if(E.__vrv_devtools){const P=E.__vrv_devtools;T.tags.push({label:(P.name?`${P.name.toString()}: `:"")+P.path,textColor:0,tooltip:"This component is rendered by &lt;router-view&gt;",backgroundColor:xy})}or(E.__vrl_devtools)&&(E.__devtoolsApi=f,E.__vrl_devtools.forEach(P=>{let C=P.route.path,z=wy,j="",ne=0;P.error?(C=P.error,z=y1,ne=x1):P.isExactActive?(z=by,j="This is exactly active"):P.isActive&&(z=_y,j="This link is active"),T.tags.push({label:C,textColor:ne,tooltip:j,backgroundColor:z})}))}),ua(s.currentRoute,()=>{R(),f.notifyComponentUpdate(),f.sendInspectorTree(w),f.sendInspectorState(w)});const v="router:navigations:"+d;f.addTimelineLayer({id:v,label:`Router${d?" "+d:""} Navigations`,color:4237508}),s.onError((T,E)=>{f.addTimelineEvent({layerId:v,event:{title:"Error during Navigation",subtitle:E.fullPath,logType:"error",time:f.now(),data:{error:T},groupId:E.meta.__navigationId}})});let _=0;s.beforeEach((T,E)=>{const P={guard:$l("beforeEach"),from:Jo(E,"Current Location during this navigation"),to:Jo(T,"Target location")};Object.defineProperty(T.meta,"__navigationId",{value:_++}),f.addTimelineEvent({layerId:v,event:{time:f.now(),title:"Start of navigation",subtitle:T.fullPath,data:P,groupId:T.meta.__navigationId}})}),s.afterEach((T,E,P)=>{const C={guard:$l("afterEach")};P?(C.failure={_custom:{type:Error,readOnly:!0,display:P?P.message:"",tooltip:"Navigation Failure",value:P}},C.status=$l("")):C.status=$l(""),C.from=Jo(E,"Current Location during this navigation"),C.to=Jo(T,"Target location"),f.addTimelineEvent({layerId:v,event:{title:"End of navigation",subtitle:T.fullPath,time:f.now(),data:C,logType:P?"warning":"default",groupId:T.meta.__navigationId}})});const w="router-inspector:"+d;f.addInspector({id:w,label:"Routes"+(d?" "+d:""),icon:"book",treeFilterPlaceholder:"Search routes"});function R(){if(!L)return;const T=L;let E=l.getRoutes().filter(P=>!P.parent||!P.parent.record.components);E.forEach(Ey),T.filter&&(E=E.filter(P=>ad(P,T.filter.toLowerCase()))),E.forEach(P=>Sy(P,s.currentRoute.value)),T.rootNodes=E.map(My)}let L;f.on.getInspectorTree(T=>{L=T,T.app===n&&T.inspectorId===w&&R()}),f.on.getInspectorState(T=>{if(T.app===n&&T.inspectorId===w){const E=l.getRoutes().find(P=>P.record.__vd_id===T.nodeId);E&&(T.state={options:m1(E)})}}),f.sendInspectorTree(w),f.sendInspectorState(w)})}function f1(n){return n.optional?n.repeatable?"*":"?":n.repeatable?"+":""}function m1(n){const{record:s}=n,l=[{editable:!1,key:"path",value:s.path}];return s.name!=null&&l.push({editable:!1,key:"name",value:s.name}),l.push({editable:!1,key:"regexp",value:n.re}),n.keys.length&&l.push({editable:!1,key:"keys",value:{_custom:{type:null,readOnly:!0,display:n.keys.map(d=>`${d.name}${f1(d)}`).join(" "),tooltip:"Param keys",value:n.keys}}}),s.redirect!=null&&l.push({editable:!1,key:"redirect",value:s.redirect}),n.alias.length&&l.push({editable:!1,key:"aliases",value:n.alias.map(d=>d.record.path)}),Object.keys(n.record.meta).length&&l.push({editable:!1,key:"meta",value:n.record.meta}),l.push({key:"score",editable:!1,value:{_custom:{type:null,readOnly:!0,display:n.score.map(d=>d.join(", ")).join(" | "),tooltip:"Score used to sort routes",value:n.score}}}),l}const xy=15485081,_y=2450411,by=8702998,g1=2282478,wy=16486972,v1=6710886,y1=16704226,x1=12131356;function My(n){const s=[],{record:l}=n;l.name!=null&&s.push({label:String(l.name),textColor:0,backgroundColor:g1}),l.aliasOf&&s.push({label:"alias",textColor:0,backgroundColor:wy}),n.__vd_match&&s.push({label:"matches",textColor:0,backgroundColor:xy}),n.__vd_exactActive&&s.push({label:"exact",textColor:0,backgroundColor:by}),n.__vd_active&&s.push({label:"active",textColor:0,backgroundColor:_y}),l.redirect&&s.push({label:typeof l.redirect=="string"?`redirect: ${l.redirect}`:"redirects",textColor:16777215,backgroundColor:v1});let d=l.__vd_id;return d==null&&(d=String(_1++),l.__vd_id=d),{id:d,label:l.path,tags:s,children:n.children.map(My)}}let _1=0;const b1=/^\/(.*)\/([a-z]*)$/;function Sy(n,s){const l=s.matched.length&&ki(s.matched[s.matched.length-1],n.record);n.__vd_exactActive=n.__vd_active=l,l||(n.__vd_active=s.matched.some(d=>ki(d,n.record))),n.children.forEach(d=>Sy(d,s))}function Ey(n){n.__vd_match=!1,n.children.forEach(Ey)}function ad(n,s){const l=String(n.re).match(b1);if(n.__vd_match=!1,!l||l.length<3)return!1;if(new RegExp(l[1].replace(/\$$/,""),l[2]).test(s))return n.children.forEach(v=>ad(v,s)),n.record.path!=="/"||s==="/"?(n.__vd_match=n.re.test(s),!0):!1;const d=n.record.path.toLowerCase(),f=so(d);return!s.startsWith("/")&&(f.includes(s)||d.includes(s))||f.startsWith(s)||d.startsWith(s)||n.record.name&&String(n.record.name).includes(s)?!0:n.children.some(v=>ad(v,s))}function w1(n,s){const l={};for(const d in n)s.includes(d)||(l[d]=n[d]);return l}/*!
 * vue-router v4.6.3
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */let M1=()=>location.protocol+"//"+location.host;function Ty(n,s){const{pathname:l,search:d,hash:f}=s,v=n.indexOf("#");if(v>-1){let _=f.includes(n.slice(v))?n.slice(v).length:1,w=f.slice(_);return w[0]!=="/"&&(w="/"+w),xg(w,"")}return xg(l,n)+d+f}function S1(n,s,l,d){let f=[],v=[],_=null;const w=({state:P})=>{const C=Ty(n,location),z=l.value,j=s.value;let ne=0;if(P){if(l.value=C,s.value=P,_&&_===z){_=null;return}ne=j?P.position-j.position:0}else d(C);f.forEach(pe=>{pe(l.value,z,{delta:ne,type:id.pop,direction:ne?ne>0?Ih.forward:Ih.back:Ih.unknown})})};function R(){_=l.value}function L(P){f.push(P);const C=()=>{const z=f.indexOf(P);z>-1&&f.splice(z,1)};return v.push(C),C}function T(){if(document.visibilityState==="hidden"){const{history:P}=window;if(!P.state)return;P.replaceState(Ot({},P.state,{scroll:kc()}),"")}}function E(){for(const P of v)P();v=[],window.removeEventListener("popstate",w),window.removeEventListener("pagehide",T),document.removeEventListener("visibilitychange",T)}return window.addEventListener("popstate",w),window.addEventListener("pagehide",T),document.addEventListener("visibilitychange",T),{pauseListeners:R,listen:L,destroy:E}}function Eg(n,s,l,d=!1,f=!1){return{back:n,current:s,forward:l,replaced:d,position:window.history.length,scroll:f?kc():null}}function E1(n){const{history:s,location:l}=window,d={value:Ty(n,l)},f={value:s.state};f.value||v(d.value,{back:null,current:d.value,forward:null,position:s.length-1,replaced:!0,scroll:null},!0);function v(R,L,T){const E=n.indexOf("#"),P=E>-1?(l.host&&document.querySelector("base")?n:n.slice(E))+R:M1()+n+R;try{s[T?"replaceState":"pushState"](L,"",P),f.value=L}catch(C){vt("Error with push/replace State",C),l[T?"replace":"assign"](P)}}function _(R,L){v(R,Ot({},s.state,Eg(f.value.back,R,f.value.forward,!0),L,{position:f.value.position}),!0),d.value=R}function w(R,L){const T=Ot({},f.value,s.state,{forward:R,scroll:kc()});s.state||vt(`history.state seems to have been manually replaced without preserving the necessary values. Make sure to preserve existing history state if you are manually calling history.replaceState:

history.replaceState(history.state, '', url)

You can find more information at https://router.vuejs.org/guide/migration/#Usage-of-history-state`),v(T.current,T,!0),v(R,Ot({},Eg(d.value,R,null),{position:T.position+1},L),!1),d.value=R}return{location:d,state:f,push:w,replace:_}}function T1(n){n=$M(n);const s=E1(n),l=S1(n,s.state,s.location,s.replace);function d(v,_=!0){_||l.pauseListeners(),history.go(v)}const f=Ot({location:"",base:n,go:d,createHref:QM.bind(null,n)},s,l);return Object.defineProperty(f,"location",{enumerable:!0,get:()=>s.location.value}),Object.defineProperty(f,"state",{enumerable:!0,get:()=>s.state.value}),f}let hs=function(n){return n[n.Static=0]="Static",n[n.Param=1]="Param",n[n.Group=2]="Group",n}({});var dn=function(n){return n[n.Static=0]="Static",n[n.Param=1]="Param",n[n.ParamRegExp=2]="ParamRegExp",n[n.ParamRegExpEnd=3]="ParamRegExpEnd",n[n.EscapeNext=4]="EscapeNext",n}(dn||{});const A1={type:hs.Static,value:""},R1=/[a-zA-Z0-9_]/;function L1(n){if(!n)return[[]];if(n==="/")return[[A1]];if(!n.startsWith("/"))throw new Error(`Route paths should start with a "/": "${n}" should be "/${n}".`);function s(C){throw new Error(`ERR (${l})/"${L}": ${C}`)}let l=dn.Static,d=l;const f=[];let v;function _(){v&&f.push(v),v=[]}let w=0,R,L="",T="";function E(){L&&(l===dn.Static?v.push({type:hs.Static,value:L}):l===dn.Param||l===dn.ParamRegExp||l===dn.ParamRegExpEnd?(v.length>1&&(R==="*"||R==="+")&&s(`A repeatable param (${L}) must be alone in its segment. eg: '/:ids+.`),v.push({type:hs.Param,value:L,regexp:T,repeatable:R==="*"||R==="+",optional:R==="*"||R==="?"})):s("Invalid state to consume buffer"),L="")}function P(){L+=R}for(;w<n.length;){if(R=n[w++],R==="\\"&&l!==dn.ParamRegExp){d=l,l=dn.EscapeNext;continue}switch(l){case dn.Static:R==="/"?(L&&E(),_()):R===":"?(E(),l=dn.Param):P();break;case dn.EscapeNext:P(),l=d;break;case dn.Param:R==="("?l=dn.ParamRegExp:R1.test(R)?P():(E(),l=dn.Static,R!=="*"&&R!=="?"&&R!=="+"&&w--);break;case dn.ParamRegExp:R===")"?T[T.length-1]=="\\"?T=T.slice(0,-1)+R:l=dn.ParamRegExpEnd:T+=R;break;case dn.ParamRegExpEnd:E(),l=dn.Static,R!=="*"&&R!=="?"&&R!=="+"&&w--,T="";break;default:s("Unknown state");break}}return l===dn.ParamRegExp&&s(`Unfinished custom RegExp for param "${L}"`),E(),_(),f}const Tg="[^/]+?",C1={sensitive:!1,strict:!1,start:!0,end:!0};var Bn=function(n){return n[n._multiplier=10]="_multiplier",n[n.Root=90]="Root",n[n.Segment=40]="Segment",n[n.SubSegment=30]="SubSegment",n[n.Static=40]="Static",n[n.Dynamic=20]="Dynamic",n[n.BonusCustomRegExp=10]="BonusCustomRegExp",n[n.BonusWildcard=-50]="BonusWildcard",n[n.BonusRepeatable=-20]="BonusRepeatable",n[n.BonusOptional=-8]="BonusOptional",n[n.BonusStrict=.7000000000000001]="BonusStrict",n[n.BonusCaseSensitive=.25]="BonusCaseSensitive",n}(Bn||{});const P1=/[.+*?^${}()[\]/\\]/g;function I1(n,s){const l=Ot({},C1,s),d=[];let f=l.start?"^":"";const v=[];for(const L of n){const T=L.length?[]:[Bn.Root];l.strict&&!L.length&&(f+="/");for(let E=0;E<L.length;E++){const P=L[E];let C=Bn.Segment+(l.sensitive?Bn.BonusCaseSensitive:0);if(P.type===hs.Static)E||(f+="/"),f+=P.value.replace(P1,"\\$&"),C+=Bn.Static;else if(P.type===hs.Param){const{value:z,repeatable:j,optional:ne,regexp:pe}=P;v.push({name:z,repeatable:j,optional:ne});const ie=pe||Tg;if(ie!==Tg){C+=Bn.BonusCustomRegExp;try{`${ie}`}catch(xe){throw new Error(`Invalid custom RegExp for param "${z}" (${ie}): `+xe.message)}}let ae=j?`((?:${ie})(?:/(?:${ie}))*)`:`(${ie})`;E||(ae=ne&&L.length<2?`(?:/${ae})`:"/"+ae),ne&&(ae+="?"),f+=ae,C+=Bn.Dynamic,ne&&(C+=Bn.BonusOptional),j&&(C+=Bn.BonusRepeatable),ie===".*"&&(C+=Bn.BonusWildcard)}T.push(C)}d.push(T)}if(l.strict&&l.end){const L=d.length-1;d[L][d[L].length-1]+=Bn.BonusStrict}l.strict||(f+="/?"),l.end?f+="$":l.strict&&!f.endsWith("/")&&(f+="(?:/|$)");const _=new RegExp(f,l.sensitive?"":"i");function w(L){const T=L.match(_),E={};if(!T)return null;for(let P=1;P<T.length;P++){const C=T[P]||"",z=v[P-1];E[z.name]=C&&z.repeatable?C.split("/"):C}return E}function R(L){let T="",E=!1;for(const P of n){(!E||!T.endsWith("/"))&&(T+="/"),E=!1;for(const C of P)if(C.type===hs.Static)T+=C.value;else if(C.type===hs.Param){const{value:z,repeatable:j,optional:ne}=C,pe=z in L?L[z]:"";if(or(pe)&&!j)throw new Error(`Provided param "${z}" is an array but it is not repeatable (* or + modifiers)`);const ie=or(pe)?pe.join("/"):pe;if(!ie)if(ne)P.length<2&&(T.endsWith("/")?T=T.slice(0,-1):E=!0);else throw new Error(`Missing required param "${z}"`);T+=ie}}return T||"/"}return{re:_,score:d,keys:v,parse:w,stringify:R}}function O1(n,s){let l=0;for(;l<n.length&&l<s.length;){const d=s[l]-n[l];if(d)return d;l++}return n.length<s.length?n.length===1&&n[0]===Bn.Static+Bn.Segment?-1:1:n.length>s.length?s.length===1&&s[0]===Bn.Static+Bn.Segment?1:-1:0}function Ay(n,s){let l=0;const d=n.score,f=s.score;for(;l<d.length&&l<f.length;){const v=O1(d[l],f[l]);if(v)return v;l++}if(Math.abs(f.length-d.length)===1){if(Ag(d))return 1;if(Ag(f))return-1}return f.length-d.length}function Ag(n){const s=n[n.length-1];return n.length>0&&s[s.length-1]<0}const D1={strict:!1,end:!0,sensitive:!1};function N1(n,s,l){const d=I1(L1(n.path),l);{const v=new Set;for(const _ of d.keys)v.has(_.name)&&vt(`Found duplicated params with name "${_.name}" for path "${n.path}". Only the last one will be available on "$route.params".`),v.add(_.name)}const f=Ot(d,{record:n,parent:s,children:[],alias:[]});return s&&!f.record.aliasOf==!s.record.aliasOf&&s.children.push(f),f}function k1(n,s){const l=[],d=new Map;s=yg(D1,s);function f(E){return d.get(E)}function v(E,P,C){const z=!C,j=Lg(E);z1(j,P),j.aliasOf=C&&C.record;const ne=yg(s,E),pe=[j];if("alias"in E){const xe=typeof E.alias=="string"?[E.alias]:E.alias;for(const Te of xe)pe.push(Lg(Ot({},j,{components:C?C.record.components:j.components,path:Te,aliasOf:C?C.record:j})))}let ie,ae;for(const xe of pe){const{path:Te}=xe;if(P&&Te[0]!=="/"){const Ke=P.record.path,at=Ke[Ke.length-1]==="/"?"":"/";xe.path=P.record.path+(Te&&at+Te)}if(xe.path==="*")throw new Error(`Catch all routes ("*") must now be defined using a param with a custom regexp.
See more at https://router.vuejs.org/guide/migration/#Removed-star-or-catch-all-routes.`);if(ie=N1(xe,P,ne),P&&Te[0]==="/"&&G1(ie,P),C?(C.alias.push(ie),B1(C,ie)):(ae=ae||ie,ae!==ie&&ae.alias.push(ie),z&&E.name&&!Cg(ie)&&(U1(E,P),_(E.name))),Ry(ie)&&R(ie),j.children){const Ke=j.children;for(let at=0;at<Ke.length;at++)v(Ke[at],ie,C&&C.children[at])}C=C||ie}return ae?()=>{_(ae)}:pa}function _(E){if(gy(E)){const P=d.get(E);P&&(d.delete(E),l.splice(l.indexOf(P),1),P.children.forEach(_),P.alias.forEach(_))}else{const P=l.indexOf(E);P>-1&&(l.splice(P,1),E.record.name&&d.delete(E.record.name),E.children.forEach(_),E.alias.forEach(_))}}function w(){return l}function R(E){const P=V1(E,l);l.splice(P,0,E),E.record.name&&!Cg(E)&&d.set(E.record.name,E)}function L(E,P){let C,z={},j,ne;if("name"in E&&E.name){if(C=d.get(E.name),!C)throw oo(Kt.MATCHER_NOT_FOUND,{location:E});{const ae=Object.keys(E.params||{}).filter(xe=>!C.keys.find(Te=>Te.name===xe));ae.length&&vt(`Discarded invalid param(s) "${ae.join('", "')}" when navigating. See https://github.com/vuejs/router/blob/main/packages/router/CHANGELOG.md#414-2022-08-22 for more details.`)}ne=C.record.name,z=Ot(Rg(P.params,C.keys.filter(ae=>!ae.optional).concat(C.parent?C.parent.keys.filter(ae=>ae.optional):[]).map(ae=>ae.name)),E.params&&Rg(E.params,C.keys.map(ae=>ae.name))),j=C.stringify(z)}else if(E.path!=null)j=E.path,j.startsWith("/")||vt(`The Matcher cannot resolve relative paths but received "${j}". Unless you directly called \`matcher.resolve("${j}")\`, this is probably a bug in vue-router. Please open an issue at https://github.com/vuejs/router/issues/new/choose.`),C=l.find(ae=>ae.re.test(j)),C&&(z=C.parse(j),ne=C.record.name);else{if(C=P.name?d.get(P.name):l.find(ae=>ae.re.test(P.path)),!C)throw oo(Kt.MATCHER_NOT_FOUND,{location:E,currentLocation:P});ne=C.record.name,z=Ot({},P.params,E.params),j=C.stringify(z)}const pe=[];let ie=C;for(;ie;)pe.unshift(ie.record),ie=ie.parent;return{name:ne,path:j,params:z,matched:pe,meta:F1(pe)}}n.forEach(E=>v(E));function T(){l.length=0,d.clear()}return{addRoute:v,resolve:L,removeRoute:_,clearRoutes:T,getRoutes:w,getRecordMatcher:f}}function Rg(n,s){const l={};for(const d of s)d in n&&(l[d]=n[d]);return l}function Lg(n){const s={path:n.path,redirect:n.redirect,name:n.name,meta:n.meta||{},aliasOf:n.aliasOf,beforeEnter:n.beforeEnter,props:H1(n),children:n.children||[],instances:{},leaveGuards:new Set,updateGuards:new Set,enterCallbacks:{},components:"components"in n?n.components||null:n.component&&{default:n.component}};return Object.defineProperty(s,"mods",{value:{}}),s}function H1(n){const s={},l=n.props||!1;if("component"in n)s.default=l;else for(const d in n.components)s[d]=typeof l=="object"?l[d]:l;return s}function Cg(n){for(;n;){if(n.record.aliasOf)return!0;n=n.parent}return!1}function F1(n){return n.reduce((s,l)=>Ot(s,l.meta),{})}function ld(n,s){return n.name===s.name&&n.optional===s.optional&&n.repeatable===s.repeatable}function B1(n,s){for(const l of n.keys)if(!l.optional&&!s.keys.find(ld.bind(null,l)))return vt(`Alias "${s.record.path}" and the original record: "${n.record.path}" must have the exact same param named "${l.name}"`);for(const l of s.keys)if(!l.optional&&!n.keys.find(ld.bind(null,l)))return vt(`Alias "${s.record.path}" and the original record: "${n.record.path}" must have the exact same param named "${l.name}"`)}function z1(n,s){s&&s.record.name&&!n.name&&!n.path&&vt(`The route named "${String(s.record.name)}" has a child without a name and an empty path. Using that name won't render the empty path child so you probably want to move the name to the child instead. If this is intentional, add a name to the child route to remove the warning.`)}function U1(n,s){for(let l=s;l;l=l.parent)if(l.record.name===n.name)throw new Error(`A route named "${String(n.name)}" has been added as a ${s===l?"child":"descendant"} of a route with the same name. Route names must be unique and a nested route cannot use the same name as an ancestor.`)}function G1(n,s){for(const l of s.keys)if(!n.keys.find(ld.bind(null,l)))return vt(`Absolute path "${n.record.path}" must have the exact same param named "${l.name}" as its parent "${s.record.path}".`)}function V1(n,s){let l=0,d=s.length;for(;l!==d;){const v=l+d>>1;Ay(n,s[v])<0?d=v:l=v+1}const f=W1(n);return f&&(d=s.lastIndexOf(f,d-1),d<0&&vt(`Finding ancestor route "${f.record.path}" failed for "${n.record.path}"`)),d}function W1(n){let s=n;for(;s=s.parent;)if(Ry(s)&&Ay(n,s)===0)return s}function Ry({record:n}){return!!(n.name||n.components&&Object.keys(n.components).length||n.redirect)}function Pg(n){const s=br(Hc),l=br(yy);let d=!1,f=null;const v=ar(()=>{const T=us(n.to);return(!d||T!==f)&&(_c(T)||(d?vt(`Invalid value for prop "to" in useLink()
- to:`,T,`
- previous to:`,f,`
- props:`,n):vt(`Invalid value for prop "to" in useLink()
- to:`,T,`
- props:`,n)),f=T,d=!0),s.resolve(T)}),_=ar(()=>{const{matched:T}=v.value,{length:E}=T,P=T[E-1],C=l.matched;if(!P||!C.length)return-1;const z=C.findIndex(ki.bind(null,P));if(z>-1)return z;const j=Ig(T[E-2]);return E>1&&Ig(P)===j&&C[C.length-1].path!==j?C.findIndex(ki.bind(null,T[E-2])):z}),w=ar(()=>_.value>-1&&Z1(l.params,v.value.params)),R=ar(()=>_.value>-1&&_.value===l.matched.length-1&&my(l.params,v.value.params));function L(T={}){if(Y1(T)){const E=s[us(n.replace)?"replace":"push"](us(n.to)).catch(pa);return n.viewTransition&&typeof document<"u"&&"startViewTransition"in document&&document.startViewTransition(()=>E),E}return Promise.resolve()}if(oi){const T=Dc();if(T){const E={route:v.value,isActive:w.value,isExactActive:R.value,error:null};T.__vrl_devtools=T.__vrl_devtools||[],T.__vrl_devtools.push(E),vw(()=>{E.route=v.value,E.isActive=w.value,E.isExactActive=R.value,E.error=_c(us(n.to))?null:'Invalid "to" value'},{flush:"post"})}}return{route:v,href:ar(()=>v.value.href),isActive:w,isExactActive:R,navigate:L}}function j1(n){return n.length===1?n[0]:n}const q1=Cv({name:"RouterLink",compatConfig:{MODE:3},props:{to:{type:[String,Object],required:!0},replace:Boolean,activeClass:String,exactActiveClass:String,custom:Boolean,ariaCurrentValue:{type:String,default:"page"},viewTransition:Boolean},useLink:Pg,setup(n,{slots:s}){const l=Lc(Pg(n)),{options:d}=br(Hc),f=ar(()=>({[Og(n.activeClass,d.linkActiveClass,"router-link-active")]:l.isActive,[Og(n.exactActiveClass,d.linkExactActiveClass,"router-link-exact-active")]:l.isExactActive}));return()=>{const v=s.default&&j1(s.default(l));return n.custom?v:oy("a",{"aria-current":l.isExactActive?n.ariaCurrentValue:null,href:l.href,onClick:l.navigate,class:f.value},v)}}}),X1=q1;function Y1(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey)&&!n.defaultPrevented&&!(n.button!==void 0&&n.button!==0)){if(n.currentTarget&&n.currentTarget.getAttribute){const s=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(s))return}return n.preventDefault&&n.preventDefault(),!0}}function Z1(n,s){for(const l in s){const d=s[l],f=n[l];if(typeof d=="string"){if(d!==f)return!1}else if(!or(f)||f.length!==d.length||d.some((v,_)=>v!==f[_]))return!1}return!0}function Ig(n){return n?n.aliasOf?n.aliasOf.path:n.path:""}const Og=(n,s,l)=>n??s??l,K1=Cv({name:"RouterView",inheritAttrs:!1,props:{name:{type:String,default:"default"},route:Object},compatConfig:{MODE:3},setup(n,{attrs:s,slots:l}){J1();const d=br(od),f=ar(()=>n.route||d.value),v=br(Sg,0),_=ar(()=>{let L=us(v);const{matched:T}=f.value;let E;for(;(E=T[L])&&!E.components;)L++;return L}),w=ar(()=>f.value.matched[_.value]);nc(Sg,ar(()=>_.value+1)),nc(c1,w),nc(od,f);const R=ir();return ua(()=>[R.value,w.value,n.name],([L,T,E],[P,C,z])=>{T&&(T.instances[E]=L,C&&C!==T&&L&&L===P&&(T.leaveGuards.size||(T.leaveGuards=C.leaveGuards),T.updateGuards.size||(T.updateGuards=C.updateGuards))),L&&T&&(!C||!ki(T,C)||!P)&&(T.enterCallbacks[E]||[]).forEach(j=>j(L))},{flush:"post"}),()=>{const L=f.value,T=n.name,E=w.value,P=E&&E.components[T];if(!P)return Dg(l.default,{Component:P,route:L});const C=E.props[T],z=C?C===!0?L.params:typeof C=="function"?C(L):C:null,ne=oy(P,Ot({},z,s,{onVnodeUnmounted:pe=>{pe.component.isUnmounted&&(E.instances[T]=null)},ref:R}));if(oi&&ne.ref){const pe={depth:_.value,name:E.name,path:E.path,meta:E.meta};(or(ne.ref)?ne.ref.map(ie=>ie.i):[ne.ref.i]).forEach(ie=>{ie.__vrv_devtools=pe})}return Dg(l.default,{Component:ne,route:L})||ne}}});function Dg(n,s){if(!n)return null;const l=n(s);return l.length===1?l[0]:l}const $1=K1;function J1(){const n=Dc(),s=n.parent&&n.parent.type.name,l=n.parent&&n.parent.subTree&&n.parent.subTree.type;if(s&&(s==="KeepAlive"||s.includes("Transition"))&&typeof l=="object"&&l.name==="RouterView"){const d=s==="KeepAlive"?"keep-alive":"transition";vt(`<router-view> can no longer be used directly inside <transition> or <keep-alive>.
Use slot props instead:

<router-view v-slot="{ Component }">
  <${d}>
    <component :is="Component" />
  </${d}>
</router-view>`)}}function Q1(n){const s=k1(n.routes,n),l=n.parseQuery||a1,d=n.stringifyQuery||Mg,f=n.history;if(!f)throw new Error('Provide the "history" option when calling "createRouter()": https://router.vuejs.org/api/interfaces/RouterOptions.html#history');const v=$o(),_=$o(),w=$o(),R=Z_(Ai);let L=Ai;oi&&n.scrollBehavior&&"scrollRestoration"in history&&(history.scrollRestoration="manual");const T=Ch.bind(null,se=>""+se),E=Ch.bind(null,jM),P=Ch.bind(null,so);function C(se,Fe){let Ne,Ye;return gy(se)?(Ne=s.getRecordMatcher(se),Ne||vt(`Parent route "${String(se)}" not found when adding child route`,Fe),Ye=Fe):Ye=se,s.addRoute(Ye,Ne)}function z(se){const Fe=s.getRecordMatcher(se);Fe?s.removeRoute(Fe):vt(`Cannot remove non-existent route "${String(se)}"`)}function j(){return s.getRoutes().map(se=>se.record)}function ne(se){return!!s.getRecordMatcher(se)}function pe(se,Fe){if(Fe=Ot({},Fe||R.value),typeof se=="string"){const F=Ph(l,se,Fe.path),$=s.resolve({path:F.path},Fe),_e=f.createHref(F.fullPath);return _e.startsWith("//")?vt(`Location "${se}" resolved to "${_e}". A resolved location cannot start with multiple slashes.`):$.matched.length||vt(`No match found for location with path "${se}"`),Ot(F,$,{params:P($.params),hash:so(F.hash),redirectedFrom:void 0,href:_e})}if(!_c(se))return vt(`router.resolve() was passed an invalid location. This will fail in production.
- Location:`,se),pe({});let Ne;if(se.path!=null)"params"in se&&!("name"in se)&&Object.keys(se.params).length&&vt(`Path "${se.path}" was passed with params but they will be ignored. Use a named route alongside params instead.`),Ne=Ot({},se,{path:Ph(l,se.path,Fe.path).path});else{const F=Ot({},se.params);for(const $ in F)F[$]==null&&delete F[$];Ne=Ot({},se,{params:E(F)}),Fe.params=E(Fe.params)}const Ye=s.resolve(Ne,Fe),$e=se.hash||"";$e&&!$e.startsWith("#")&&vt(`A \`hash\` should always start with the character "#". Replace "${$e}" with "#${$e}".`),Ye.params=T(P(Ye.params));const Pt=YM(d,Ot({},se,{hash:GM($e),path:Ye.path})),D=f.createHref(Pt);return D.startsWith("//")?vt(`Location "${se}" resolved to "${D}". A resolved location cannot start with multiple slashes.`):Ye.matched.length||vt(`No match found for location with path "${se.path!=null?se.path:se}"`),Ot({fullPath:Pt,hash:$e,query:d===Mg?l1(se.query):se.query||{}},Ye,{redirectedFrom:void 0,href:D})}function ie(se){return typeof se=="string"?Ph(l,se,R.value.path):Ot({},se)}function ae(se,Fe){if(L!==se)return oo(Kt.NAVIGATION_CANCELLED,{from:Fe,to:se})}function xe(se){return at(se)}function Te(se){return xe(Ot(ie(se),{replace:!0}))}function Ke(se,Fe){const Ne=se.matched[se.matched.length-1];if(Ne&&Ne.redirect){const{redirect:Ye}=Ne;let $e=typeof Ye=="function"?Ye(se,Fe):Ye;if(typeof $e=="string"&&($e=$e.includes("?")||$e.includes("#")?$e=ie($e):{path:$e},$e.params={}),$e.path==null&&!("name"in $e))throw vt(`Invalid redirect found:
${JSON.stringify($e,null,2)}
 when navigating to "${se.fullPath}". A redirect must contain a name or path. This will break in production.`),new Error("Invalid redirect");return Ot({query:se.query,hash:se.hash,params:$e.path!=null?{}:se.params},$e)}}function at(se,Fe){const Ne=L=pe(se),Ye=R.value,$e=se.state,Pt=se.force,D=se.replace===!0,F=Ke(Ne,Ye);if(F)return at(Ot(ie(F),{state:typeof F=="object"?Ot({},$e,F.state):$e,force:Pt,replace:D}),Fe||Ne);const $=Ne;$.redirectedFrom=Fe;let _e;return!Pt&&_g(d,Ye,Ne)&&(_e=oo(Kt.NAVIGATION_DUPLICATED,{to:$,from:Ye}),Cn(Ye,Ye,!0,!1)),(_e?Promise.resolve(_e):Ct($,Ye)).catch(ue=>ri(ue)?ri(ue,Kt.NAVIGATION_GUARD_REDIRECT)?ue:Vn(ue):et(ue,$,Ye)).then(ue=>{if(ue){if(ri(ue,Kt.NAVIGATION_GUARD_REDIRECT))return _g(d,pe(ue.to),$)&&Fe&&(Fe._count=Fe._count?Fe._count+1:1)>30?(vt(`Detected a possibly infinite redirection in a navigation guard when going from "${Ye.fullPath}" to "${$.fullPath}". Aborting to avoid a Stack Overflow.
 Are you always returning a new location within a navigation guard? That would lead to this error. Only return when redirecting or aborting, that should fix this. This might break in production if not fixed.`),Promise.reject(new Error("Infinite redirect in navigation guard"))):at(Ot({replace:D},ie(ue.to),{state:typeof ue.to=="object"?Ot({},$e,ue.to.state):$e,force:Pt}),Fe||$)}else ue=At($,Ye,!0,D,$e);return Mt($,Ye,ue),ue})}function lt(se,Fe){const Ne=ae(se,Fe);return Ne?Promise.reject(Ne):Promise.resolve()}function pt(se){const Fe=Pn.values().next().value;return Fe&&typeof Fe.runWithContext=="function"?Fe.runWithContext(se):se()}function Ct(se,Fe){let Ne;const[Ye,$e,Pt]=h1(se,Fe);Ne=Oh(Ye.reverse(),"beforeRouteLeave",se,Fe);for(const F of Ye)F.leaveGuards.forEach($=>{Ne.push(Pi($,se,Fe))});const D=lt.bind(null,se,Fe);return Ne.push(D),On(Ne).then(()=>{Ne=[];for(const F of v.list())Ne.push(Pi(F,se,Fe));return Ne.push(D),On(Ne)}).then(()=>{Ne=Oh($e,"beforeRouteUpdate",se,Fe);for(const F of $e)F.updateGuards.forEach($=>{Ne.push(Pi($,se,Fe))});return Ne.push(D),On(Ne)}).then(()=>{Ne=[];for(const F of Pt)if(F.beforeEnter)if(or(F.beforeEnter))for(const $ of F.beforeEnter)Ne.push(Pi($,se,Fe));else Ne.push(Pi(F.beforeEnter,se,Fe));return Ne.push(D),On(Ne)}).then(()=>(se.matched.forEach(F=>F.enterCallbacks={}),Ne=Oh(Pt,"beforeRouteEnter",se,Fe,pt),Ne.push(D),On(Ne))).then(()=>{Ne=[];for(const F of _.list())Ne.push(Pi(F,se,Fe));return Ne.push(D),On(Ne)}).catch(F=>ri(F,Kt.NAVIGATION_CANCELLED)?F:Promise.reject(F))}function Mt(se,Fe,Ne){w.list().forEach(Ye=>pt(()=>Ye(se,Fe,Ne)))}function At(se,Fe,Ne,Ye,$e){const Pt=ae(se,Fe);if(Pt)return Pt;const D=Fe===Ai,F=oi?history.state:{};Ne&&(Ye||D?f.replace(se.fullPath,Ot({scroll:D&&F&&F.scroll},$e)):f.push(se.fullPath,$e)),R.value=se,Cn(se,Fe,Ne,D),Vn()}let Et;function tn(){Et||(Et=f.listen((se,Fe,Ne)=>{if(!In.listening)return;const Ye=pe(se),$e=Ke(Ye,In.currentRoute.value);if($e){at(Ot($e,{replace:!0,force:!0}),Ye).catch(pa);return}L=Ye;const Pt=R.value;oi&&n1(wg(Pt.fullPath,Ne.delta),kc()),Ct(Ye,Pt).catch(D=>ri(D,Kt.NAVIGATION_ABORTED|Kt.NAVIGATION_CANCELLED)?D:ri(D,Kt.NAVIGATION_GUARD_REDIRECT)?(at(Ot(ie(D.to),{force:!0}),Ye).then(F=>{ri(F,Kt.NAVIGATION_ABORTED|Kt.NAVIGATION_DUPLICATED)&&!Ne.delta&&Ne.type===id.pop&&f.go(-1,!1)}).catch(pa),Promise.reject()):(Ne.delta&&f.go(-Ne.delta,!1),et(D,Ye,Pt))).then(D=>{D=D||At(Ye,Pt,!1),D&&(Ne.delta&&!ri(D,Kt.NAVIGATION_CANCELLED)?f.go(-Ne.delta,!1):Ne.type===id.pop&&ri(D,Kt.NAVIGATION_ABORTED|Kt.NAVIGATION_DUPLICATED)&&f.go(-1,!1)),Mt(Ye,Pt,D)}).catch(pa)}))}let zt=$o(),It=$o(),Je;function et(se,Fe,Ne){Vn(se);const Ye=It.list();return Ye.length?Ye.forEach($e=>$e(se,Fe,Ne)):(vt("uncaught error during route navigation:"),console.error(se)),Promise.reject(se)}function Vt(){return Je&&R.value!==Ai?Promise.resolve():new Promise((se,Fe)=>{zt.add([se,Fe])})}function Vn(se){return Je||(Je=!se,tn(),zt.list().forEach(([Fe,Ne])=>se?Ne(se):Fe()),zt.reset()),se}function Cn(se,Fe,Ne,Ye){const{scrollBehavior:$e}=n;if(!oi||!$e)return Promise.resolve();const Pt=!Ne&&r1(wg(se.fullPath,0))||(Ye||!Ne)&&history.state&&history.state.scroll||null;return xv().then(()=>$e(se,Fe,Pt)).then(D=>D&&t1(D)).catch(D=>et(D,se,Fe))}const bn=se=>f.go(se);let cn;const Pn=new Set,In={currentRoute:R,listening:!0,addRoute:C,removeRoute:z,clearRoutes:s.clearRoutes,hasRoute:ne,getRoutes:j,resolve:pe,options:n,push:xe,replace:Te,go:bn,back:()=>bn(-1),forward:()=>bn(1),beforeEach:v.add,beforeResolve:_.add,afterEach:w.add,onError:It.add,isReady:Vt,install(se){se.component("RouterLink",X1),se.component("RouterView",$1),se.config.globalProperties.$router=In,Object.defineProperty(se.config.globalProperties,"$route",{enumerable:!0,get:()=>us(R)}),oi&&!cn&&R.value===Ai&&(cn=!0,xe(f.location).catch(Ye=>{vt("Unexpected error when starting the router:",Ye)}));const Fe={};for(const Ye in Ai)Object.defineProperty(Fe,Ye,{get:()=>R.value[Ye],enumerable:!0});se.provide(Hc,In),se.provide(yy,fv(Fe)),se.provide(od,R);const Ne=se.unmount;Pn.add(se),se.unmount=function(){Pn.delete(se),Pn.size<1&&(L=Ai,Et&&Et(),Et=null,R.value=Ai,cn=!1,Je=!1),Ne()},oi&&p1(se,In,s)}};function On(se){return se.reduce((Fe,Ne)=>Fe.then(()=>pt(Ne)),Promise.resolve())}return In}function eS(){return br(Hc)}const Ly=Symbol("$auth0");function kr(n,s){var l={};for(var d in n)Object.prototype.hasOwnProperty.call(n,d)&&s.indexOf(d)<0&&(l[d]=n[d]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function"){var f=0;for(d=Object.getOwnPropertySymbols(n);f<d.length;f++)s.indexOf(d[f])<0&&Object.prototype.propertyIsEnumerable.call(n,d[f])&&(l[d[f]]=n[d[f]])}return l}var ls=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function Nd(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function kd(n,s){return n(s={exports:{}},s.exports),s.exports}var as=kd(function(n,s){Object.defineProperty(s,"__esModule",{value:!0});var l=function(){function d(){var f=this;this.locked=new Map,this.addToLocked=function(v,_){var w=f.locked.get(v);w===void 0?_===void 0?f.locked.set(v,[]):f.locked.set(v,[_]):_!==void 0&&(w.unshift(_),f.locked.set(v,w))},this.isLocked=function(v){return f.locked.has(v)},this.lock=function(v){return new Promise(function(_,w){f.isLocked(v)?f.addToLocked(v,_):(f.addToLocked(v),_())})},this.unlock=function(v){var _=f.locked.get(v);if(_!==void 0&&_.length!==0){var w=_.pop();f.locked.set(v,_),w!==void 0&&setTimeout(w,0)}else f.locked.delete(v)}}return d.getInstance=function(){return d.instance===void 0&&(d.instance=new d),d.instance},d}();s.default=function(){return l.getInstance()}});Nd(as);var tS=Nd(kd(function(n,s){var l=ls&&ls.__awaiter||function(T,E,P,C){return new(P||(P=Promise))(function(z,j){function ne(ae){try{ie(C.next(ae))}catch(xe){j(xe)}}function pe(ae){try{ie(C.throw(ae))}catch(xe){j(xe)}}function ie(ae){ae.done?z(ae.value):new P(function(xe){xe(ae.value)}).then(ne,pe)}ie((C=C.apply(T,E||[])).next())})},d=ls&&ls.__generator||function(T,E){var P,C,z,j,ne={label:0,sent:function(){if(1&z[0])throw z[1];return z[1]},trys:[],ops:[]};return j={next:pe(0),throw:pe(1),return:pe(2)},typeof Symbol=="function"&&(j[Symbol.iterator]=function(){return this}),j;function pe(ie){return function(ae){return function(xe){if(P)throw new TypeError("Generator is already executing.");for(;ne;)try{if(P=1,C&&(z=2&xe[0]?C.return:xe[0]?C.throw||((z=C.return)&&z.call(C),0):C.next)&&!(z=z.call(C,xe[1])).done)return z;switch(C=0,z&&(xe=[2&xe[0],z.value]),xe[0]){case 0:case 1:z=xe;break;case 4:return ne.label++,{value:xe[1],done:!1};case 5:ne.label++,C=xe[1],xe=[0];continue;case 7:xe=ne.ops.pop(),ne.trys.pop();continue;default:if(!((z=(z=ne.trys).length>0&&z[z.length-1])||xe[0]!==6&&xe[0]!==2)){ne=0;continue}if(xe[0]===3&&(!z||xe[1]>z[0]&&xe[1]<z[3])){ne.label=xe[1];break}if(xe[0]===6&&ne.label<z[1]){ne.label=z[1],z=xe;break}if(z&&ne.label<z[2]){ne.label=z[2],ne.ops.push(xe);break}z[2]&&ne.ops.pop(),ne.trys.pop();continue}xe=E.call(T,ne)}catch(Te){xe=[6,Te],C=0}finally{P=z=0}if(5&xe[0])throw xe[1];return{value:xe[0]?xe[1]:void 0,done:!0}}([ie,ae])}}},f=ls;Object.defineProperty(s,"__esModule",{value:!0});var v="browser-tabs-lock-key",_={key:function(T){return l(f,void 0,void 0,function(){return d(this,function(E){throw new Error("Unsupported")})})},getItem:function(T){return l(f,void 0,void 0,function(){return d(this,function(E){throw new Error("Unsupported")})})},clear:function(){return l(f,void 0,void 0,function(){return d(this,function(T){return[2,window.localStorage.clear()]})})},removeItem:function(T){return l(f,void 0,void 0,function(){return d(this,function(E){throw new Error("Unsupported")})})},setItem:function(T,E){return l(f,void 0,void 0,function(){return d(this,function(P){throw new Error("Unsupported")})})},keySync:function(T){return window.localStorage.key(T)},getItemSync:function(T){return window.localStorage.getItem(T)},clearSync:function(){return window.localStorage.clear()},removeItemSync:function(T){return window.localStorage.removeItem(T)},setItemSync:function(T,E){return window.localStorage.setItem(T,E)}};function w(T){return new Promise(function(E){return setTimeout(E,T)})}function R(T){for(var E="0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz",P="",C=0;C<T;C++)P+=E[Math.floor(Math.random()*E.length)];return P}var L=function(){function T(E){this.acquiredIatSet=new Set,this.storageHandler=void 0,this.id=Date.now().toString()+R(15),this.acquireLock=this.acquireLock.bind(this),this.releaseLock=this.releaseLock.bind(this),this.releaseLock__private__=this.releaseLock__private__.bind(this),this.waitForSomethingToChange=this.waitForSomethingToChange.bind(this),this.refreshLockWhileAcquired=this.refreshLockWhileAcquired.bind(this),this.storageHandler=E,T.waiters===void 0&&(T.waiters=[])}return T.prototype.acquireLock=function(E,P){return P===void 0&&(P=5e3),l(this,void 0,void 0,function(){var C,z,j,ne,pe,ie,ae;return d(this,function(xe){switch(xe.label){case 0:C=Date.now()+R(4),z=Date.now()+P,j=v+"-"+E,ne=this.storageHandler===void 0?_:this.storageHandler,xe.label=1;case 1:return Date.now()<z?[4,w(30)]:[3,8];case 2:return xe.sent(),ne.getItemSync(j)!==null?[3,5]:(pe=this.id+"-"+E+"-"+C,[4,w(Math.floor(25*Math.random()))]);case 3:return xe.sent(),ne.setItemSync(j,JSON.stringify({id:this.id,iat:C,timeoutKey:pe,timeAcquired:Date.now(),timeRefreshed:Date.now()})),[4,w(30)];case 4:return xe.sent(),(ie=ne.getItemSync(j))!==null&&(ae=JSON.parse(ie)).id===this.id&&ae.iat===C?(this.acquiredIatSet.add(C),this.refreshLockWhileAcquired(j,C),[2,!0]):[3,7];case 5:return T.lockCorrector(this.storageHandler===void 0?_:this.storageHandler),[4,this.waitForSomethingToChange(z)];case 6:xe.sent(),xe.label=7;case 7:return C=Date.now()+R(4),[3,1];case 8:return[2,!1]}})})},T.prototype.refreshLockWhileAcquired=function(E,P){return l(this,void 0,void 0,function(){var C=this;return d(this,function(z){return setTimeout(function(){return l(C,void 0,void 0,function(){var j,ne,pe;return d(this,function(ie){switch(ie.label){case 0:return[4,as.default().lock(P)];case 1:return ie.sent(),this.acquiredIatSet.has(P)?(j=this.storageHandler===void 0?_:this.storageHandler,(ne=j.getItemSync(E))===null?(as.default().unlock(P),[2]):((pe=JSON.parse(ne)).timeRefreshed=Date.now(),j.setItemSync(E,JSON.stringify(pe)),as.default().unlock(P),this.refreshLockWhileAcquired(E,P),[2])):(as.default().unlock(P),[2])}})})},1e3),[2]})})},T.prototype.waitForSomethingToChange=function(E){return l(this,void 0,void 0,function(){return d(this,function(P){switch(P.label){case 0:return[4,new Promise(function(C){var z=!1,j=Date.now(),ne=!1;function pe(){if(ne||(window.removeEventListener("storage",pe),T.removeFromWaiting(pe),clearTimeout(ie),ne=!0),!z){z=!0;var ae=50-(Date.now()-j);ae>0?setTimeout(C,ae):C(null)}}window.addEventListener("storage",pe),T.addToWaiting(pe);var ie=setTimeout(pe,Math.max(0,E-Date.now()))})];case 1:return P.sent(),[2]}})})},T.addToWaiting=function(E){this.removeFromWaiting(E),T.waiters!==void 0&&T.waiters.push(E)},T.removeFromWaiting=function(E){T.waiters!==void 0&&(T.waiters=T.waiters.filter(function(P){return P!==E}))},T.notifyWaiters=function(){T.waiters!==void 0&&T.waiters.slice().forEach(function(E){return E()})},T.prototype.releaseLock=function(E){return l(this,void 0,void 0,function(){return d(this,function(P){switch(P.label){case 0:return[4,this.releaseLock__private__(E)];case 1:return[2,P.sent()]}})})},T.prototype.releaseLock__private__=function(E){return l(this,void 0,void 0,function(){var P,C,z,j;return d(this,function(ne){switch(ne.label){case 0:return P=this.storageHandler===void 0?_:this.storageHandler,C=v+"-"+E,(z=P.getItemSync(C))===null?[2]:(j=JSON.parse(z)).id!==this.id?[3,2]:[4,as.default().lock(j.iat)];case 1:ne.sent(),this.acquiredIatSet.delete(j.iat),P.removeItemSync(C),as.default().unlock(j.iat),T.notifyWaiters(),ne.label=2;case 2:return[2]}})})},T.lockCorrector=function(E){for(var P=Date.now()-5e3,C=E,z=[],j=0;;){var ne=C.keySync(j);if(ne===null)break;z.push(ne),j++}for(var pe=!1,ie=0;ie<z.length;ie++){var ae=z[ie];if(ae.includes(v)){var xe=C.getItemSync(ae);if(xe!==null){var Te=JSON.parse(xe);(Te.timeRefreshed===void 0&&Te.timeAcquired<P||Te.timeRefreshed!==void 0&&Te.timeRefreshed<P)&&(C.removeItemSync(ae),pe=!0)}}}pe&&T.notifyWaiters()},T.waiters=void 0,T}();s.default=L}));const nS={timeoutInSeconds:60},Cy={name:"auth0-spa-js",version:"2.10.0"},Py=()=>Date.now();class $t extends Error{constructor(s,l){super(l),this.error=s,this.error_description=l,Object.setPrototypeOf(this,$t.prototype)}static fromPayload({error:s,error_description:l}){return new $t(s,l)}}class Hd extends $t{constructor(s,l,d,f=null){super(s,l),this.state=d,this.appState=f,Object.setPrototypeOf(this,Hd.prototype)}}class Fd extends $t{constructor(s,l,d,f,v=null){super(s,l),this.connection=d,this.state=f,this.appState=v,Object.setPrototypeOf(this,Fd.prototype)}}class _a extends $t{constructor(){super("timeout","Timeout"),Object.setPrototypeOf(this,_a.prototype)}}class Bd extends _a{constructor(s){super(),this.popup=s,Object.setPrototypeOf(this,Bd.prototype)}}class zd extends $t{constructor(s){super("cancelled","Popup closed"),this.popup=s,Object.setPrototypeOf(this,zd.prototype)}}class Ud extends $t{constructor(){super("popup_open","Unable to open a popup for loginWithPopup - window.open returned `null`"),Object.setPrototypeOf(this,Ud.prototype)}}class Gd extends $t{constructor(s,l,d){super(s,l),this.mfa_token=d,Object.setPrototypeOf(this,Gd.prototype)}}class Fc extends $t{constructor(s,l){super("missing_refresh_token",`Missing Refresh Token (audience: '${bc(s,["default"])}', scope: '${bc(l)}')`),this.audience=s,this.scope=l,Object.setPrototypeOf(this,Fc.prototype)}}class Vd extends $t{constructor(s,l){super("missing_scopes",`Missing requested scopes after refresh (audience: '${bc(s,["default"])}', missing scope: '${bc(l)}')`),this.audience=s,this.scope=l,Object.setPrototypeOf(this,Vd.prototype)}}class Bc extends $t{constructor(s){super("use_dpop_nonce","Server rejected DPoP proof: wrong nonce"),this.newDpopNonce=s,Object.setPrototypeOf(this,Bc.prototype)}}function bc(n,s=[]){return n&&!s.includes(n)?n:""}const wc=()=>window.crypto,Qo=()=>{const n="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_~.";let s="";return Array.from(wc().getRandomValues(new Uint8Array(43))).forEach(l=>s+=n[l%n.length]),s},Dh=n=>btoa(n),rS=[{key:"name",type:["string"]},{key:"version",type:["string","number"]},{key:"env",type:["object"]}],iS=n=>Object.keys(n).reduce((s,l)=>{const d=rS.find(f=>f.key===l);return d&&d.type.includes(typeof n[l])&&(s[l]=n[l]),s},{}),cd=n=>{var{clientId:s}=n,l=kr(n,["clientId"]);return new URLSearchParams((d=>Object.keys(d).filter(f=>d[f]!==void 0).reduce((f,v)=>Object.assign(Object.assign({},f),{[v]:d[v]}),{}))(Object.assign({client_id:s},l))).toString()},Ng=async n=>await wc().subtle.digest({name:"SHA-256"},new TextEncoder().encode(n)),kg=n=>(s=>decodeURIComponent(atob(s).split("").map(l=>"%"+("00"+l.charCodeAt(0).toString(16)).slice(-2)).join("")))(n.replace(/_/g,"/").replace(/-/g,"+")),Hg=n=>{const s=new Uint8Array(n);return(l=>{const d={"+":"-","/":"_","=":""};return l.replace(/[+/=]/g,f=>d[f])})(window.btoa(String.fromCharCode(...Array.from(s))))},sS=new TextEncoder,oS=new TextDecoder;function ra(n){return typeof n=="string"?sS.encode(n):oS.decode(n)}function Fg(n){if(typeof n.modulusLength!="number"||n.modulusLength<2048)throw new aS(`${n.name} modulusLength must be at least 2048 bits`)}let ud;Uint8Array.prototype.toBase64?ud=n=>(n instanceof ArrayBuffer&&(n=new Uint8Array(n)),n.toBase64({alphabet:"base64url",omitPadding:!0})):ud=s=>{s instanceof ArrayBuffer&&(s=new Uint8Array(s));const l=[];for(let d=0;d<s.byteLength;d+=32768)l.push(String.fromCharCode.apply(null,s.subarray(d,d+32768)));return btoa(l.join("")).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")};function ia(n){return ud(n)}class Js extends Error{constructor(s){var l;super(s??"operation not supported"),this.name=this.constructor.name,(l=Error.captureStackTrace)===null||l===void 0||l.call(Error,this,this.constructor)}}class aS extends Error{constructor(s){var l;super(s),this.name=this.constructor.name,(l=Error.captureStackTrace)===null||l===void 0||l.call(Error,this,this.constructor)}}function lS(n){switch(n.algorithm.name){case"RSA-PSS":return function(s){if(s.algorithm.hash.name==="SHA-256")return"PS256";throw new Js("unsupported RsaHashedKeyAlgorithm hash name")}(n);case"RSASSA-PKCS1-v1_5":return function(s){if(s.algorithm.hash.name==="SHA-256")return"RS256";throw new Js("unsupported RsaHashedKeyAlgorithm hash name")}(n);case"ECDSA":return function(s){if(s.algorithm.namedCurve==="P-256")return"ES256";throw new Js("unsupported EcKeyAlgorithm namedCurve")}(n);case"Ed25519":return"Ed25519";default:throw new Js("unsupported CryptoKey algorithm name")}}function Iy(n){return n instanceof CryptoKey}function Oy(n){return Iy(n)&&n.type==="public"}async function cS(n,s,l,d,f,v){const _=n==null?void 0:n.privateKey,w=n==null?void 0:n.publicKey;if(!Iy(R=_)||R.type!=="private")throw new TypeError('"keypair.privateKey" must be a private CryptoKey');var R;if(!Oy(w))throw new TypeError('"keypair.publicKey" must be a public CryptoKey');if(w.extractable!==!0)throw new TypeError('"keypair.publicKey.extractable" must be true');if(typeof s!="string")throw new TypeError('"htu" must be a string');if(typeof l!="string")throw new TypeError('"htm" must be a string');if(d!==void 0&&typeof d!="string")throw new TypeError('"nonce" must be a string or undefined');if(f!==void 0&&typeof f!="string")throw new TypeError('"accessToken" must be a string or undefined');return async function(L,T,E){if(E.usages.includes("sign")===!1)throw new TypeError('private CryptoKey instances used for signing assertions must include "sign" in their "usages"');const P=`${ia(ra(JSON.stringify(L)))}.${ia(ra(JSON.stringify(T)))}`;return`${P}.${ia(await crypto.subtle.sign(function(C){switch(C.algorithm.name){case"ECDSA":return{name:C.algorithm.name,hash:"SHA-256"};case"RSA-PSS":return Fg(C.algorithm),{name:C.algorithm.name,saltLength:32};case"RSASSA-PKCS1-v1_5":return Fg(C.algorithm),{name:C.algorithm.name};case"Ed25519":return{name:C.algorithm.name}}throw new Js}(E),E,ra(P)))}`}({alg:lS(_),typ:"dpop+jwt",jwk:await Dy(w)},Object.assign(Object.assign({},v),{iat:Math.floor(Date.now()/1e3),jti:crypto.randomUUID(),htm:l,nonce:d,htu:s,ath:f?ia(await crypto.subtle.digest("SHA-256",ra(f))):void 0}),_)}async function Dy(n){const{kty:s,e:l,n:d,x:f,y:v,crv:_}=await crypto.subtle.exportKey("jwk",n);return{kty:s,crv:_,e:l,n:d,x:f,y:v}}const uS=["authorization_code","refresh_token","urn:ietf:params:oauth:grant-type:token-exchange"],hS=async(n,s)=>{const l=await fetch(n,s);return{ok:l.ok,json:await l.json(),headers:(d=l.headers,[...d].reduce((f,[v,_])=>(f[v]=_,f),{}))};var d},dS=async(n,s,l,d,f,v,_=1e4,w)=>f?(async(R,L,T,E,P,C,z,j)=>{return ne={auth:{audience:L,scope:T},timeout:P,fetchUrl:R,fetchOptions:E,useFormData:z,useMrrt:j},pe=C,new Promise(function(ie,ae){const xe=new MessageChannel;xe.port1.onmessage=function(Te){Te.data.error?ae(new Error(Te.data.error)):ie(Te.data),xe.port1.close()},pe.postMessage(ne,[xe.port2])});var ne,pe})(n,s,l,d,_,f,v,w):(async(R,L,T)=>{const E=new AbortController;let P;return L.signal=E.signal,Promise.race([hS(R,L),new Promise((C,z)=>{P=setTimeout(()=>{E.abort(),z(new Error("Timeout when executing 'fetch'"))},T)})]).finally(()=>{clearTimeout(P)})})(n,d,_);async function Ny(n,s,l,d,f,v,_,w,R,L){if(R){const ae=await R.generateProof({url:n,method:f.method||"GET",nonce:await R.getNonce()});f.headers=Object.assign(Object.assign({},f.headers),{dpop:ae})}let T,E=null;for(let ae=0;ae<3;ae++)try{T=await dS(n,l,d,f,v,_,s,w),E=null;break}catch(xe){E=xe}if(E)throw E;const P=T.json,{error:C,error_description:z}=P,j=kr(P,["error","error_description"]),{headers:ne,ok:pe}=T;let ie;if(R&&(ie=ne["dpop-nonce"],ie&&await R.setNonce(ie)),!pe){const ae=z||`HTTP error. Unable to fetch ${n}`;if(C==="mfa_required")throw new Gd(C,ae,j.mfa_token);if(C==="missing_refresh_token")throw new Fc(l,d);if(C==="use_dpop_nonce"){if(!R||!ie||L)throw new Bc(ie);return Ny(n,s,l,d,f,v,_,w,R,!0)}throw new $t(C||"request_error",ae)}return j}async function pS(n,s){var{baseUrl:l,timeout:d,audience:f,scope:v,auth0Client:_,useFormData:w,useMrrt:R,dpop:L}=n,T=kr(n,["baseUrl","timeout","audience","scope","auth0Client","useFormData","useMrrt","dpop"]);const E=T.grant_type==="urn:ietf:params:oauth:grant-type:token-exchange",P=T.grant_type==="refresh_token"&&R,C=Object.assign(Object.assign(Object.assign(Object.assign({},T),E&&f&&{audience:f}),E&&v&&{scope:v}),P&&{audience:f,scope:v}),z=w?cd(C):JSON.stringify(C),j=(ne=T.grant_type,uS.includes(ne));var ne;return await Ny(`${l}/oauth/token`,d,f||"default",v,{method:"POST",body:z,headers:{"Content-Type":w?"application/x-www-form-urlencoded":"application/json","Auth0-Client":btoa(JSON.stringify(iS(_||Cy)))}},s,w,R,j?L:void 0)}const sc=(...n)=>{return(s=n.filter(Boolean).join(" ").trim().split(/\s+/),Array.from(new Set(s))).join(" ");var s},Jl=(n,s,l)=>{let d;return l&&(d=n[l]),d||(d=n.default),sc(d,s)};class lr{constructor(s,l="@@auth0spajs@@",d){this.prefix=l,this.suffix=d,this.clientId=s.clientId,this.scope=s.scope,this.audience=s.audience}toKey(){return[this.prefix,this.clientId,this.audience,this.scope,this.suffix].filter(Boolean).join("::")}static fromKey(s){const[l,d,f,v]=s.split("::");return new lr({clientId:d,scope:v,audience:f},l)}static fromCacheEntry(s){const{scope:l,audience:d,client_id:f}=s;return new lr({scope:l,audience:d,clientId:f})}}class fS{set(s,l){localStorage.setItem(s,JSON.stringify(l))}get(s){const l=window.localStorage.getItem(s);if(l)try{return JSON.parse(l)}catch{return}}remove(s){localStorage.removeItem(s)}allKeys(){return Object.keys(window.localStorage).filter(s=>s.startsWith("@@auth0spajs@@"))}}class ky{constructor(){this.enclosedCache=function(){let s={};return{set(l,d){s[l]=d},get(l){const d=s[l];if(d)return d},remove(l){delete s[l]},allKeys:()=>Object.keys(s)}}()}}class mS{constructor(s,l,d){this.cache=s,this.keyManifest=l,this.nowProvider=d||Py}async setIdToken(s,l,d){var f;const v=this.getIdTokenCacheKey(s);await this.cache.set(v,{id_token:l,decodedToken:d}),await((f=this.keyManifest)===null||f===void 0?void 0:f.add(v))}async getIdToken(s){const l=await this.cache.get(this.getIdTokenCacheKey(s.clientId));if(!l&&s.scope&&s.audience){const d=await this.get(s);return!d||!d.id_token||!d.decodedToken?void 0:{id_token:d.id_token,decodedToken:d.decodedToken}}if(l)return{id_token:l.id_token,decodedToken:l.decodedToken}}async get(s,l=0,d=!1,f){var v;let _=await this.cache.get(s.toKey());if(!_){const L=await this.getCacheKeys();if(!L)return;const T=this.matchExistingCacheKey(s,L);if(T&&(_=await this.cache.get(T)),!T&&d&&f!=="cache-only")return this.getEntryWithRefreshToken(s,L)}if(!_)return;const w=await this.nowProvider(),R=Math.floor(w/1e3);return _.expiresAt-l<R?_.body.refresh_token?this.modifiedCachedEntry(_,s):(await this.cache.remove(s.toKey()),void await((v=this.keyManifest)===null||v===void 0?void 0:v.remove(s.toKey()))):_.body}async modifiedCachedEntry(s,l){return s.body={refresh_token:s.body.refresh_token,audience:s.body.audience,scope:s.body.scope},await this.cache.set(l.toKey(),s),{refresh_token:s.body.refresh_token,audience:s.body.audience,scope:s.body.scope}}async set(s){var l;const d=new lr({clientId:s.client_id,scope:s.scope,audience:s.audience}),f=await this.wrapCacheEntry(s);await this.cache.set(d.toKey(),f),await((l=this.keyManifest)===null||l===void 0?void 0:l.add(d.toKey()))}async remove(s,l,d){const f=new lr({clientId:s,scope:d,audience:l});await this.cache.remove(f.toKey())}async clear(s){var l;const d=await this.getCacheKeys();d&&(await d.filter(f=>!s||f.includes(s)).reduce(async(f,v)=>{await f,await this.cache.remove(v)},Promise.resolve()),await((l=this.keyManifest)===null||l===void 0?void 0:l.clear()))}async wrapCacheEntry(s){const l=await this.nowProvider();return{body:s,expiresAt:Math.floor(l/1e3)+s.expires_in}}async getCacheKeys(){var s;return this.keyManifest?(s=await this.keyManifest.get())===null||s===void 0?void 0:s.keys:this.cache.allKeys?this.cache.allKeys():void 0}getIdTokenCacheKey(s){return new lr({clientId:s},"@@auth0spajs@@","@@user@@").toKey()}matchExistingCacheKey(s,l){return l.filter(d=>{var f;const v=lr.fromKey(d),_=new Set(v.scope&&v.scope.split(" ")),w=((f=s.scope)===null||f===void 0?void 0:f.split(" "))||[],R=v.scope&&w.reduce((L,T)=>L&&_.has(T),!0);return v.prefix==="@@auth0spajs@@"&&v.clientId===s.clientId&&v.audience===s.audience&&R})[0]}async getEntryWithRefreshToken(s,l){var d;for(const f of l){const v=lr.fromKey(f);if(v.prefix==="@@auth0spajs@@"&&v.clientId===s.clientId){const _=await this.cache.get(f);if(!((d=_==null?void 0:_.body)===null||d===void 0)&&d.refresh_token)return this.modifiedCachedEntry(_,s)}}}async updateEntry(s,l){var d;const f=await this.getCacheKeys();if(f)for(const v of f){const _=await this.cache.get(v);if(((d=_==null?void 0:_.body)===null||d===void 0?void 0:d.refresh_token)===s){const w=Object.assign(Object.assign({},_.body),{refresh_token:l});await this.set(w)}}}}class gS{constructor(s,l,d){this.storage=s,this.clientId=l,this.cookieDomain=d,this.storageKey=`a0.spajs.txs.${this.clientId}`}create(s){this.storage.save(this.storageKey,s,{daysUntilExpire:1,cookieDomain:this.cookieDomain})}get(){return this.storage.get(this.storageKey)}remove(){this.storage.remove(this.storageKey,{cookieDomain:this.cookieDomain})}}const ea=n=>typeof n=="number",vS=["iss","aud","exp","nbf","iat","jti","azp","nonce","auth_time","at_hash","c_hash","acr","amr","sub_jwk","cnf","sip_from_tag","sip_date","sip_callid","sip_cseq_num","sip_via_branch","orig","dest","mky","events","toe","txn","rph","sid","vot","vtm"];var ds=kd(function(n,s){var l=ls&&ls.__assign||function(){return l=Object.assign||function(R){for(var L,T=1,E=arguments.length;T<E;T++)for(var P in L=arguments[T])Object.prototype.hasOwnProperty.call(L,P)&&(R[P]=L[P]);return R},l.apply(this,arguments)};function d(R,L){if(!L)return"";var T="; "+R;return L===!0?T:T+"="+L}function f(R,L,T){return encodeURIComponent(R).replace(/%(23|24|26|2B|5E|60|7C)/g,decodeURIComponent).replace(/\(/g,"%28").replace(/\)/g,"%29")+"="+encodeURIComponent(L).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g,decodeURIComponent)+function(E){if(typeof E.expires=="number"){var P=new Date;P.setMilliseconds(P.getMilliseconds()+864e5*E.expires),E.expires=P}return d("Expires",E.expires?E.expires.toUTCString():"")+d("Domain",E.domain)+d("Path",E.path)+d("Secure",E.secure)+d("SameSite",E.sameSite)}(T)}function v(R){for(var L={},T=R?R.split("; "):[],E=/(%[\dA-F]{2})+/gi,P=0;P<T.length;P++){var C=T[P].split("="),z=C.slice(1).join("=");z.charAt(0)==='"'&&(z=z.slice(1,-1));try{L[C[0].replace(E,decodeURIComponent)]=z.replace(E,decodeURIComponent)}catch{}}return L}function _(){return v(document.cookie)}function w(R,L,T){document.cookie=f(R,L,l({path:"/"},T))}s.__esModule=!0,s.encode=f,s.parse=v,s.getAll=_,s.get=function(R){return _()[R]},s.set=w,s.remove=function(R,L){w(R,"",l(l({},L),{expires:-1}))}});Nd(ds),ds.encode,ds.parse,ds.getAll;var yS=ds.get,Hy=ds.set,Fy=ds.remove;const $s={get(n){const s=yS(n);if(s!==void 0)return JSON.parse(s)},save(n,s,l){let d={};window.location.protocol==="https:"&&(d={secure:!0,sameSite:"none"}),l!=null&&l.daysUntilExpire&&(d.expires=l.daysUntilExpire),l!=null&&l.cookieDomain&&(d.domain=l.cookieDomain),Hy(n,JSON.stringify(s),d)},remove(n,s){let l={};s!=null&&s.cookieDomain&&(l.domain=s.cookieDomain),Fy(n,l)}},xS={get:n=>$s.get(n)||$s.get(`_legacy_${n}`),save(n,s,l){let d={};window.location.protocol==="https:"&&(d={secure:!0}),l!=null&&l.daysUntilExpire&&(d.expires=l.daysUntilExpire),l!=null&&l.cookieDomain&&(d.domain=l.cookieDomain),Hy(`_legacy_${n}`,JSON.stringify(s),d),$s.save(n,s,l)},remove(n,s){let l={};s!=null&&s.cookieDomain&&(l.domain=s.cookieDomain),Fy(n,l),$s.remove(n,s),$s.remove(`_legacy_${n}`,s)}},_S={get(n){if(typeof sessionStorage>"u")return;const s=sessionStorage.getItem(n);return s!=null?JSON.parse(s):void 0},save(n,s){sessionStorage.setItem(n,JSON.stringify(s))},remove(n){sessionStorage.removeItem(n)}};var cs;(function(n){n.Code="code",n.ConnectCode="connect_code"})(cs||(cs={}));var Nh,bS=function(n){return Nh=Nh||function(s,l,d){var f=function(R,L){var T=atob(R);return T}(s),v=f.indexOf(`
`,10)+1,_=f.substring(v)+"",w=new Blob([_],{type:"application/javascript"});return URL.createObjectURL(w)}("Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwohZnVuY3Rpb24oKXsidXNlIHN0cmljdCI7Y2xhc3MgZSBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKHQscil7c3VwZXIociksdGhpcy5lcnJvcj10LHRoaXMuZXJyb3JfZGVzY3JpcHRpb249cixPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcyxlLnByb3RvdHlwZSl9c3RhdGljIGZyb21QYXlsb2FkKHtlcnJvcjp0LGVycm9yX2Rlc2NyaXB0aW9uOnJ9KXtyZXR1cm4gbmV3IGUodCxyKX19Y2xhc3MgdCBleHRlbmRzIGV7Y29uc3RydWN0b3IoZSxzKXtzdXBlcigibWlzc2luZ19yZWZyZXNoX3Rva2VuIixgTWlzc2luZyBSZWZyZXNoIFRva2VuIChhdWRpZW5jZTogJyR7cihlLFsiZGVmYXVsdCJdKX0nLCBzY29wZTogJyR7cihzKX0nKWApLHRoaXMuYXVkaWVuY2U9ZSx0aGlzLnNjb3BlPXMsT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsdC5wcm90b3R5cGUpfX1mdW5jdGlvbiByKGUsdD1bXSl7cmV0dXJuIGUmJiF0LmluY2x1ZGVzKGUpP2U6IiJ9ImZ1bmN0aW9uIj09dHlwZW9mIFN1cHByZXNzZWRFcnJvciYmU3VwcHJlc3NlZEVycm9yO2NvbnN0IHM9ZT0+e3ZhcntjbGllbnRJZDp0fT1lLHI9ZnVuY3Rpb24oZSx0KXt2YXIgcj17fTtmb3IodmFyIHMgaW4gZSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxzKSYmdC5pbmRleE9mKHMpPDAmJihyW3NdPWVbc10pO2lmKG51bGwhPWUmJiJmdW5jdGlvbiI9PXR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgbz0wO2ZvcihzPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7bzxzLmxlbmd0aDtvKyspdC5pbmRleE9mKHNbb10pPDAmJk9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlLHNbb10pJiYocltzW29dXT1lW3Nbb11dKX1yZXR1cm4gcn0oZSxbImNsaWVudElkIl0pO3JldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zKChlPT5PYmplY3Qua2V5cyhlKS5maWx0ZXIoKHQ9PnZvaWQgMCE9PWVbdF0pKS5yZWR1Y2UoKCh0LHIpPT5PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdCkse1tyXTplW3JdfSkpLHt9KSkoT2JqZWN0LmFzc2lnbih7Y2xpZW50X2lkOnR9LHIpKSkudG9TdHJpbmcoKX07bGV0IG89e307Y29uc3Qgbj0oZSx0KT0+YCR7ZX18JHt0fWA7YWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsKGFzeW5jKHtkYXRhOnt0aW1lb3V0OmUsYXV0aDpyLGZldGNoVXJsOmksZmV0Y2hPcHRpb25zOmMsdXNlRm9ybURhdGE6YSx1c2VNcnJ0OmZ9LHBvcnRzOltwXX0pPT57bGV0IGgsdSxsPXt9O2NvbnN0e2F1ZGllbmNlOmQsc2NvcGU6eX09cnx8e307dHJ5e2NvbnN0IHI9YT8oZT0+e2NvbnN0IHQ9bmV3IFVSTFNlYXJjaFBhcmFtcyhlKSxyPXt9O3JldHVybiB0LmZvckVhY2goKChlLHQpPT57clt0XT1lfSkpLHJ9KShjLmJvZHkpOkpTT04ucGFyc2UoYy5ib2R5KTtpZighci5yZWZyZXNoX3Rva2VuJiYicmVmcmVzaF90b2tlbiI9PT1yLmdyYW50X3R5cGUpe2lmKHU9KChlLHQpPT5vW24oZSx0KV0pKGQseSksIXUmJmYpe2NvbnN0IGU9by5sYXRlc3RfcmVmcmVzaF90b2tlbix0PSgoZSx0KT0+e2NvbnN0IHI9T2JqZWN0LmtleXMobykuZmluZCgocj0+e2lmKCJsYXRlc3RfcmVmcmVzaF90b2tlbiIhPT1yKXtjb25zdCBzPSgoZSx0KT0+dC5zdGFydHNXaXRoKGAke2V9fGApKSh0LHIpLG89ci5zcGxpdCgifCIpWzFdLnNwbGl0KCIgIiksbj1lLnNwbGl0KCIgIikuZXZlcnkoKGU9Pm8uaW5jbHVkZXMoZSkpKTtyZXR1cm4gcyYmbn19KSk7cmV0dXJuISFyfSkoeSxkKTtlJiYhdCYmKHU9ZSl9aWYoIXUpdGhyb3cgbmV3IHQoZCx5KTtjLmJvZHk9YT9zKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxyKSx7cmVmcmVzaF90b2tlbjp1fSkpOkpTT04uc3RyaW5naWZ5KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxyKSx7cmVmcmVzaF90b2tlbjp1fSkpfWxldCBqLGs7ImZ1bmN0aW9uIj09dHlwZW9mIEFib3J0Q29udHJvbGxlciYmKGo9bmV3IEFib3J0Q29udHJvbGxlcixjLnNpZ25hbD1qLnNpZ25hbCk7dHJ5e2s9YXdhaXQgUHJvbWlzZS5yYWNlKFsoXz1lLG5ldyBQcm9taXNlKChlPT5zZXRUaW1lb3V0KGUsXykpKSksZmV0Y2goaSxPYmplY3QuYXNzaWduKHt9LGMpKV0pfWNhdGNoKGUpe3JldHVybiB2b2lkIHAucG9zdE1lc3NhZ2Uoe2Vycm9yOmUubWVzc2FnZX0pfWlmKCFrKXJldHVybiBqJiZqLmFib3J0KCksdm9pZCBwLnBvc3RNZXNzYWdlKHtlcnJvcjoiVGltZW91dCB3aGVuIGV4ZWN1dGluZyAnZmV0Y2gnIn0pO2c9ay5oZWFkZXJzLGw9Wy4uLmddLnJlZHVjZSgoKGUsW3Qscl0pPT4oZVt0XT1yLGUpKSx7fSksaD1hd2FpdCBrLmpzb24oKSxoLnJlZnJlc2hfdG9rZW4/KGYmJihvLmxhdGVzdF9yZWZyZXNoX3Rva2VuPWgucmVmcmVzaF90b2tlbixPPXUsYj1oLnJlZnJlc2hfdG9rZW4sT2JqZWN0LmVudHJpZXMobykuZm9yRWFjaCgoKFtlLHRdKT0+e3Q9PT1PJiYob1tlXT1iKX0pKSksKChlLHQscik9PntvW24odCxyKV09ZX0pKGgucmVmcmVzaF90b2tlbixkLHkpLGRlbGV0ZSBoLnJlZnJlc2hfdG9rZW4pOigoZSx0KT0+e2RlbGV0ZSBvW24oZSx0KV19KShkLHkpLHAucG9zdE1lc3NhZ2Uoe29rOmsub2ssanNvbjpoLGhlYWRlcnM6bH0pfWNhdGNoKGUpe3AucG9zdE1lc3NhZ2Uoe29rOiExLGpzb246e2Vycm9yOmUuZXJyb3IsZXJyb3JfZGVzY3JpcHRpb246ZS5tZXNzYWdlfSxoZWFkZXJzOmx9KX12YXIgTyxiLGcsX30pKX0oKTsKCg=="),new Worker(Nh,n)};const kh={};class wS{constructor(s,l){this.cache=s,this.clientId=l,this.manifestKey=this.createManifestKeyFrom(this.clientId)}async add(s){var l;const d=new Set(((l=await this.cache.get(this.manifestKey))===null||l===void 0?void 0:l.keys)||[]);d.add(s),await this.cache.set(this.manifestKey,{keys:[...d]})}async remove(s){const l=await this.cache.get(this.manifestKey);if(l){const d=new Set(l.keys);return d.delete(s),d.size>0?await this.cache.set(this.manifestKey,{keys:[...d]}):await this.cache.remove(this.manifestKey)}}get(){return this.cache.get(this.manifestKey)}clear(){return this.cache.remove(this.manifestKey)}createManifestKeyFrom(s){return`@@auth0spajs@@::${s}`}}const MS={memory:()=>new ky().enclosedCache,localstorage:()=>new fS},Bg=n=>MS[n],zg=n=>{const{openUrl:s,onRedirect:l}=n,d=kr(n,["openUrl","onRedirect"]);return Object.assign(Object.assign({},d),{openUrl:s===!1||s?s:l})},Ug=(n,s)=>{const l=(s==null?void 0:s.split(" "))||[];return((n==null?void 0:n.split(" "))||[]).every(d=>l.includes(d))},is={NONCE:"nonce",KEYPAIR:"keypair"};class SS{constructor(s){this.clientId=s}getVersion(){return 1}createDbHandle(){const s=window.indexedDB.open("auth0-spa-js",this.getVersion());return new Promise((l,d)=>{s.onupgradeneeded=()=>Object.values(is).forEach(f=>s.result.createObjectStore(f)),s.onerror=()=>d(s.error),s.onsuccess=()=>l(s.result)})}async getDbHandle(){return this.dbHandle||(this.dbHandle=await this.createDbHandle()),this.dbHandle}async executeDbRequest(s,l,d){const f=d((await this.getDbHandle()).transaction(s,l).objectStore(s));return new Promise((v,_)=>{f.onsuccess=()=>v(f.result),f.onerror=()=>_(f.error)})}buildKey(s){const l=s?`_${s}`:"auth0";return`${this.clientId}::${l}`}setNonce(s,l){return this.save(is.NONCE,this.buildKey(l),s)}setKeyPair(s){return this.save(is.KEYPAIR,this.buildKey(),s)}async save(s,l,d){await this.executeDbRequest(s,"readwrite",f=>f.put(d,l))}findNonce(s){return this.find(is.NONCE,this.buildKey(s))}findKeyPair(){return this.find(is.KEYPAIR,this.buildKey())}find(s,l){return this.executeDbRequest(s,"readonly",d=>d.get(l))}async deleteBy(s,l){const d=await this.executeDbRequest(s,"readonly",f=>f.getAllKeys());d==null||d.filter(l).map(f=>this.executeDbRequest(s,"readwrite",v=>v.delete(f)))}deleteByClientId(s,l){return this.deleteBy(s,d=>typeof d=="string"&&d.startsWith(`${l}::`))}clearNonces(){return this.deleteByClientId(is.NONCE,this.clientId)}clearKeyPairs(){return this.deleteByClientId(is.KEYPAIR,this.clientId)}}class ES{constructor(s){this.storage=new SS(s)}getNonce(s){return this.storage.findNonce(s)}setNonce(s,l){return this.storage.setNonce(s,l)}async getOrGenerateKeyPair(){let s=await this.storage.findKeyPair();return s||(s=await async function(l,d){var f;let v;return v={name:"ECDSA",namedCurve:"P-256"},crypto.subtle.generateKey(v,(f=d==null?void 0:d.extractable)!==null&&f!==void 0&&f,["sign","verify"])}(0,{extractable:!1}),await this.storage.setKeyPair(s)),s}async generateProof(s){const l=await this.getOrGenerateKeyPair();return function({keyPair:d,url:f,method:v,nonce:_,accessToken:w}){const R=function(L){const T=new URL(L);return T.search="",T.hash="",T.href}(f);return cS(d,R,v,_,w)}(Object.assign({keyPair:l},s))}async calculateThumbprint(){return function(s){return async function(l){if(!Oy(l))throw new TypeError('"publicKey" must be a public CryptoKey');if(l.extractable!==!0)throw new TypeError('"publicKey.extractable" must be true');const d=await Dy(l);let f;switch(d.kty){case"EC":f={crv:d.crv,kty:d.kty,x:d.x,y:d.y};break;case"OKP":f={crv:d.crv,kty:d.kty,x:d.x};break;case"RSA":f={e:d.e,kty:d.kty,n:d.n};break;default:throw new Js("unsupported JWK kty")}return ia(await crypto.subtle.digest({name:"SHA-256"},ra(JSON.stringify(f))))}(s.publicKey)}(await this.getOrGenerateKeyPair())}async clear(){await Promise.all([this.storage.clearNonces(),this.storage.clearKeyPairs()])}}var Qs;(function(n){n.Bearer="Bearer",n.DPoP="DPoP"})(Qs||(Qs={}));class TS{constructor(s,l){this.hooks=l,this.config=Object.assign(Object.assign({},s),{fetch:s.fetch||(typeof window>"u"?fetch:window.fetch.bind(window))})}isAbsoluteUrl(s){return/^(https?:)?\/\//i.test(s)}buildUrl(s,l){if(l){if(this.isAbsoluteUrl(l))return l;if(s)return`${s.replace(/\/?\/$/,"")}/${l.replace(/^\/+/,"")}`}throw new TypeError("`url` must be absolute or `baseUrl` non-empty.")}getAccessToken(s){return this.config.getAccessToken?this.config.getAccessToken(s):this.hooks.getAccessToken(s)}extractUrl(s){return typeof s=="string"?s:s instanceof URL?s.href:s.url}buildBaseRequest(s,l){if(!this.config.baseUrl)return new Request(s,l);const d=this.buildUrl(this.config.baseUrl,this.extractUrl(s)),f=s instanceof Request?new Request(d,s):d;return new Request(f,l)}setAuthorizationHeader(s,l,d=Qs.Bearer){s.headers.set("authorization",`${d} ${l}`)}async setDpopProofHeader(s,l){if(!this.config.dpopNonceId)return;const d=await this.hooks.getDpopNonce(),f=await this.hooks.generateDpopProof({accessToken:l,method:s.method,nonce:d,url:s.url});s.headers.set("dpop",f)}async prepareRequest(s,l){const d=await this.getAccessToken(l);let f,v;typeof d=="string"?(f=this.config.dpopNonceId?Qs.DPoP:Qs.Bearer,v=d):(f=d.token_type,v=d.access_token),this.setAuthorizationHeader(s,v,f),f===Qs.DPoP&&await this.setDpopProofHeader(s,v)}getHeader(s,l){return Array.isArray(s)?new Headers(s).get(l)||"":typeof s.get=="function"?s.get(l)||"":s[l]||""}hasUseDpopNonceError(s){if(s.status!==401)return!1;const l=this.getHeader(s.headers,"www-authenticate");return l.includes("invalid_dpop_nonce")||l.includes("use_dpop_nonce")}async handleResponse(s,l){const d=this.getHeader(s.headers,"dpop-nonce");if(d&&await this.hooks.setDpopNonce(d),!this.hasUseDpopNonceError(s))return s;if(!d||!l.onUseDpopNonceError)throw new Bc(d);return l.onUseDpopNonceError()}async internalFetchWithAuth(s,l,d,f){const v=this.buildBaseRequest(s,l);await this.prepareRequest(v,f);const _=await this.config.fetch(v);return this.handleResponse(_,d)}fetchWithAuth(s,l,d){const f={onUseDpopNonceError:()=>this.internalFetchWithAuth(s,l,Object.assign(Object.assign({},f),{onUseDpopNonceError:void 0}),d)};return this.internalFetchWithAuth(s,l,f,d)}}class AS{constructor(s,l){this.myAccountFetcher=s,this.apiBase=l}async connectAccount(s){const l=await this.myAccountFetcher.fetchWithAuth(`${this.apiBase}v1/connected-accounts/connect`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(s)});return this._handleResponse(l)}async completeAccount(s){const l=await this.myAccountFetcher.fetchWithAuth(`${this.apiBase}v1/connected-accounts/complete`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(s)});return this._handleResponse(l)}async _handleResponse(s){let l;try{l=await s.text(),l=JSON.parse(l)}catch(d){throw new Mc({type:"invalid_json",status:s.status,title:"Invalid JSON response",detail:l||String(d)})}if(s.ok)return l;throw new Mc(l)}}class Mc extends Error{constructor({type:s,status:l,title:d,detail:f,validation_errors:v}){super(f),this.name="MyAccountApiError",this.type=s,this.status=l,this.title=d,this.detail=f,this.validation_errors=v,Object.setPrototypeOf(this,Mc.prototype)}}const Hh=new tS;class RS{constructor(s){let l,d;if(this.userCache=new ky().enclosedCache,this.activeLockKeys=new Set,this.defaultOptions={authorizationParams:{scope:"openid profile email"},useRefreshTokensFallback:!1,useFormData:!0},this._releaseLockOnPageHide=async()=>{const R=Array.from(this.activeLockKeys);for(const L of R)await Hh.releaseLock(L);this.activeLockKeys.clear(),window.removeEventListener("pagehide",this._releaseLockOnPageHide)},this.options=Object.assign(Object.assign(Object.assign({},this.defaultOptions),s),{authorizationParams:Object.assign(Object.assign({},this.defaultOptions.authorizationParams),s.authorizationParams)}),typeof window<"u"&&(()=>{if(!wc())throw new Error("For security reasons, `window.crypto` is required to run `auth0-spa-js`.");if(wc().subtle===void 0)throw new Error(`
      auth0-spa-js must run on a secure origin. See https://github.com/auth0/auth0-spa-js/blob/main/FAQ.md#why-do-i-get-auth0-spa-js-must-run-on-a-secure-origin for more information.
    `)})(),s.cache&&s.cacheLocation&&console.warn("Both `cache` and `cacheLocation` options have been specified in the Auth0Client configuration; ignoring `cacheLocation` and using `cache`."),s.cache)d=s.cache;else{if(l=s.cacheLocation||"memory",!Bg(l))throw new Error(`Invalid cache location "${l}"`);d=Bg(l)()}this.httpTimeoutMs=s.httpTimeoutInSeconds?1e3*s.httpTimeoutInSeconds:1e4,this.cookieStorage=s.legacySameSiteCookie===!1?$s:xS,this.orgHintCookieName=`auth0.${this.options.clientId}.organization_hint`,this.isAuthenticatedCookieName=(R=>`auth0.${this.options.clientId}.is.authenticated`)(),this.sessionCheckExpiryDays=s.sessionCheckExpiryDays||1;const f=s.useCookiesForTransactions?this.cookieStorage:_S;var v;this.scope=((R,L,...T)=>{if(typeof R!="object")return{default:sc(L,R,...T)};let E={default:sc(L,...T)};return Object.keys(R).forEach(P=>{const C=R[P];E[P]=sc(L,C,...T)}),E})(this.options.authorizationParams.scope,"openid",this.options.useRefreshTokens?"offline_access":""),this.transactionManager=new gS(f,this.options.clientId,this.options.cookieDomain),this.nowProvider=this.options.nowProvider||Py,this.cacheManager=new mS(d,d.allKeys?void 0:new wS(d,this.options.clientId),this.nowProvider),this.dpop=this.options.useDpop?new ES(this.options.clientId):void 0,this.domainUrl=(v=this.options.domain,/^https?:\/\//.test(v)?v:`https://${v}`),this.tokenIssuer=((R,L)=>R?R.startsWith("https://")?R:`https://${R}/`:`${L}/`)(this.options.issuer,this.domainUrl);const _=`${this.domainUrl}/me/`,w=this.createFetcher(Object.assign(Object.assign({},this.options.useDpop&&{dpopNonceId:"__auth0_my_account_api__"}),{getAccessToken:()=>this.getTokenSilently({authorizationParams:{scope:"create:me:connected_accounts",audience:_},detailedResponse:!0})}));this.myAccountApi=new AS(w,_),typeof window<"u"&&window.Worker&&this.options.useRefreshTokens&&l==="memory"&&(this.options.workerUrl?this.worker=new Worker(this.options.workerUrl):this.worker=new bS)}_url(s){const l=encodeURIComponent(btoa(JSON.stringify(this.options.auth0Client||Cy)));return`${this.domainUrl}${s}&auth0Client=${l}`}_authorizeUrl(s){return this._url(`/authorize?${cd(s)}`)}async _verifyIdToken(s,l,d){const f=await this.nowProvider();return(_=>{if(!_.id_token)throw new Error("ID token is required but missing");const w=(E=>{const P=E.split("."),[C,z,j]=P;if(P.length!==3||!C||!z||!j)throw new Error("ID token could not be decoded");const ne=JSON.parse(kg(z)),pe={__raw:E},ie={};return Object.keys(ne).forEach(ae=>{pe[ae]=ne[ae],vS.includes(ae)||(ie[ae]=ne[ae])}),{encoded:{header:C,payload:z,signature:j},header:JSON.parse(kg(C)),claims:pe,user:ie}})(_.id_token);if(!w.claims.iss)throw new Error("Issuer (iss) claim must be a string present in the ID token");if(w.claims.iss!==_.iss)throw new Error(`Issuer (iss) claim mismatch in the ID token; expected "${_.iss}", found "${w.claims.iss}"`);if(!w.user.sub)throw new Error("Subject (sub) claim must be a string present in the ID token");if(w.header.alg!=="RS256")throw new Error(`Signature algorithm of "${w.header.alg}" is not supported. Expected the ID token to be signed with "RS256".`);if(!w.claims.aud||typeof w.claims.aud!="string"&&!Array.isArray(w.claims.aud))throw new Error("Audience (aud) claim must be a string or array of strings present in the ID token");if(Array.isArray(w.claims.aud)){if(!w.claims.aud.includes(_.aud))throw new Error(`Audience (aud) claim mismatch in the ID token; expected "${_.aud}" but was not one of "${w.claims.aud.join(", ")}"`);if(w.claims.aud.length>1){if(!w.claims.azp)throw new Error("Authorized Party (azp) claim must be a string present in the ID token when Audience (aud) claim has multiple values");if(w.claims.azp!==_.aud)throw new Error(`Authorized Party (azp) claim mismatch in the ID token; expected "${_.aud}", found "${w.claims.azp}"`)}}else if(w.claims.aud!==_.aud)throw new Error(`Audience (aud) claim mismatch in the ID token; expected "${_.aud}" but found "${w.claims.aud}"`);if(_.nonce){if(!w.claims.nonce)throw new Error("Nonce (nonce) claim must be a string present in the ID token");if(w.claims.nonce!==_.nonce)throw new Error(`Nonce (nonce) claim mismatch in the ID token; expected "${_.nonce}", found "${w.claims.nonce}"`)}if(_.max_age&&!ea(w.claims.auth_time))throw new Error("Authentication Time (auth_time) claim must be a number present in the ID token when Max Age (max_age) is specified");if(w.claims.exp==null||!ea(w.claims.exp))throw new Error("Expiration Time (exp) claim must be a number present in the ID token");if(!ea(w.claims.iat))throw new Error("Issued At (iat) claim must be a number present in the ID token");const R=_.leeway||60,L=new Date(_.now||Date.now()),T=new Date(0);if(T.setUTCSeconds(w.claims.exp+R),L>T)throw new Error(`Expiration Time (exp) claim error in the ID token; current time (${L}) is after expiration time (${T})`);if(w.claims.nbf!=null&&ea(w.claims.nbf)){const E=new Date(0);if(E.setUTCSeconds(w.claims.nbf-R),L<E)throw new Error(`Not Before time (nbf) claim in the ID token indicates that this token can't be used just yet. Current time (${L}) is before ${E}`)}if(w.claims.auth_time!=null&&ea(w.claims.auth_time)){const E=new Date(0);if(E.setUTCSeconds(parseInt(w.claims.auth_time)+_.max_age+R),L>E)throw new Error(`Authentication Time (auth_time) claim in the ID token indicates that too much time has passed since the last end-user authentication. Current time (${L}) is after last auth at ${E}`)}if(_.organization){const E=_.organization.trim();if(E.startsWith("org_")){const P=E;if(!w.claims.org_id)throw new Error("Organization ID (org_id) claim must be a string present in the ID token");if(P!==w.claims.org_id)throw new Error(`Organization ID (org_id) claim mismatch in the ID token; expected "${P}", found "${w.claims.org_id}"`)}else{const P=E.toLowerCase();if(!w.claims.org_name)throw new Error("Organization Name (org_name) claim must be a string present in the ID token");if(P!==w.claims.org_name)throw new Error(`Organization Name (org_name) claim mismatch in the ID token; expected "${P}", found "${w.claims.org_name}"`)}}return w})({iss:this.tokenIssuer,aud:this.options.clientId,id_token:s,nonce:l,organization:d,leeway:this.options.leeway,max_age:(v=this.options.authorizationParams.max_age,typeof v!="string"?v:parseInt(v,10)||void 0),now:f});var v}_processOrgHint(s){s?this.cookieStorage.save(this.orgHintCookieName,s,{daysUntilExpire:this.sessionCheckExpiryDays,cookieDomain:this.options.cookieDomain}):this.cookieStorage.remove(this.orgHintCookieName,{cookieDomain:this.options.cookieDomain})}async _prepareAuthorizeUrl(s,l,d){var f;const v=Dh(Qo()),_=Dh(Qo()),w=Qo(),R=await Ng(w),L=Hg(R),T=await((f=this.dpop)===null||f===void 0?void 0:f.calculateThumbprint()),E=((C,z,j,ne,pe,ie,ae,xe,Te)=>Object.assign(Object.assign(Object.assign({client_id:C.clientId},C.authorizationParams),j),{scope:Jl(z,j.scope,j.audience),response_type:"code",response_mode:xe||"query",state:ne,nonce:pe,redirect_uri:ae||C.authorizationParams.redirect_uri,code_challenge:ie,code_challenge_method:"S256",dpop_jkt:Te}))(this.options,this.scope,s,v,_,L,s.redirect_uri||this.options.authorizationParams.redirect_uri||d,l==null?void 0:l.response_mode,T),P=this._authorizeUrl(E);return{nonce:_,code_verifier:w,scope:E.scope,audience:E.audience||"default",redirect_uri:E.redirect_uri,state:v,url:P}}async loginWithPopup(s,l){var d;if(s=s||{},!(l=l||{}).popup&&(l.popup=(w=>{const R=window.screenX+(window.innerWidth-400)/2,L=window.screenY+(window.innerHeight-600)/2;return window.open("","auth0:authorize:popup",`left=${R},top=${L},width=400,height=600,resizable,scrollbars=yes,status=1`)})(),!l.popup))throw new Ud;const f=await this._prepareAuthorizeUrl(s.authorizationParams||{},{response_mode:"web_message"},window.location.origin);l.popup.location.href=f.url;const v=await(w=>new Promise((R,L)=>{let T;const E=setInterval(()=>{w.popup&&w.popup.closed&&(clearInterval(E),clearTimeout(P),window.removeEventListener("message",T,!1),L(new zd(w.popup)))},1e3),P=setTimeout(()=>{clearInterval(E),L(new Bd(w.popup)),window.removeEventListener("message",T,!1)},1e3*(w.timeoutInSeconds||60));T=function(C){if(C.data&&C.data.type==="authorization_response"){if(clearTimeout(P),clearInterval(E),window.removeEventListener("message",T,!1),w.popup.close(),C.data.response.error)return L($t.fromPayload(C.data.response));R(C.data.response)}},window.addEventListener("message",T)}))(Object.assign(Object.assign({},l),{timeoutInSeconds:l.timeoutInSeconds||this.options.authorizeTimeoutInSeconds||60}));if(f.state!==v.state)throw new $t("state_mismatch","Invalid state");const _=((d=s.authorizationParams)===null||d===void 0?void 0:d.organization)||this.options.authorizationParams.organization;await this._requestToken({audience:f.audience,scope:f.scope,code_verifier:f.code_verifier,grant_type:"authorization_code",code:v.code,redirect_uri:f.redirect_uri},{nonceIn:f.nonce,organization:_})}async getUser(){var s;const l=await this._getIdTokenFromCache();return(s=l==null?void 0:l.decodedToken)===null||s===void 0?void 0:s.user}async getIdTokenClaims(){var s;const l=await this._getIdTokenFromCache();return(s=l==null?void 0:l.decodedToken)===null||s===void 0?void 0:s.claims}async loginWithRedirect(s={}){var l;const d=zg(s),{openUrl:f,fragment:v,appState:_}=d,w=kr(d,["openUrl","fragment","appState"]),R=((l=w.authorizationParams)===null||l===void 0?void 0:l.organization)||this.options.authorizationParams.organization,L=await this._prepareAuthorizeUrl(w.authorizationParams||{}),{url:T}=L,E=kr(L,["url"]);this.transactionManager.create(Object.assign(Object.assign(Object.assign({},E),{appState:_,response_type:cs.Code}),R&&{organization:R}));const P=v?`${T}#${v}`:T;f?await f(P):window.location.assign(P)}async handleRedirectCallback(s=window.location.href){const l=s.split("?").slice(1);if(l.length===0)throw new Error("There are no query params available for parsing.");const d=this.transactionManager.get();if(!d)throw new $t("missing_transaction","Invalid state");this.transactionManager.remove();const f=(v=>{v.indexOf("#")>-1&&(v=v.substring(0,v.indexOf("#")));const _=new URLSearchParams(v);return{state:_.get("state"),code:_.get("code")||void 0,connect_code:_.get("connect_code")||void 0,error:_.get("error")||void 0,error_description:_.get("error_description")||void 0}})(l.join(""));return d.response_type===cs.ConnectCode?this._handleConnectAccountRedirectCallback(f,d):this._handleLoginRedirectCallback(f,d)}async _handleLoginRedirectCallback(s,l){const{code:d,state:f,error:v,error_description:_}=s;if(v)throw new Hd(v,_||v,f,l.appState);if(!l.code_verifier||l.state&&l.state!==f)throw new $t("state_mismatch","Invalid state");const w=l.organization,R=l.nonce,L=l.redirect_uri;return await this._requestToken(Object.assign({audience:l.audience,scope:l.scope,code_verifier:l.code_verifier,grant_type:"authorization_code",code:d},L?{redirect_uri:L}:{}),{nonceIn:R,organization:w}),{appState:l.appState,response_type:cs.Code}}async _handleConnectAccountRedirectCallback(s,l){const{connect_code:d,state:f,error:v,error_description:_}=s;if(v)throw new Fd(v,_||v,l.connection,f,l.appState);if(!d)throw new $t("missing_connect_code","Missing connect code");if(!(l.code_verifier&&l.state&&l.auth_session&&l.redirect_uri&&l.state===f))throw new $t("state_mismatch","Invalid state");const w=await this.myAccountApi.completeAccount({auth_session:l.auth_session,connect_code:d,redirect_uri:l.redirect_uri,code_verifier:l.code_verifier});return Object.assign(Object.assign({},w),{appState:l.appState,response_type:cs.ConnectCode})}async checkSession(s){if(!this.cookieStorage.get(this.isAuthenticatedCookieName)){if(!this.cookieStorage.get("auth0.is.authenticated"))return;this.cookieStorage.save(this.isAuthenticatedCookieName,!0,{daysUntilExpire:this.sessionCheckExpiryDays,cookieDomain:this.options.cookieDomain}),this.cookieStorage.remove("auth0.is.authenticated")}try{await this.getTokenSilently(s)}catch{}}async getTokenSilently(s={}){var l,d;const f=Object.assign(Object.assign({cacheMode:"on"},s),{authorizationParams:Object.assign(Object.assign(Object.assign({},this.options.authorizationParams),s.authorizationParams),{scope:Jl(this.scope,(l=s.authorizationParams)===null||l===void 0?void 0:l.scope,((d=s.authorizationParams)===null||d===void 0?void 0:d.audience)||this.options.authorizationParams.audience)})}),v=await((_,w)=>{let R=kh[w];return R||(R=_().finally(()=>{delete kh[w],R=null}),kh[w]=R),R})(()=>this._getTokenSilently(f),`${this.options.clientId}::${f.authorizationParams.audience}::${f.authorizationParams.scope}`);return s.detailedResponse?v:v==null?void 0:v.access_token}async _getTokenSilently(s){const{cacheMode:l}=s,d=kr(s,["cacheMode"]);if(l!=="off"){const v=await this._getEntryFromCache({scope:d.authorizationParams.scope,audience:d.authorizationParams.audience||"default",clientId:this.options.clientId,cacheMode:l});if(v)return v}if(l==="cache-only")return;const f=`auth0.lock.getTokenSilently.${this.options.clientId}.${d.authorizationParams.audience||"default"}`;if(!await(async(v,_=3)=>{for(let w=0;w<_;w++)if(await v())return!0;return!1})(()=>Hh.acquireLock(f,5e3),10))throw new _a;this.activeLockKeys.add(f),this.activeLockKeys.size===1&&window.addEventListener("pagehide",this._releaseLockOnPageHide);try{if(l!=="off"){const E=await this._getEntryFromCache({scope:d.authorizationParams.scope,audience:d.authorizationParams.audience||"default",clientId:this.options.clientId});if(E)return E}const v=this.options.useRefreshTokens?await this._getTokenUsingRefreshToken(d):await this._getTokenFromIFrame(d),{id_token:_,token_type:w,access_token:R,oauthTokenScope:L,expires_in:T}=v;return Object.assign(Object.assign({id_token:_,token_type:w,access_token:R},L?{scope:L}:null),{expires_in:T})}finally{await Hh.releaseLock(f),this.activeLockKeys.delete(f),this.activeLockKeys.size===0&&window.removeEventListener("pagehide",this._releaseLockOnPageHide)}}async getTokenWithPopup(s={},l={}){var d,f;const v=Object.assign(Object.assign({},s),{authorizationParams:Object.assign(Object.assign(Object.assign({},this.options.authorizationParams),s.authorizationParams),{scope:Jl(this.scope,(d=s.authorizationParams)===null||d===void 0?void 0:d.scope,((f=s.authorizationParams)===null||f===void 0?void 0:f.audience)||this.options.authorizationParams.audience)})});return l=Object.assign(Object.assign({},nS),l),await this.loginWithPopup(v,l),(await this.cacheManager.get(new lr({scope:v.authorizationParams.scope,audience:v.authorizationParams.audience||"default",clientId:this.options.clientId}),void 0,this.options.useMrrt)).access_token}async isAuthenticated(){return!!await this.getUser()}_buildLogoutUrl(s){s.clientId!==null?s.clientId=s.clientId||this.options.clientId:delete s.clientId;const l=s.logoutParams||{},{federated:d}=l,f=kr(l,["federated"]),v=d?"&federated":"";return this._url(`/v2/logout?${cd(Object.assign({clientId:s.clientId},f))}`)+v}async logout(s={}){var l;const d=zg(s),{openUrl:f}=d,v=kr(d,["openUrl"]);s.clientId===null?await this.cacheManager.clear():await this.cacheManager.clear(s.clientId||this.options.clientId),this.cookieStorage.remove(this.orgHintCookieName,{cookieDomain:this.options.cookieDomain}),this.cookieStorage.remove(this.isAuthenticatedCookieName,{cookieDomain:this.options.cookieDomain}),this.userCache.remove("@@user@@"),await((l=this.dpop)===null||l===void 0?void 0:l.clear());const _=this._buildLogoutUrl(v);f?await f(_):f!==!1&&window.location.assign(_)}async _getTokenFromIFrame(s){const l=Object.assign(Object.assign({},s.authorizationParams),{prompt:"none"}),d=this.cookieStorage.get(this.orgHintCookieName);d&&!l.organization&&(l.organization=d);const{url:f,state:v,nonce:_,code_verifier:w,redirect_uri:R,scope:L,audience:T}=await this._prepareAuthorizeUrl(l,{response_mode:"web_message"},window.location.origin);try{if(window.crossOriginIsolated)throw new $t("login_required","The application is running in a Cross-Origin Isolated context, silently retrieving a token without refresh token is not possible.");const E=s.timeoutInSeconds||this.options.authorizeTimeoutInSeconds;let P;try{P=new URL(this.domainUrl).origin}catch{P=this.domainUrl}const C=await((j,ne,pe=60)=>new Promise((ie,ae)=>{const xe=window.document.createElement("iframe");xe.setAttribute("width","0"),xe.setAttribute("height","0"),xe.style.display="none";const Te=()=>{window.document.body.contains(xe)&&(window.document.body.removeChild(xe),window.removeEventListener("message",Ke,!1))};let Ke;const at=setTimeout(()=>{ae(new _a),Te()},1e3*pe);Ke=function(lt){if(lt.origin!=ne||!lt.data||lt.data.type!=="authorization_response")return;const pt=lt.source;pt&&pt.close(),lt.data.response.error?ae($t.fromPayload(lt.data.response)):ie(lt.data.response),clearTimeout(at),window.removeEventListener("message",Ke,!1),setTimeout(Te,2e3)},window.addEventListener("message",Ke,!1),window.document.body.appendChild(xe),xe.setAttribute("src",j)}))(f,P,E);if(v!==C.state)throw new $t("state_mismatch","Invalid state");const z=await this._requestToken(Object.assign(Object.assign({},s.authorizationParams),{code_verifier:w,code:C.code,grant_type:"authorization_code",redirect_uri:R,timeout:s.authorizationParams.timeout||this.httpTimeoutMs}),{nonceIn:_,organization:l.organization});return Object.assign(Object.assign({},z),{scope:L,oauthTokenScope:z.scope,audience:T})}catch(E){throw E.error==="login_required"&&this.logout({openUrl:!1}),E}}async _getTokenUsingRefreshToken(s){const l=await this.cacheManager.get(new lr({scope:s.authorizationParams.scope,audience:s.authorizationParams.audience||"default",clientId:this.options.clientId}),void 0,this.options.useMrrt);if(!(l&&l.refresh_token||this.worker)){if(this.options.useRefreshTokensFallback)return await this._getTokenFromIFrame(s);throw new Fc(s.authorizationParams.audience||"default",s.authorizationParams.scope)}const d=s.authorizationParams.redirect_uri||this.options.authorizationParams.redirect_uri||window.location.origin,f=typeof s.timeoutInSeconds=="number"?1e3*s.timeoutInSeconds:null,v=((T,E,P,C)=>{var z;if(T&&P&&C){if(E.audience!==P)return E.scope;const j=C.split(" "),ne=((z=E.scope)===null||z===void 0?void 0:z.split(" "))||[],pe=ne.every(ie=>j.includes(ie));return j.length>=ne.length&&pe?C:E.scope}return E.scope})(this.options.useMrrt,s.authorizationParams,l==null?void 0:l.audience,l==null?void 0:l.scope);try{const T=await this._requestToken(Object.assign(Object.assign(Object.assign({},s.authorizationParams),{grant_type:"refresh_token",refresh_token:l&&l.refresh_token,redirect_uri:d}),f&&{timeout:f}),{scopesToRequest:v});if(T.refresh_token&&this.options.useMrrt&&(l!=null&&l.refresh_token)&&await this.cacheManager.updateEntry(l.refresh_token,T.refresh_token),this.options.useMrrt&&(_=l==null?void 0:l.audience,w=l==null?void 0:l.scope,R=s.authorizationParams.audience,L=s.authorizationParams.scope,!(_===R&&Ug(L,w)||Ug(v,T.scope)))){if(this.options.useRefreshTokensFallback)return await this._getTokenFromIFrame(s);await this.cacheManager.remove(this.options.clientId,s.authorizationParams.audience,s.authorizationParams.scope);const E=((P,C)=>{const z=(P==null?void 0:P.split(" "))||[],j=(C==null?void 0:C.split(" "))||[];return z.filter(ne=>j.indexOf(ne)==-1).join(",")})(v,T.scope);throw new Vd(s.authorizationParams.audience||"default",E)}return Object.assign(Object.assign({},T),{scope:s.authorizationParams.scope,oauthTokenScope:T.scope,audience:s.authorizationParams.audience||"default"})}catch(T){if((T.message.indexOf("Missing Refresh Token")>-1||T.message&&T.message.indexOf("invalid refresh token")>-1)&&this.options.useRefreshTokensFallback)return await this._getTokenFromIFrame(s);throw T}var _,w,R,L}async _saveEntryInCache(s){const{id_token:l,decodedToken:d}=s,f=kr(s,["id_token","decodedToken"]);this.userCache.set("@@user@@",{id_token:l,decodedToken:d}),await this.cacheManager.setIdToken(this.options.clientId,s.id_token,s.decodedToken),await this.cacheManager.set(f)}async _getIdTokenFromCache(){const s=this.options.authorizationParams.audience||"default",l=this.scope[s],d=await this.cacheManager.getIdToken(new lr({clientId:this.options.clientId,audience:s,scope:l})),f=this.userCache.get("@@user@@");return d&&d.id_token===(f==null?void 0:f.id_token)?f:(this.userCache.set("@@user@@",d),d)}async _getEntryFromCache({scope:s,audience:l,clientId:d,cacheMode:f}){const v=await this.cacheManager.get(new lr({scope:s,audience:l,clientId:d}),60,this.options.useMrrt,f);if(v&&v.access_token){const{token_type:_,access_token:w,oauthTokenScope:R,expires_in:L}=v,T=await this._getIdTokenFromCache();return T&&Object.assign(Object.assign({id_token:T.id_token,token_type:_||"Bearer",access_token:w},R?{scope:R}:null),{expires_in:L})}}async _requestToken(s,l){const{nonceIn:d,organization:f,scopesToRequest:v}=l||{},_=await pS(Object.assign(Object.assign({baseUrl:this.domainUrl,client_id:this.options.clientId,auth0Client:this.options.auth0Client,useFormData:this.options.useFormData,timeout:this.httpTimeoutMs,useMrrt:this.options.useMrrt,dpop:this.dpop},s),{scope:v||s.scope}),this.worker),w=await this._verifyIdToken(_.id_token,d,f);return await this._saveEntryInCache(Object.assign(Object.assign(Object.assign(Object.assign({},_),{decodedToken:w,scope:s.scope,audience:s.audience||"default"}),_.scope?{oauthTokenScope:_.scope}:null),{client_id:this.options.clientId})),this.cookieStorage.save(this.isAuthenticatedCookieName,!0,{daysUntilExpire:this.sessionCheckExpiryDays,cookieDomain:this.options.cookieDomain}),this._processOrgHint(f||w.claims.org_id),Object.assign(Object.assign({},_),{decodedToken:w})}async exchangeToken(s){return this._requestToken({grant_type:"urn:ietf:params:oauth:grant-type:token-exchange",subject_token:s.subject_token,subject_token_type:s.subject_token_type,scope:Jl(this.scope,s.scope,s.audience||this.options.authorizationParams.audience),audience:s.audience||this.options.authorizationParams.audience})}_assertDpop(s){if(!s)throw new Error("`useDpop` option must be enabled before using DPoP.")}getDpopNonce(s){return this._assertDpop(this.dpop),this.dpop.getNonce(s)}setDpopNonce(s,l){return this._assertDpop(this.dpop),this.dpop.setNonce(s,l)}generateDpopProof(s){return this._assertDpop(this.dpop),this.dpop.generateProof(s)}createFetcher(s={}){return new TS(s,{isDpopEnabled:()=>!!this.options.useDpop,getAccessToken:l=>{var d;return this.getTokenSilently({authorizationParams:{scope:(d=l==null?void 0:l.scope)===null||d===void 0?void 0:d.join(" "),audience:l==null?void 0:l.audience},detailedResponse:!0})},getDpopNonce:()=>this.getDpopNonce(s.dpopNonceId),setDpopNonce:l=>this.setDpopNonce(l,s.dpopNonceId),generateDpopProof:l=>this.generateDpopProof(l)})}async connectAccountWithRedirect(s){const{openUrl:l,appState:d,connection:f,scopes:v,authorization_params:_,redirectUri:w=this.options.authorizationParams.redirect_uri||window.location.origin}=s;if(!f)throw new Error("connection is required");const R=Dh(Qo()),L=Qo(),T=await Ng(L),E=Hg(T),{connect_uri:P,connect_params:C,auth_session:z}=await this.myAccountApi.connectAccount({connection:f,scopes:v,redirect_uri:w,state:R,code_challenge:E,code_challenge_method:"S256",authorization_params:_});this.transactionManager.create({state:R,code_verifier:L,auth_session:z,redirect_uri:w,appState:d,connection:f,response_type:cs.ConnectCode});const j=new URL(P);j.searchParams.set("ticket",C.ticket),l?await l(j.toString()):window.location.assign(j)}}function sa(n){n!=null&&n.redirect_uri&&(console.warn("Using `redirect_uri` has been deprecated, please use `authorizationParams.redirect_uri` instead as `redirectUri` will be no longer supported in a future version"),n.authorizationParams=n.authorizationParams||{},n.authorizationParams.redirect_uri=n.redirect_uri,delete n.redirect_uri)}const yr=()=>{console.error("Please ensure Auth0's Vue plugin is correctly installed.")},LS={isLoading:ir(!1),isAuthenticated:ir(!1),user:ir(void 0),idTokenClaims:ir(void 0),error:ir(null),loginWithPopup:yr,loginWithRedirect:yr,getAccessTokenSilently:yr,getAccessTokenWithPopup:yr,logout:yr,checkSession:yr,handleRedirectCallback:yr,getDpopNonce:yr,setDpopNonce:yr,generateDpopProof:yr,createFetcher:yr},CS=ir(LS);class PS{constructor(s,l){var d,f;this.clientOptions=s,this.pluginOptions=l,this.isLoading=ir(!0),this.isAuthenticated=ir(!1),this.user=ir({}),this.idTokenClaims=ir(),this.error=ir(null),d=this,f=["constructor"],Object.getOwnPropertyNames(Object.getPrototypeOf(d)).filter(v=>!f.includes(v)).forEach(v=>d[v]=d[v].bind(d))}install(s){this._client=new RS(Object.assign(Object.assign({},this.clientOptions),{auth0Client:{name:"auth0-vue",version:"2.3.1"}})),this.__checkSession(s.config.globalProperties.$router),s.config.globalProperties.$auth0=this,s.provide(Ly,this),CS.value=this}async loginWithRedirect(s){return sa(s),this._client.loginWithRedirect(s)}async loginWithPopup(s,l){return sa(s),this.__proxy(()=>this._client.loginWithPopup(s,l))}async logout(s){return s!=null&&s.openUrl||(s==null?void 0:s.openUrl)===!1?this.__proxy(()=>this._client.logout(s)):this._client.logout(s)}async getAccessTokenSilently(s={}){return sa(s),this.__proxy(()=>this._client.getTokenSilently(s))}async getAccessTokenWithPopup(s,l){return sa(s),this.__proxy(()=>this._client.getTokenWithPopup(s,l))}async checkSession(s){return this.__proxy(()=>this._client.checkSession(s))}async handleRedirectCallback(s){return this.__proxy(()=>this._client.handleRedirectCallback(s))}async getDpopNonce(s){return this.__proxy(()=>this._client.getDpopNonce(s))}async setDpopNonce(s,l){return this.__proxy(()=>this._client.setDpopNonce(s,l))}async generateDpopProof(s){return this.__proxy(()=>this._client.generateDpopProof(s))}createFetcher(s){return this._client.createFetcher(s)}async __checkSession(s){var l,d,f;const v=window.location.search;try{if((v.includes("code=")||v.includes("error="))&&v.includes("state=")&&!(!((l=this.pluginOptions)===null||l===void 0)&&l.skipRedirectCallback)){const _=await this.handleRedirectCallback(),w=_==null?void 0:_.appState,R=(d=w==null?void 0:w.target)!==null&&d!==void 0?d:"/";return window.history.replaceState({},"","/"),s&&s.push(R),_}await this.checkSession()}catch{window.history.replaceState({},"","/"),s&&s.push(((f=this.pluginOptions)===null||f===void 0?void 0:f.errorPath)||"/")}}async __refreshState(){this.isAuthenticated.value=await this._client.isAuthenticated(),this.user.value=await this._client.getUser(),this.idTokenClaims.value=await this._client.getIdTokenClaims(),this.isLoading.value=!1}async __proxy(s,l=!0){let d;try{d=await s(),this.error.value=null}catch(f){throw this.error.value=f,f}finally{l&&await this.__refreshState()}return d}}function IS(n,s){return sa(n),new PS(n,s)}function OS(){return br(Ly)}const By=(n,s)=>{const l=n.__vccOpts||n;for(const[d,f]of s)l[d]=f;return l},DS={id:"cssmenu"},NS={class:"logo"},kS={id:"login"},HS={__name:"NavMenu",setup(n){const{isAuthenticated:s,getAccessTokenSilently:l,logout:d}=OS(),f=eS(),v=ir(!0),_=ar(()=>s.value&&v.value);Ov(async()=>{if(s.value)try{await l()}catch{v.value=!1,await d({logoutParams:{returnTo:window.location.origin}})}});function w(R){f.push(R)}return(R,L)=>(va(),ey("header",null,[Fn("nav",DS,[Fn("div",NS,[Fn("a",{href:"#",onClick:L[0]||(L[0]=Kl(T=>w("/"),["prevent"]))},[...L[4]||(L[4]=[Fn("img",{width:"50",src:MM,alt:"Cauliflower Logo"},null,-1)])])]),Fn("ul",null,[Fn("li",null,[Fn("a",{href:"#",id:"one",onClick:L[1]||(L[1]=Kl(T=>w("/art"),["prevent"]))},"Art")]),Fn("li",null,[Fn("a",{href:"#",id:"two",onClick:L[2]||(L[2]=Kl(T=>w("/code"),["prevent"]))},"Code")])])]),Fn("div",kS,[Fn("ul",null,[Fn("li",null,[Fn("a",{href:"#",id:"three",class:Tc({authenticated:_.value}),onClick:L[3]||(L[3]=Kl(T=>w("/auth"),["prevent"]))},Kg(_.value?"PROFILE":"LOGIN"),3)])])])]))}},FS=By(HS,[["__scopeId","data-v-cdd2f924"],["__file","/mnt/c/Users/Admin/Documents/Projects/cauliflower.dev/src/components/NavMenu.vue"]]),BS={id:"app-root"},zS={__name:"App",setup(n){return(s,l)=>{const d=Hb("router-view");return va(),ey("div",BS,[En(FS),En(d)])}}},US=By(zS,[["__file","/mnt/c/Users/Admin/Documents/Projects/cauliflower.dev/src/App.vue"]]),GS="modulepreload",VS=function(n,s){return new URL(n,s).href},Gg={},Aa=function(s,l,d){let f=Promise.resolve();if(l&&l.length>0){const _=document.getElementsByTagName("link"),w=document.querySelector("meta[property=csp-nonce]"),R=(w==null?void 0:w.nonce)||(w==null?void 0:w.getAttribute("nonce"));f=Promise.allSettled(l.map(L=>{if(L=VS(L,d),L in Gg)return;Gg[L]=!0;const T=L.endsWith(".css"),E=T?'[rel="stylesheet"]':"";if(!!d)for(let z=_.length-1;z>=0;z--){const j=_[z];if(j.href===L&&(!T||j.rel==="stylesheet"))return}else if(document.querySelector(`link[href="${L}"]${E}`))return;const C=document.createElement("link");if(C.rel=T?"stylesheet":GS,T||(C.as="script"),C.crossOrigin="",C.href=L,R&&C.setAttribute("nonce",R),document.head.appendChild(C),T)return new Promise((z,j)=>{C.addEventListener("load",z),C.addEventListener("error",()=>j(new Error(`Unable to preload CSS for ${L}`)))})}))}function v(_){const w=new Event("vite:preloadError",{cancelable:!0});if(w.payload=_,window.dispatchEvent(w),!w.defaultPrevented)throw _}return f.then(_=>{for(const w of _||[])w.status==="rejected"&&v(w.reason);return s().catch(v)})},WS=()=>Aa(()=>import("./Home-B7j9ZMVE.js"),__vite__mapDeps([0,1]),import.meta.url),jS=()=>Aa(()=>import("./Art-BIm3KAoV.js"),__vite__mapDeps([2,3]),import.meta.url),qS=()=>Aa(()=>import("./Code-I1ya4v3_.js"),__vite__mapDeps([4,5]),import.meta.url),XS=()=>Aa(()=>import("./Auth-aEzh_JkD.js"),__vite__mapDeps([6,7]),import.meta.url),YS=()=>Aa(()=>import("./NotFound-BusaW-sW.js"),__vite__mapDeps([8,9]),import.meta.url),ZS=[{path:"/",component:WS},{path:"/art",component:jS},{path:"/code",component:qS},{path:"/auth",component:XS},{path:"/userinfo",component:()=>{}},{path:"/src/pages/sites/robot-builder/index.html",component:()=>{}},{path:"/src/pages/sites/unicode-hieroglyphs/unicodeLoop.html",component:()=>{}},{path:"/src/pages/sites/tree-fractal/index.html",component:()=>{}},{path:"/src/pages/sites/snake/index.html",component:()=>{}},{path:"/src/pages/sites/divz/index.html",component:()=>{}},{path:"/src/pages/sites/thesis/index.html",component:()=>{}},{path:"/src/pages/sites/ballpit/index.html",component:()=>{}},{path:"/:pathMatch(.*)*",component:YS}],KS=Q1({history:T1("./"),routes:ZS});vM(US).use(KS).use(IS({domain:"dev-bscikzimgp8254nw.us.auth0.com",clientId:"PXUwz6fKHgsaNUQy36Uy6Zj1Sn7XlRdQ",authorizationParams:{redirect_uri:window.location.origin},cacheLocation:"localstorage",useRefreshTokens:!0})).mount("#app");const $S=()=>[{tag:"meta",attrs:{charset:"UTF-8"}},{tag:"meta",attrs:{name:"viewport",content:"width=device-width, initial-scale=1.0"}},{tag:"meta",attrs:{name:"description",content:"Art, code, and creative technology by cauliflower. Explore projects, experiments, and resources for developers and artists."}},{tag:"meta",attrs:{name:"author",content:"cauliflower"}},{tag:"meta",attrs:{name:"keywords",content:"art, code, creative coding, developer, portfolio, generative art, web development, three.js, personal website"}},{tag:"meta",attrs:{name:"theme-color",content:"#222"}},{tag:"link",attrs:{rel:"canonical",href:"https://cauliflower.dev/"}},{tag:"link",attrs:{rel:"stylesheet",href:"../../styles.css"}},{tag:"link",attrs:{rel:"icon",type:"image/png",href:"../../assets/images/Cauliflower.png"}},{tag:"link",attrs:{rel:"preload",href:"../../fonts/Iceberg-Regular.ttf",as:"font",type:"font/ttf",crossorigin:""}},{tag:"meta",attrs:{property:"og:type",content:"website"}},{tag:"meta",attrs:{property:"og:url",content:"https://cauliflower.dev/"}},{tag:"meta",attrs:{property:"og:title",content:"Art & Code by cauliflower"}},{tag:"meta",attrs:{property:"og:description",content:"Art, code, and creative technology by cauliflower. Explore projects, experiments, and resources for developers and artists."}},{tag:"meta",attrs:{property:"og:image",content:"../../assets/images/Cauliflower.png"}},{tag:"meta",attrs:{name:"twitter:card",content:"summary_large_image"}},{tag:"meta",attrs:{name:"twitter:title",content:"Art & Code by cauliflower"}},{tag:"meta",attrs:{name:"twitter:description",content:"Art, code, and creative technology by cauliflower. Explore projects, experiments, and resources for developers and artists."}},{tag:"meta",attrs:{name:"twitter:image",content:"../../assets/images/Cauliflower.png"}},{tag:"meta",attrs:{"http-equiv":"X-UA-Compatible",content:"IE=edge"}}],JS=()=>{$S().forEach(({tag:s,attrs:l})=>{const d=document.createElement(s);Object.entries(l).forEach(([f,v])=>{v!==void 0&&d.setAttribute(f,v)}),document.head.appendChild(d)})};document.title="cauliflower.dev";JS();export{OS as E,rr as F,By as _,Fn as a,va as b,ey as c,tE as d,ir as e,ar as f,Dv as g,En as h,QS as i,Pb as j,nE as k,eS as l,Hb as m,Tc as n,Ov as o,Pw as p,eE as r,Kg as t,us as u,bb as w};
